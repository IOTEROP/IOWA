{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IOWA reference documentation \u00b6 (IOWA public code) \u00b6 This is the documentation of the public version of IOWA LwM2M stack , illustrating how to use the LwM2M library. The Lite version can be found here: IOWA Github repository . This code is provided as-is , under the associated licence (./LICENSE.txt). (This code should not be used in a commercial product and is for personal evaluation ONLY) With this code, you can jump into LwM2M and validate the build and the execution of the IOWA stack on your device, but with some limitations: IOWA Eval SDK IOWA Full SDK Free for Non Commercial Usage Contact us Source Code & C-Make\u200b LwM2M 1.0\u200b LwM2M 1.1\u200b Mandatory LwM2M Objects\u200b Full IPSO Objects\u200b UDP Transport\u200b TCP Transport\u200b COAP Block\u200b LwM2M 1.1 data formats\u200b Bootstrap \u200b Firmware Update\u200b Multithread\u200b Two kinds of samples are available on the IOWA Github repository . The first set of samples can be used as a reference for evaluating this code. The second set (refered as Full_SDK_Samples ) is for information only, as it is NOT BUILDABLE without the Full SDK The *Full SDK\" and additional information is available from https://ioterop.com/iowa/ . Additional technical contents and how-to's may be found at https://ioterop.com/iot-dev-24-7/ . Please note: Neither the SDK nor the samples are open source software but commercial software. Whatever SDK (Eval or Full) you are using, start with the sample 01-baseline_client ... Enjoy !","title":"Home"},{"location":"#iowa-reference-documentation","text":"","title":"IOWA reference documentation"},{"location":"#iowa-public-code","text":"This is the documentation of the public version of IOWA LwM2M stack , illustrating how to use the LwM2M library. The Lite version can be found here: IOWA Github repository . This code is provided as-is , under the associated licence (./LICENSE.txt). (This code should not be used in a commercial product and is for personal evaluation ONLY) With this code, you can jump into LwM2M and validate the build and the execution of the IOWA stack on your device, but with some limitations: IOWA Eval SDK IOWA Full SDK Free for Non Commercial Usage Contact us Source Code & C-Make\u200b LwM2M 1.0\u200b LwM2M 1.1\u200b Mandatory LwM2M Objects\u200b Full IPSO Objects\u200b UDP Transport\u200b TCP Transport\u200b COAP Block\u200b LwM2M 1.1 data formats\u200b Bootstrap \u200b Firmware Update\u200b Multithread\u200b Two kinds of samples are available on the IOWA Github repository . The first set of samples can be used as a reference for evaluating this code. The second set (refered as Full_SDK_Samples ) is for information only, as it is NOT BUILDABLE without the Full SDK The *Full SDK\" and additional information is available from https://ioterop.com/iowa/ . Additional technical contents and how-to's may be found at https://ioterop.com/iot-dev-24-7/ . Please note: Neither the SDK nor the samples are open source software but commercial software. Whatever SDK (Eval or Full) you are using, start with the sample 01-baseline_client ... Enjoy !","title":"(IOWA public code)"},{"location":"AbstractionLayer/","text":"System Abstraction Layer \u00b6 The functions explained below are defined inside the file include/iowa_platform.h . Presentation \u00b6 To port IOWA to your platform, you have to implement the following functions. void * iowa_system_malloc ( size_t size ); void iowa_system_free ( void * pointer ); int32_t iowa_system_gettime ( void ); int iowa_system_connection_send ( void * connP , uint8_t * buffer , size_t length , void * userData ); int iowa_system_connection_recv ( void * connP , uint8_t * buffer , size_t length , void * userData ); int iowa_system_connection_select ( void ** connArray , size_t connCount , int32_t timeout , void * userData ); void iowa_system_connection_close ( void * connP , void * userData ); If you are implementing a LwM2M Client, you also have to implement these functions: void iowa_system_reboot ( void * userData ); void * iowa_system_connection_open ( iowa_connection_type_t type , char * hostname , char * port , void * userData ); These other functions are optional to implement. See Below. void iowa_system_trace ( const char * format , va_list varArgs ); void * iowa_system_queue_create ( void * userData ); void iowa_system_queue_delete ( void * queueP , void * userData ); int iowa_system_queue_enqueue ( void * queueP , uint8_t * buffer , size_t length , void * userData ); size_t iowa_system_queue_dequeue ( void * queueP , uint8_t * buffer , size_t length , void * userData ); size_t iowa_system_queue_peek ( void * queueP , uint8_t * buffer , size_t length , void * userData ); void iowa_system_queue_remove ( void * queueP , void * userData ); size_t iowa_system_queue_backup ( void * queueP , uint8_t * buffer , size_t length , void * userData ); void * iowa_system_queue_restore ( uint8_t * buffer , size_t length , void * userData ); size_t iowa_system_store_context ( uint8_t * bufferP , size_t length , void * userData ); size_t iowa_system_retrieve_context ( uint8_t ** bufferP , void * userData ); void iowa_system_connection_interrupt_select ( void * userData ); void iowa_system_mutex_lock ( void * userData ); void iowa_system_mutex_unlock ( void * userData ); size_t iowa_system_connection_get_peer_identifier ( void * connP , uint8_t * addrP , size_t length , void * userData ); int iowa_system_random_vector_generator ( uint8_t * randomBuffer , size_t size , void * userData ); iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ); \\clearpage Data types \u00b6 iowa_connection_type_t \u00b6 typedef enum { IOWA_CONN_UNDEFINED = 0 , IOWA_CONN_DATAGRAM , IOWA_CONN_STREAM , IOWA_CONN_LORAWAN , IOWA_CONN_SMS } iowa_connection_type_t ; This is an enumeration of the following values: IOWA_CONN_UNDEFINED : Connection type is unknown. IOWA_CONN_DATAGRAM : UDP connection. IOWA_CONN_STREAM : TCP connection. IOWA_CONN_LORAWAN : LoRaWAN transport. IOWA_CONN_SMS : SMS transport. iowa_security_operation_t \u00b6 typedef enum { IOWA_SEC_READ , IOWA_SEC_FREE , IOWA_SEC_CREATE , IOWA_SEC_DELETE , IOWA_SEC_CHECK } iowa_security_operation_t ; The iowa_security_operation_t enumeration is used to tell which security operation is requested when the function iowa_system_security_data is called. IOWA_SEC_READ : Read security keys from the Application. IOWA_SEC_FREE : Free the data allocated if any in the security structure. Always call after IOWA_SEC_READ . IOWA_SEC_CREATE : Add security keys to the Application. IOWA_SEC_DELETE : Remove security keys from the Application. IOWA_SEC_CHECK : Check if the security keys are present on the Application. iowa_psk_data_t \u00b6 typedef struct { uint8_t * identity ; size_t identityLen ; uint8_t * privateKey ; size_t privateKeyLen ; } iowa_psk_data_t ; The iowa_psk_data_t structure is used to store the identity / private key pair information. identity : Identity associated with the private key. identityLen : Length of the identity. privateKey : Private key associated with the identity. privateKeyLen : Length of the private key. iowa_certificate_data_t \u00b6 typedef struct { uint8_t * caCertificate ; size_t caCertificateLen ; uint8_t * certificate ; size_t certificateLen ; uint8_t * privateKey ; size_t privateKeyLen ; } iowa_certificate_data_t ; The iowa_certificate_data_t structure is used to store information related to a certificate. caCertificate : Certificate authority used to generate the certificate. Must respect the DER (Distinguished Encoding Rules) format. caCertificateLen : Length of the certificate authority. certificate : Certificate. Must respect the DER (Distinguished Encoding Rules) format. certificateLen : Length of the certificate. privateKey : Private key used to generate the certificate. Must respect the DER (Distinguished Encoding Rules) format. privateKeyLen : Length of the private key. iowa_rpk_data_t \u00b6 typedef struct { uint8_t * publicKeyX ; size_t publicKeyXLen ; uint8_t * publicKeyY ; size_t publicKeyYLen ; uint8_t * privateKey ; size_t privateKeyLen ; } iowa_rpk_data_t ; The iowa_rpk_data_t structure is used to store information related to raw public key information. Supported public keys must use the fixed curve secp256r1 . publicKeyX : Public key X coordinate. publicKeyXLen : Length of the public key X coordinate. publicKeyY : Public key Y coordinate. publicKeyYLen : Length of the public key Y coordinate. privateKey : Private key used to generate the public key. privateKeyLen : Length of the private key. iowa_oscore_data_t \u00b6 typedef struct { uint8_t * senderId ; size_t senderIdLen ; uint8_t * recipientId ; size_t recipientIdLen ; uint8_t * masterSecret ; size_t masterSecretLen ; } iowa_oscore_data_t ; The iowa_oscore_data_t structure is used to store information related to OSCORE key information. senderId : ID to use to protect sent CoAP messages. senderIdLen : Length of the Sender ID. recipientId : ID to use to verify received CoAP messages.. recipientIdLen : Length of the Recipient ID. masterSecret : Private key associated to the Sender ID and Recipient ID. masterSecretLen : Length of the Master Secret. iowa_security_data_t \u00b6 typedef struct { iowa_security_mode_t securityMode ; union { iowa_psk_data_t pskData ; iowa_certificate_data_t certData ; iowa_rpk_data_t rpkData ; iowa_oscore_data_t oscoreData ; } protocol ; } iowa_security_data_t ; The iowa_security_data_t structure is used to create, delete, read and free security data. securityMode : Security mode to determine the data in the union structure. protocol.pskData : Pre-shared key data. protocol.certData : Certificate data. protocol.rpkData : Raw public key data. protocol.oscoreData : Object Security for CORE key data. \\clearpage API \u00b6 iowa_system_malloc \u00b6 Prototype void * iowa_system_malloc ( size_t size ); Description iowa_system_malloc() could map directly to C standard library malloc() . It allocates a memory block. Arguments size : The size in bytes of the requested memory block. Return Value A pointer to the allocated memory or NULL in case of error. Header File iowa_platform.h Note This function is required by IOWA. \\clearpage iowa_system_free \u00b6 Prototype void iowa_system_free ( void * pointer ); Description iowa_system_free() could map directly to C standard library free() . It releases a memory block previously allocated by iowa_system_malloc() . Arguments pointer : A pointer to the memory block to release. Return Value None. Header File iowa_platform.h Notes This function is required by IOWA. From C standard, no action should occur if pointer argument is a null pointer. This is how the function free() from C standard library behaves. However some compilers or implementations do not respect this standard. So it can be necessary when implementing iowa_system_free() to check if the argument pointer is nil. \\clearpage iowa_system_gettime \u00b6 Prototype int32_t iowa_system_gettime ( void ); Description iowa_system_gettime() is used by IOWA to determine the time elapsed. Return Value The number of seconds elapsed since a point of origin or a negative number in case of error. Header File iowa_platform.h Notes This function is required by IOWA. If you are using the GPS or the Location object, this function will be used to timestamp the measure. In this case, the point of origin must be Epoch. Else, the point of origin (Epoch, system boot, etc...) does not matter as this function is used only to determine the elapsed time between consecutive calls. There is no safeguard if iowa_system_gettime() returns a value inferior to the one returned in a previous call. \\clearpage iowa_system_reboot \u00b6 Prototype void iowa_system_reboot ( void * userData ); Description iowa_system_reboot() starts a system reboot. Arguments userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only for LwM2M Clients. This feature is required by the Lightweight M2M protocol. However, a LwM2M device can be functional without it and this function can be a stub. \\clearpage iowa_system_trace \u00b6 Prototype void iowa_system_trace ( const char * format , va_list varArgs ); Description iowa_system_trace() outputs the logs when the stack is built with IOWA_WITH_LOGS . It can be mapped directly to vprintf() . Return Value None. Header File iowa_platform.h Notes This function is required by IOWA only when logs are activated. See [IOWA_LOG_LEVEL and IOWA_LOG_PART][IOWA_LOG_LEVEL and IOWA_LOG_PART]. IOWA takes care of freeing varArgs after this call returns. To print a single line on the output, this function can be called multiple times. This has an impact when the flag IOWA_THREAD_SUPPORT is enabled. Several calls of iowa_system_trace() can occur from different threads at the same time. And thus, the output can be ruined. The implementation of this function must be thread safe. \\clearpage iowa_system_connection_open \u00b6 Prototype void * iowa_system_connection_open ( iowa_connection_type_t type , char * hostname , char * port , void * userData ); Description iowa_system_connection_open() opens a connection to a host. Arguments type : The type of connection to open. hostname : The hostname of the peer to connect to. port : The port to connect to. It may be NULL depending on the provided server URL. userData : The argument passed to iowa_init() . Return Value A pointer to an user-defined type or NULL in case of error. Header File iowa_platform.h Notes This function is required only for LwM2M Clients. When IOWA is used as a LwM2M Client, it calls this function to connect to the LwM2M Servers. See the iowa_client_add_server() API. \\clearpage iowa_system_connection_send \u00b6 Prototype int iowa_system_connection_send ( void * connP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_connection_send() sends a buffer on a connection. Arguments connP : The connection as returned by iowa_system_connection_open() . buffer : The data to send. length : The length of the data in bytes. userData : The argument passed to iowa_init() . Return Value The number of bytes sent or a negative number in case of error. Header File iowa_platform.h Notes This function is required by IOWA. On packet switched networks (eg. UDP), if length is bigger than the MTU, it is advised to not try to send the buffer and return the MTU. \\clearpage iowa_system_connection_get_peer_identifier \u00b6 Prototype size_t iowa_system_connection_get_peer_identifier ( void * connP , uint8_t * addrP , size_t length , void * userData ); Description iowa_system_connection_get_peer_identifier() returns an unique identifier for the peer of a connection (e.g. IP address, LoRaWAN DevEUI, SMS MSISDN). Arguments connP : The connection as returned by iowa_system_connection_open() . addrP : A pre-allocated buffer to store the identifier. length : The length of addrP in bytes. userData : The argument passed to iowa_init() . Return Value The number of bytes of the identifier or 0 in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with [IOWA_SECURITY_LAYER][IOWA_SECURITY_LAYER] different from IOWA_SECURITY_LAYER_NONE , or with LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE flags. This is used when the endpoint name has not been found in the registration payload. \\clearpage iowa_system_connection_recv \u00b6 Prototype int iowa_system_connection_recv ( void * connP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_connection_recv() reads data from a connection in a non-blocking way. Arguments connP : The connection as returned by iowa_system_connection_open() . buffer : A buffer to store the received data. length : The length of the buffer in bytes. userData : The argument passed to iowa_init() . Return Value The number of received bytes or a negative number in case of error. Header File iowa_platform.h Note This function is required by IOWA. \\clearpage iowa_system_connection_select \u00b6 Prototype int iowa_system_connection_select ( void ** connArray , size_t connCount , int32_t timeout , void * userData ); Description iowa_system_connection_select() monitors a list of connections for incoming data during the specified time. Arguments connArray : An array of connections as returned by iowa_system_connection_open() . connCount : The number of elements of connArray. This may be zero. timeout : The time to wait for data in seconds. This may be zero. userData : The argument passed to iowa_init() . Return Value : either: : - a positive number if data are available. : - zero if the time elapsed. : - a negative number in case of error. Header File iowa_platform.h Notes This function is required by IOWA. If data are available on one or more connections, iowa_system_connection_select() must modify the connArray elements : If data are available on a connection the matching element in connArray is left untouched. If no data are available, the matching element is set to NULL. If the timeout is reached (or in case of error), there is no need to modify the connArray elements. When the application needs to be very responsive, this function is a good place to monitor application specific events without using a very short timeout in iowa_step() . For instance, the sample server waits for keyboard events here. It is possible that IOWA calls iowa_system_connection_select() with a timeout of zero. In this case, iowa_system_connection_select() must not return an error, and should check if some data are already available on one of the connections. It is also possible that IOWA calls iowa_system_connection_select() with no connections. In this case, iowa_system_connection_select() must not return an error, and should return after the timeout, which may also be zero, expires. This can occur when opening a connection to a LwM2M Server failed and IOWA is configured to wait a specific time before retrying to connect to the LwM2M Server. \\clearpage iowa_system_connection_interrupt_select \u00b6 Prototype void iowa_system_connection_interrupt_select ( void * userData ); Description A call to iowa_system_connection_interrupt_select() makes iowa_system_connection_select() return immediately if it is currently running. Arguments userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_MULTITHREAD_SUPPORT flag. The value returned by iowa_system_connection_select() is zero. Calling iowa_system_connection_interrupt_select() is considered as a preemptive timeout for iowa_system_connection_select() . \\clearpage iowa_system_connection_close \u00b6 Prototype void iowa_system_connection_close ( void * connP , void * userData ); Description iowa_system_connection_close() closes a connection. Arguments connP : The connection as returned by iowa_system_connection_open() . userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Note This function is required by IOWA. \\clearpage iowa_system_queue_create \u00b6 Prototype void * iowa_system_queue_create ( void * userData ); Description iowa_system_queue_create() creates a storage queue to offload data from the memory. Arguments userData : The argument passed to iowa_init() . Return Value A pointer to an user-defined type or NULL in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. The storage queue must store data as separate entities and not as as a stream. Ideally, this is a FIFO. \\clearpage iowa_system_queue_delete \u00b6 Prototype void iowa_system_queue_delete ( void * queueP , void * userData ); Description iowa_system_queue_delete() closes a storage queue. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. \\clearpage iowa_system_queue_enqueue \u00b6 Prototype int iowa_system_queue_enqueue ( void * queueP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_enqueue() stores data in a storage queue. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . buffer : The data to store. length : The length of the data in bytes. userData : The argument passed to iowa_init() . Return Value The number of stored bytes or a negative number in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. The data must be stored as a single entity. \\clearpage iowa_system_queue_dequeue \u00b6 Prototype size_t iowa_system_queue_dequeue ( void * queueP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_dequeue() retrieves an entity from a storage queue or, the provided buffer is too small, it returns the size of the next entity to retrieve. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . buffer : A buffer to store the retrieved data. This can be nil. length : The length of the buffer in bytes. This can be zero. userData : The argument passed to iowa_init() . Return Value The size in bytes of retrieved entity or zero if the queue is empty or in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_SUPPORT flag. If the provided buffer is nil or too small to contain the entity to retrieve, the entity is not removed from the queue. \\clearpage iowa_system_queue_peek \u00b6 Prototype size_t iowa_system_queue_peek ( void * queueP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_peek() peeks a entity from a storage queue or, if the provided buffer is too small, it returns the size of the next entity to peek. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . buffer : A buffer to store the retrieved data. This can be nil. length : The length of the buffer in bytes. This can be zero. userData : The argument passed to iowa_init() . Return Value The size in bytes of peeked entity or zero if the queue is empty or in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flag. \\clearpage iowa_system_queue_remove \u00b6 Prototype void iowa_system_queue_remove ( void * queueP , void * userData ); Description iowa_system_queue_remove() removes the first entity of a storage queue. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flag. \\clearpage iowa_system_queue_backup \u00b6 Prototype size_t iowa_system_queue_backup ( void * queueP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_backup() returns a blob of data necessary to recreate a storage queue, or if the provided buffer is too small, the size of this blob of data. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . buffer : A buffer to store the blob of data. This can be nil. length : The length of buffer in bytes. This can be zero. userData : The argument passed to iowa_init() . Return Value The size in bytes of the blob of data to save or zero in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_STORAGE_CONTEXT_SUPPORT flag and with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. \\clearpage iowa_system_queue_restore \u00b6 Prototype void * iowa_system_queue_restore ( uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_restore() recreates a storage queue from a blob of data. Arguments buffer : A buffer containing the blob of data returned by iowa_system_queue_backup() . length : The length of buffer in bytes. userData : The argument passed to iowa_init() . Return Value A pointer to an user-defined type or NULL in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_STORAGE_CONTEXT_SUPPORT flag and with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. \\clearpage iowa_system_store_context \u00b6 Prototype size_t iowa_system_store_context ( uint8_t * bufferP , size_t length , void * userData ); Description iowa_system_store_context() stores the IOWA context. Arguments bufferP : The destination buffer. length : Length of the buffer. userData : The argument passed to iowa_init() . Return Value The number of stored bytes or a zero in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_STORAGE_CONTEXT_SUPPORT flag. \\clearpage iowa_system_retrieve_context \u00b6 Prototype size_t iowa_system_retrieve_context ( uint8_t ** bufferP , void * userData ); Description iowa_system_retrieve_context() retrieves an IOWA context. Arguments bufferP : The buffer containing the retrieved data. userData : The argument passed to iowa_init() . Return Value The size in bytes of retrieved data or zero if there is nothing or in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_STORAGE_CONTEXT_SUPPORT flag. bufferP must be allocated by the function. The buffer will next be freed by IOWA internally. \\clearpage iowa_system_mutex_lock \u00b6 Prototype void iowa_system_mutex_lock ( void * userData ); Description iowa_system_mutex_lock() locks a mutex for the current thread. Arguments userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_MULTITHREAD_SUPPORT flag. IOWA uses only one mutex. \\clearpage iowa_system_mutex_unlock \u00b6 Prototype void iowa_system_mutex_unlock ( void * userData ); Description iowa_system_mutex_unlock() releases a mutex. Arguments userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_MULTITHREAD_SUPPORT flag. IOWA uses only one mutex. \\clearpage iowa_system_random_vector_generator \u00b6 Prototype int iowa_system_random_vector_generator ( uint8_t * randomBuffer , size_t size , void * userData ); Description iowa_system_random_vector_generator() stores random values to a preallocated vector. Arguments randomBuffer : The generated random vector. size : The size of the vector. userData : The argument passed to iowa_init() . Return Value A code indicating if the vector has been generated: 0 if the vector has been generated successfully. Another value if an error occurred. Header File iowa_platform.h Notes This function is only required if IOWA is built with IOWA_SECURITY_LAYER different from IOWA_SECURITY_LAYER_NONE . \\clearpage iowa_system_security_data \u00b6 Prototype iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ); Description iowa_system_security_data() is a function used by the security layer to CREATE, DELETE or READ the security data. Arguments peerIdentity : The identity associating to the peer (can be an URI on client side, or the PSK identity on server side, etc). peerIdentitySize : Size of the identity. securityOp : The security operation. securityDataP : The security data. userDataP : The argument passed to iowa_init() . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : the security data based on peerIdentity has not been found (only when the security operation is not IOWA_SEC_CREATE ). IOWA_COAP_406_NOT_ACCEPTABLE : the security data based on peerIdentity already exists (only when the security operation is IOWA_SEC_CREATE ). IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_platform.h Notes This function is only required if IOWA is built with IOWA_SECURITY_LAYER different from IOWA_SECURITY_LAYER_NONE . The IOWA_SEC_DELETE operation is only used if a IOWA_SEC_CREATE operation happened. The IOWA_SEC_CREATE operation is only used on bootstrapping. Regarding the memory allocation: On a IOWA_SEC_CREATE operation, the data is allocated by the stack. So the deallocation MUST not be done by the application. On a IOWA_SEC_READ operation, the data if needed is allocated by the application. The stack does not deallocate it. That's why after a IOWA_SEC_READ operation, the function iowa_system_security_data is called with IOWA_SEC_FREE to allow the application to deallocate the memory if needed. peerIdentity is always a character string encoded in UTF-8 without the Null-terminated string: On a LwM2M Client, this is the LwM2M Server URI or the Bootstrap Server URI. On Server, this is Client Hint Identity.","title":"Abstraction Layer"},{"location":"AbstractionLayer/#system-abstraction-layer","text":"The functions explained below are defined inside the file include/iowa_platform.h .","title":"System Abstraction Layer"},{"location":"AbstractionLayer/#presentation","text":"To port IOWA to your platform, you have to implement the following functions. void * iowa_system_malloc ( size_t size ); void iowa_system_free ( void * pointer ); int32_t iowa_system_gettime ( void ); int iowa_system_connection_send ( void * connP , uint8_t * buffer , size_t length , void * userData ); int iowa_system_connection_recv ( void * connP , uint8_t * buffer , size_t length , void * userData ); int iowa_system_connection_select ( void ** connArray , size_t connCount , int32_t timeout , void * userData ); void iowa_system_connection_close ( void * connP , void * userData ); If you are implementing a LwM2M Client, you also have to implement these functions: void iowa_system_reboot ( void * userData ); void * iowa_system_connection_open ( iowa_connection_type_t type , char * hostname , char * port , void * userData ); These other functions are optional to implement. See Below. void iowa_system_trace ( const char * format , va_list varArgs ); void * iowa_system_queue_create ( void * userData ); void iowa_system_queue_delete ( void * queueP , void * userData ); int iowa_system_queue_enqueue ( void * queueP , uint8_t * buffer , size_t length , void * userData ); size_t iowa_system_queue_dequeue ( void * queueP , uint8_t * buffer , size_t length , void * userData ); size_t iowa_system_queue_peek ( void * queueP , uint8_t * buffer , size_t length , void * userData ); void iowa_system_queue_remove ( void * queueP , void * userData ); size_t iowa_system_queue_backup ( void * queueP , uint8_t * buffer , size_t length , void * userData ); void * iowa_system_queue_restore ( uint8_t * buffer , size_t length , void * userData ); size_t iowa_system_store_context ( uint8_t * bufferP , size_t length , void * userData ); size_t iowa_system_retrieve_context ( uint8_t ** bufferP , void * userData ); void iowa_system_connection_interrupt_select ( void * userData ); void iowa_system_mutex_lock ( void * userData ); void iowa_system_mutex_unlock ( void * userData ); size_t iowa_system_connection_get_peer_identifier ( void * connP , uint8_t * addrP , size_t length , void * userData ); int iowa_system_random_vector_generator ( uint8_t * randomBuffer , size_t size , void * userData ); iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ); \\clearpage","title":"Presentation"},{"location":"AbstractionLayer/#data-types","text":"","title":"Data types"},{"location":"AbstractionLayer/#iowa_connection_type_t","text":"typedef enum { IOWA_CONN_UNDEFINED = 0 , IOWA_CONN_DATAGRAM , IOWA_CONN_STREAM , IOWA_CONN_LORAWAN , IOWA_CONN_SMS } iowa_connection_type_t ; This is an enumeration of the following values: IOWA_CONN_UNDEFINED : Connection type is unknown. IOWA_CONN_DATAGRAM : UDP connection. IOWA_CONN_STREAM : TCP connection. IOWA_CONN_LORAWAN : LoRaWAN transport. IOWA_CONN_SMS : SMS transport.","title":"iowa_connection_type_t"},{"location":"AbstractionLayer/#iowa_security_operation_t","text":"typedef enum { IOWA_SEC_READ , IOWA_SEC_FREE , IOWA_SEC_CREATE , IOWA_SEC_DELETE , IOWA_SEC_CHECK } iowa_security_operation_t ; The iowa_security_operation_t enumeration is used to tell which security operation is requested when the function iowa_system_security_data is called. IOWA_SEC_READ : Read security keys from the Application. IOWA_SEC_FREE : Free the data allocated if any in the security structure. Always call after IOWA_SEC_READ . IOWA_SEC_CREATE : Add security keys to the Application. IOWA_SEC_DELETE : Remove security keys from the Application. IOWA_SEC_CHECK : Check if the security keys are present on the Application.","title":"iowa_security_operation_t"},{"location":"AbstractionLayer/#iowa_psk_data_t","text":"typedef struct { uint8_t * identity ; size_t identityLen ; uint8_t * privateKey ; size_t privateKeyLen ; } iowa_psk_data_t ; The iowa_psk_data_t structure is used to store the identity / private key pair information. identity : Identity associated with the private key. identityLen : Length of the identity. privateKey : Private key associated with the identity. privateKeyLen : Length of the private key.","title":"iowa_psk_data_t"},{"location":"AbstractionLayer/#iowa_certificate_data_t","text":"typedef struct { uint8_t * caCertificate ; size_t caCertificateLen ; uint8_t * certificate ; size_t certificateLen ; uint8_t * privateKey ; size_t privateKeyLen ; } iowa_certificate_data_t ; The iowa_certificate_data_t structure is used to store information related to a certificate. caCertificate : Certificate authority used to generate the certificate. Must respect the DER (Distinguished Encoding Rules) format. caCertificateLen : Length of the certificate authority. certificate : Certificate. Must respect the DER (Distinguished Encoding Rules) format. certificateLen : Length of the certificate. privateKey : Private key used to generate the certificate. Must respect the DER (Distinguished Encoding Rules) format. privateKeyLen : Length of the private key.","title":"iowa_certificate_data_t"},{"location":"AbstractionLayer/#iowa_rpk_data_t","text":"typedef struct { uint8_t * publicKeyX ; size_t publicKeyXLen ; uint8_t * publicKeyY ; size_t publicKeyYLen ; uint8_t * privateKey ; size_t privateKeyLen ; } iowa_rpk_data_t ; The iowa_rpk_data_t structure is used to store information related to raw public key information. Supported public keys must use the fixed curve secp256r1 . publicKeyX : Public key X coordinate. publicKeyXLen : Length of the public key X coordinate. publicKeyY : Public key Y coordinate. publicKeyYLen : Length of the public key Y coordinate. privateKey : Private key used to generate the public key. privateKeyLen : Length of the private key.","title":"iowa_rpk_data_t"},{"location":"AbstractionLayer/#iowa_oscore_data_t","text":"typedef struct { uint8_t * senderId ; size_t senderIdLen ; uint8_t * recipientId ; size_t recipientIdLen ; uint8_t * masterSecret ; size_t masterSecretLen ; } iowa_oscore_data_t ; The iowa_oscore_data_t structure is used to store information related to OSCORE key information. senderId : ID to use to protect sent CoAP messages. senderIdLen : Length of the Sender ID. recipientId : ID to use to verify received CoAP messages.. recipientIdLen : Length of the Recipient ID. masterSecret : Private key associated to the Sender ID and Recipient ID. masterSecretLen : Length of the Master Secret.","title":"iowa_oscore_data_t"},{"location":"AbstractionLayer/#iowa_security_data_t","text":"typedef struct { iowa_security_mode_t securityMode ; union { iowa_psk_data_t pskData ; iowa_certificate_data_t certData ; iowa_rpk_data_t rpkData ; iowa_oscore_data_t oscoreData ; } protocol ; } iowa_security_data_t ; The iowa_security_data_t structure is used to create, delete, read and free security data. securityMode : Security mode to determine the data in the union structure. protocol.pskData : Pre-shared key data. protocol.certData : Certificate data. protocol.rpkData : Raw public key data. protocol.oscoreData : Object Security for CORE key data. \\clearpage","title":"iowa_security_data_t"},{"location":"AbstractionLayer/#api","text":"","title":"API"},{"location":"AbstractionLayer/#iowa_system_malloc","text":"Prototype void * iowa_system_malloc ( size_t size ); Description iowa_system_malloc() could map directly to C standard library malloc() . It allocates a memory block. Arguments size : The size in bytes of the requested memory block. Return Value A pointer to the allocated memory or NULL in case of error. Header File iowa_platform.h Note This function is required by IOWA. \\clearpage","title":"iowa_system_malloc"},{"location":"AbstractionLayer/#iowa_system_free","text":"Prototype void iowa_system_free ( void * pointer ); Description iowa_system_free() could map directly to C standard library free() . It releases a memory block previously allocated by iowa_system_malloc() . Arguments pointer : A pointer to the memory block to release. Return Value None. Header File iowa_platform.h Notes This function is required by IOWA. From C standard, no action should occur if pointer argument is a null pointer. This is how the function free() from C standard library behaves. However some compilers or implementations do not respect this standard. So it can be necessary when implementing iowa_system_free() to check if the argument pointer is nil. \\clearpage","title":"iowa_system_free"},{"location":"AbstractionLayer/#iowa_system_gettime","text":"Prototype int32_t iowa_system_gettime ( void ); Description iowa_system_gettime() is used by IOWA to determine the time elapsed. Return Value The number of seconds elapsed since a point of origin or a negative number in case of error. Header File iowa_platform.h Notes This function is required by IOWA. If you are using the GPS or the Location object, this function will be used to timestamp the measure. In this case, the point of origin must be Epoch. Else, the point of origin (Epoch, system boot, etc...) does not matter as this function is used only to determine the elapsed time between consecutive calls. There is no safeguard if iowa_system_gettime() returns a value inferior to the one returned in a previous call. \\clearpage","title":"iowa_system_gettime"},{"location":"AbstractionLayer/#iowa_system_reboot","text":"Prototype void iowa_system_reboot ( void * userData ); Description iowa_system_reboot() starts a system reboot. Arguments userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only for LwM2M Clients. This feature is required by the Lightweight M2M protocol. However, a LwM2M device can be functional without it and this function can be a stub. \\clearpage","title":"iowa_system_reboot"},{"location":"AbstractionLayer/#iowa_system_trace","text":"Prototype void iowa_system_trace ( const char * format , va_list varArgs ); Description iowa_system_trace() outputs the logs when the stack is built with IOWA_WITH_LOGS . It can be mapped directly to vprintf() . Return Value None. Header File iowa_platform.h Notes This function is required by IOWA only when logs are activated. See [IOWA_LOG_LEVEL and IOWA_LOG_PART][IOWA_LOG_LEVEL and IOWA_LOG_PART]. IOWA takes care of freeing varArgs after this call returns. To print a single line on the output, this function can be called multiple times. This has an impact when the flag IOWA_THREAD_SUPPORT is enabled. Several calls of iowa_system_trace() can occur from different threads at the same time. And thus, the output can be ruined. The implementation of this function must be thread safe. \\clearpage","title":"iowa_system_trace"},{"location":"AbstractionLayer/#iowa_system_connection_open","text":"Prototype void * iowa_system_connection_open ( iowa_connection_type_t type , char * hostname , char * port , void * userData ); Description iowa_system_connection_open() opens a connection to a host. Arguments type : The type of connection to open. hostname : The hostname of the peer to connect to. port : The port to connect to. It may be NULL depending on the provided server URL. userData : The argument passed to iowa_init() . Return Value A pointer to an user-defined type or NULL in case of error. Header File iowa_platform.h Notes This function is required only for LwM2M Clients. When IOWA is used as a LwM2M Client, it calls this function to connect to the LwM2M Servers. See the iowa_client_add_server() API. \\clearpage","title":"iowa_system_connection_open"},{"location":"AbstractionLayer/#iowa_system_connection_send","text":"Prototype int iowa_system_connection_send ( void * connP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_connection_send() sends a buffer on a connection. Arguments connP : The connection as returned by iowa_system_connection_open() . buffer : The data to send. length : The length of the data in bytes. userData : The argument passed to iowa_init() . Return Value The number of bytes sent or a negative number in case of error. Header File iowa_platform.h Notes This function is required by IOWA. On packet switched networks (eg. UDP), if length is bigger than the MTU, it is advised to not try to send the buffer and return the MTU. \\clearpage","title":"iowa_system_connection_send"},{"location":"AbstractionLayer/#iowa_system_connection_get_peer_identifier","text":"Prototype size_t iowa_system_connection_get_peer_identifier ( void * connP , uint8_t * addrP , size_t length , void * userData ); Description iowa_system_connection_get_peer_identifier() returns an unique identifier for the peer of a connection (e.g. IP address, LoRaWAN DevEUI, SMS MSISDN). Arguments connP : The connection as returned by iowa_system_connection_open() . addrP : A pre-allocated buffer to store the identifier. length : The length of addrP in bytes. userData : The argument passed to iowa_init() . Return Value The number of bytes of the identifier or 0 in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with [IOWA_SECURITY_LAYER][IOWA_SECURITY_LAYER] different from IOWA_SECURITY_LAYER_NONE , or with LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE flags. This is used when the endpoint name has not been found in the registration payload. \\clearpage","title":"iowa_system_connection_get_peer_identifier"},{"location":"AbstractionLayer/#iowa_system_connection_recv","text":"Prototype int iowa_system_connection_recv ( void * connP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_connection_recv() reads data from a connection in a non-blocking way. Arguments connP : The connection as returned by iowa_system_connection_open() . buffer : A buffer to store the received data. length : The length of the buffer in bytes. userData : The argument passed to iowa_init() . Return Value The number of received bytes or a negative number in case of error. Header File iowa_platform.h Note This function is required by IOWA. \\clearpage","title":"iowa_system_connection_recv"},{"location":"AbstractionLayer/#iowa_system_connection_select","text":"Prototype int iowa_system_connection_select ( void ** connArray , size_t connCount , int32_t timeout , void * userData ); Description iowa_system_connection_select() monitors a list of connections for incoming data during the specified time. Arguments connArray : An array of connections as returned by iowa_system_connection_open() . connCount : The number of elements of connArray. This may be zero. timeout : The time to wait for data in seconds. This may be zero. userData : The argument passed to iowa_init() . Return Value : either: : - a positive number if data are available. : - zero if the time elapsed. : - a negative number in case of error. Header File iowa_platform.h Notes This function is required by IOWA. If data are available on one or more connections, iowa_system_connection_select() must modify the connArray elements : If data are available on a connection the matching element in connArray is left untouched. If no data are available, the matching element is set to NULL. If the timeout is reached (or in case of error), there is no need to modify the connArray elements. When the application needs to be very responsive, this function is a good place to monitor application specific events without using a very short timeout in iowa_step() . For instance, the sample server waits for keyboard events here. It is possible that IOWA calls iowa_system_connection_select() with a timeout of zero. In this case, iowa_system_connection_select() must not return an error, and should check if some data are already available on one of the connections. It is also possible that IOWA calls iowa_system_connection_select() with no connections. In this case, iowa_system_connection_select() must not return an error, and should return after the timeout, which may also be zero, expires. This can occur when opening a connection to a LwM2M Server failed and IOWA is configured to wait a specific time before retrying to connect to the LwM2M Server. \\clearpage","title":"iowa_system_connection_select"},{"location":"AbstractionLayer/#iowa_system_connection_interrupt_select","text":"Prototype void iowa_system_connection_interrupt_select ( void * userData ); Description A call to iowa_system_connection_interrupt_select() makes iowa_system_connection_select() return immediately if it is currently running. Arguments userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_MULTITHREAD_SUPPORT flag. The value returned by iowa_system_connection_select() is zero. Calling iowa_system_connection_interrupt_select() is considered as a preemptive timeout for iowa_system_connection_select() . \\clearpage","title":"iowa_system_connection_interrupt_select"},{"location":"AbstractionLayer/#iowa_system_connection_close","text":"Prototype void iowa_system_connection_close ( void * connP , void * userData ); Description iowa_system_connection_close() closes a connection. Arguments connP : The connection as returned by iowa_system_connection_open() . userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Note This function is required by IOWA. \\clearpage","title":"iowa_system_connection_close"},{"location":"AbstractionLayer/#iowa_system_queue_create","text":"Prototype void * iowa_system_queue_create ( void * userData ); Description iowa_system_queue_create() creates a storage queue to offload data from the memory. Arguments userData : The argument passed to iowa_init() . Return Value A pointer to an user-defined type or NULL in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. The storage queue must store data as separate entities and not as as a stream. Ideally, this is a FIFO. \\clearpage","title":"iowa_system_queue_create"},{"location":"AbstractionLayer/#iowa_system_queue_delete","text":"Prototype void iowa_system_queue_delete ( void * queueP , void * userData ); Description iowa_system_queue_delete() closes a storage queue. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. \\clearpage","title":"iowa_system_queue_delete"},{"location":"AbstractionLayer/#iowa_system_queue_enqueue","text":"Prototype int iowa_system_queue_enqueue ( void * queueP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_enqueue() stores data in a storage queue. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . buffer : The data to store. length : The length of the data in bytes. userData : The argument passed to iowa_init() . Return Value The number of stored bytes or a negative number in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. The data must be stored as a single entity. \\clearpage","title":"iowa_system_queue_enqueue"},{"location":"AbstractionLayer/#iowa_system_queue_dequeue","text":"Prototype size_t iowa_system_queue_dequeue ( void * queueP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_dequeue() retrieves an entity from a storage queue or, the provided buffer is too small, it returns the size of the next entity to retrieve. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . buffer : A buffer to store the retrieved data. This can be nil. length : The length of the buffer in bytes. This can be zero. userData : The argument passed to iowa_init() . Return Value The size in bytes of retrieved entity or zero if the queue is empty or in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_SUPPORT flag. If the provided buffer is nil or too small to contain the entity to retrieve, the entity is not removed from the queue. \\clearpage","title":"iowa_system_queue_dequeue"},{"location":"AbstractionLayer/#iowa_system_queue_peek","text":"Prototype size_t iowa_system_queue_peek ( void * queueP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_peek() peeks a entity from a storage queue or, if the provided buffer is too small, it returns the size of the next entity to peek. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . buffer : A buffer to store the retrieved data. This can be nil. length : The length of the buffer in bytes. This can be zero. userData : The argument passed to iowa_init() . Return Value The size in bytes of peeked entity or zero if the queue is empty or in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flag. \\clearpage","title":"iowa_system_queue_peek"},{"location":"AbstractionLayer/#iowa_system_queue_remove","text":"Prototype void iowa_system_queue_remove ( void * queueP , void * userData ); Description iowa_system_queue_remove() removes the first entity of a storage queue. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flag. \\clearpage","title":"iowa_system_queue_remove"},{"location":"AbstractionLayer/#iowa_system_queue_backup","text":"Prototype size_t iowa_system_queue_backup ( void * queueP , uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_backup() returns a blob of data necessary to recreate a storage queue, or if the provided buffer is too small, the size of this blob of data. Arguments queueP : A storage queue as returned by iowa_system_queue_create() . buffer : A buffer to store the blob of data. This can be nil. length : The length of buffer in bytes. This can be zero. userData : The argument passed to iowa_init() . Return Value The size in bytes of the blob of data to save or zero in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_STORAGE_CONTEXT_SUPPORT flag and with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. \\clearpage","title":"iowa_system_queue_backup"},{"location":"AbstractionLayer/#iowa_system_queue_restore","text":"Prototype void * iowa_system_queue_restore ( uint8_t * buffer , size_t length , void * userData ); Description iowa_system_queue_restore() recreates a storage queue from a blob of data. Arguments buffer : A buffer containing the blob of data returned by iowa_system_queue_backup() . length : The length of buffer in bytes. userData : The argument passed to iowa_init() . Return Value A pointer to an user-defined type or NULL in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_STORAGE_CONTEXT_SUPPORT flag and with the LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags. \\clearpage","title":"iowa_system_queue_restore"},{"location":"AbstractionLayer/#iowa_system_store_context","text":"Prototype size_t iowa_system_store_context ( uint8_t * bufferP , size_t length , void * userData ); Description iowa_system_store_context() stores the IOWA context. Arguments bufferP : The destination buffer. length : Length of the buffer. userData : The argument passed to iowa_init() . Return Value The number of stored bytes or a zero in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_STORAGE_CONTEXT_SUPPORT flag. \\clearpage","title":"iowa_system_store_context"},{"location":"AbstractionLayer/#iowa_system_retrieve_context","text":"Prototype size_t iowa_system_retrieve_context ( uint8_t ** bufferP , void * userData ); Description iowa_system_retrieve_context() retrieves an IOWA context. Arguments bufferP : The buffer containing the retrieved data. userData : The argument passed to iowa_init() . Return Value The size in bytes of retrieved data or zero if there is nothing or in case of error. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_STORAGE_CONTEXT_SUPPORT flag. bufferP must be allocated by the function. The buffer will next be freed by IOWA internally. \\clearpage","title":"iowa_system_retrieve_context"},{"location":"AbstractionLayer/#iowa_system_mutex_lock","text":"Prototype void iowa_system_mutex_lock ( void * userData ); Description iowa_system_mutex_lock() locks a mutex for the current thread. Arguments userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_MULTITHREAD_SUPPORT flag. IOWA uses only one mutex. \\clearpage","title":"iowa_system_mutex_lock"},{"location":"AbstractionLayer/#iowa_system_mutex_unlock","text":"Prototype void iowa_system_mutex_unlock ( void * userData ); Description iowa_system_mutex_unlock() releases a mutex. Arguments userData : The argument passed to iowa_init() . Return Value None. Header File iowa_platform.h Notes This function is required only if IOWA is built with the IOWA_MULTITHREAD_SUPPORT flag. IOWA uses only one mutex. \\clearpage","title":"iowa_system_mutex_unlock"},{"location":"AbstractionLayer/#iowa_system_random_vector_generator","text":"Prototype int iowa_system_random_vector_generator ( uint8_t * randomBuffer , size_t size , void * userData ); Description iowa_system_random_vector_generator() stores random values to a preallocated vector. Arguments randomBuffer : The generated random vector. size : The size of the vector. userData : The argument passed to iowa_init() . Return Value A code indicating if the vector has been generated: 0 if the vector has been generated successfully. Another value if an error occurred. Header File iowa_platform.h Notes This function is only required if IOWA is built with IOWA_SECURITY_LAYER different from IOWA_SECURITY_LAYER_NONE . \\clearpage","title":"iowa_system_random_vector_generator"},{"location":"AbstractionLayer/#iowa_system_security_data","text":"Prototype iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ); Description iowa_system_security_data() is a function used by the security layer to CREATE, DELETE or READ the security data. Arguments peerIdentity : The identity associating to the peer (can be an URI on client side, or the PSK identity on server side, etc). peerIdentitySize : Size of the identity. securityOp : The security operation. securityDataP : The security data. userDataP : The argument passed to iowa_init() . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : the security data based on peerIdentity has not been found (only when the security operation is not IOWA_SEC_CREATE ). IOWA_COAP_406_NOT_ACCEPTABLE : the security data based on peerIdentity already exists (only when the security operation is IOWA_SEC_CREATE ). IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_platform.h Notes This function is only required if IOWA is built with IOWA_SECURITY_LAYER different from IOWA_SECURITY_LAYER_NONE . The IOWA_SEC_DELETE operation is only used if a IOWA_SEC_CREATE operation happened. The IOWA_SEC_CREATE operation is only used on bootstrapping. Regarding the memory allocation: On a IOWA_SEC_CREATE operation, the data is allocated by the stack. So the deallocation MUST not be done by the application. On a IOWA_SEC_READ operation, the data if needed is allocated by the application. The stack does not deallocate it. That's why after a IOWA_SEC_READ operation, the function iowa_system_security_data is called with IOWA_SEC_FREE to allow the application to deallocate the memory if needed. peerIdentity is always a character string encoded in UTF-8 without the Null-terminated string: On a LwM2M Client, this is the LwM2M Server URI or the Bootstrap Server URI. On Server, this is Client Hint Identity.","title":"iowa_system_security_data"},{"location":"ApplicationStorage/","text":"Application storage \u00b6 Depending on features enabled during the IOWA build, IOWA can rely on the Application storage to store data. Two main features rely on the Application storage: The Context storage, The Notification storage. Context storage \u00b6 Context saving/restoring can be enabled with the flag IOWA_STORAGE_CONTEXT_SUPPORT . When this flag is set two additional platform functions must be defined: iowa_system_store_context() and iowa_system_retrieve_context() . Note: Currently this feature is only available for the LwM2M Client. Client pseudo code \u00b6 #include \"iowa_client.h\" #include \"iowa_ipso.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; iowa_device_info_t devInfo ; iowa_sensor_t sensorId ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); devInfo . manufacturer = \"IOTEROP\" ; devInfo . deviceType = \"Context Storage example device\" ; devInfo . modelNumber = \"1\" ; devInfo . serialNumber = NULL ; devInfo . hardwareVersion = NULL ; devInfo . softwareVersion = NULL ; devInfo . optFlags = 0 ; result = iowa_client_configure ( iowaH , \"IOWA_Sample_Client\" , devInfo , NULL ); result = iowa_client_IPSO_add_sensor ( iowaH , IOWA_IPSO_VOLTAGE , 12.0 , \"V\" , \"Test DC\" , 0.0 , 0.0 , & sensorId ); result = iowa_load_context ( iowaH ); if ( result != IOWA_COAP_NO_ERROR ) { result = iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); } /****************** * \"Main loop\" */ while ( ! quit && result == IOWA_COAP_NO_ERROR ) { float sensorValue ; result = iowa_step ( iowaH , 5 ); sensorValue = read_battery_voltage (); result = iowa_client_IPSO_update_value ( iowaH , sensorId , sensorValue ); } if ( result == IOWA_COAP_NO_ERROR ) { result = iowa_save_context_snapshot ( iowaH ); } iowa_client_IPSO_remove_sensor ( iowaH , sensorId ); iowa_close ( iowaH ); return 0 ; } Saving the context \u00b6 Context saving can be controlled through the APIs iowa_save_context() and iowa_save_context_snapshot() . Each call to theses APIs will call the platform function iowa_system_store_context() . The data passed to the platform is a serialized non-encrypted version of the IOWA Context. The buffer / buffer length pair can, depending of the Application use case, be serialized without modification or be encrypted before the serialization. The data is encoded using the CoAP option scheme which is a Type Length Value format with size optimizations. Each stored piece of information is prepended by a header between 1 and 4 bytes in size. On the Client side, the size of the buffer to save will depend on the presence of a LwM2M Bootstrap Server Account and the number of LwM2M Server Accounts configured at the time the Context is saved. Using iowa_save_context_snapshot() saves additional information for each server, including registration information, observations and attributes. Bootstrap Server and Server Accounts \u00b6 Both account types are composed of: Data Type Bytes used Server Short ID uint16_t 2 Security Object Instance ID uint16_t 2 Server Object Instance ID uint16_t 2 Registration lifetime int32_t 4 Binding mode uint8_t 1 Default Minimum Period uint32_t 4 Default Maximum Period uint32_t 4 Notification Storing bool 1 Bootstrap-Server bool 1 Disable Timeout int32_t 4 Security Mode uint8_t 1 Server URI string Variable (max length: 65535) Server MSISDN string Variable (max length: 15) Summing up the fields except the last two ones, the maximum static size is 26 bytes. The remaining variables do not have a static length and depend on the Server URI or Server MSISDN. The maximum length for a Server MSISDN is 15 bytes. For a Server URI, an approximation can be made by taking the following approach: The Server URI can be usually decomposed into three parts: [COAP_SCHEMA]://[HOSTNAME]:[PORT] . With this decomposition in mind, the following Server URI handles 90% of the cases: coaps://255.255.255.255:65535 which leads to an conservative size of 29 bytes. The encoding adds an average overhead of 22 bytes per Server Account. So, the LwM2M Bootstrap Server Account and LwM2M Server Accounts are mostly stored inside 77 bytes. Now let's take the following example: A LwM2M Client is launched, no LwM2M server is configured but a LwM2M Bootstrap Server is added by calling iowa_client_add_bootstrap_server . The Server URI is: coaps://217.182.95.250:5784 . If the Context is saved at this stage, the serialized buffer will have a length of 77 bytes. After the Bootstrap procedure, a LwM2M Server Account has been added to the LwM2M Client with the Server URI: coaps://18.195.192.63:5684 . If the Context is now saved, the serialized buffer will have a length of 77 bytes (LwM2M Bootstrap Server Account) + 80 bytes (LwM2M Server) = 157 bytes. Access Control \u00b6 If [ IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT ][IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT] is set. Data Type Bytes used ACL Instance ID uint16_t 2 Object ID uint16_t 2 Instance ID uint16_t 2 Owner ID uint16_t 2 ACL Flags Buffer Variable ACL Flags may be present several times. The ACL Flags buffer is made of the following data: Data Type Bytes used Server ID uint16_t 2 Flags uint8_t 1 Runtime Information \u00b6 When using iowa_save_context_snapshot() , runtime information, including observations and attributes, will also be stored when the context is saved. For LwM2M Server Account, runtime information are composed of: Data Type Bytes used Runtime Status uint8_t 1 Location string Variable Retry Count uint8_t 1 Sequence Retry Count uint8_t 1 Attributes Buffer Variable Observations Buffer Variable Storage Queue Buffer Variable Both observations and attributes key may be present several times in order to serialize each observation and attributes of the desired LwM2M Server Account. If LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags are set, IOWA will call iowa_system_queue_backup() and save the returned buffer. When loading the context, IOWA calls iowa_system_queue_restore() with the saved buffer. The application must be able to restore the queue and the stored notifications using this buffer. Attributes \u00b6 For each URI with attributes, only set attributes will be saved. The size of this buffer depends on the LwM2M Client state. Data Type Bytes used URI uint8_t[] max size: 8 Minimum Period uint32_t 4 Maximum Period uint32_t 4 Greater Than double 8 Less Than double 8 Step double 8 Minimum Evaluation Period uint32_t 4 Maximum Evaluation Period uint32_t 4 Observations \u00b6 Each observation will have a static size of 14 bytes. The remaining variables do not have a static length and depends on the URI and the number of token. Observation can also have several URI key. This leads to a maximum overhead of 8 bytes plus 9 bytes for each URI. Data Type Bytes used URI uint8_t[] max size: 8 URI flags uint8_t 1 Content Format uint16_t 2 Token uint8_t[] max size: 8 Last Notification Time uint32_t 4 Notification Counter uint32_t 4 Restoring the context \u00b6 On the other side, Context restoring can be controlled through the API iowa_load_context() . Each call to this API will call the platform function iowa_system_retrieve_context() . The data retrieved from the platform must be the serialized non-encrypted version of the IOWA Context. The buffer passed by argument has to be allocated by the Application. But the iowa_system_retrieve_context() function doesn't need to free the memory. This will be done by IOWA once the Context has been loaded into memory. Automatic Context saving \u00b6 Automatic Context saving can be done when the flag IOWA_STORAGE_CONTEXT_AUTOMATIC_BACKUP is set. This feature only saves the Bootstrap Server and Server accounts just as iowa_save_context() . On the Client, the Context is then saved when the following events occur: Calling the functions iowa_client_add_bootstrap_server , iowa_client_remove_bootstrap_server , iowa_client_add_server and iowa_client_remove_server , After a successful Bootstrap sequence, A LwM2M Server writes a new value on the resources Lifetime (ID:1), Default Minimum Period (ID:2), Default Maximum Period (ID:3), Disable Timeout (ID:5), or Notification Storing When Disabled or Offline (ID:6) of the [ Server Object ][Server Object] (ID:1). Notification storage \u00b6 Note: This feature is only available for the LwM2M Client. This is used by the Client when the Server is not available and the notifications need to be stored until the connection with the Server is reestablished. Notification storing is enabled when the resource Notification Storing When Disabled or Offline is set to true in the Server object. This can be done either by using the API iowa_client_use_reliable_notifications() or when a LwM2M Server writes in the resource 1/x/6 . When notification storing is enabled, notifications are stored in Queue if one the flags LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT is set. When LWM2M_STORAGE_QUEUE_SUPPORT flag is set four additional system abstraction functions must be defined: iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_dequeue() , and iowa_system_queue_delete() . When LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flag is set five additional system abstraction functions must be defined: iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_peek() , iowa_system_queue_remove() , and iowa_system_queue_delete() . When the LWM2M_STORAGE_QUEUE_SUPPORT or the LWM2M_STORAGE_QUEUE_PEEK_SUPPORT are defined, the system abstraction function iowa_system_queue_create() is called to create a queue to save notifications. This queue must be a FIFO (First In, First Out). Likewise, when the Observation is cancelled by the Server, if a queue was created, the system abstraction function iowa_system_queue_delete() is called to remove it. As said earlier, the notifications are stored when the Server is no more reachable. A Server is considered no more available when: On a Registration message, no acknowledgement has been received, On a Registration Update message, no acknowledgement has been received, On a Confirmable Notification message, no acknowledgement has been received, After the Server triggers the resource Disable (ID: 4) of the [ Server Object ][Server Object] (ID:1). Saving a notification \u00b6 The data passed to the platform are a serialized non-encrypted version of a Notification encoded with TLV Content Format. The pair buffer / buffer length can, depend on the Application use case, be serialized without modification or be encrypted before the serialization. The size of the buffer to save will depend on the URI observed, the buffer is composed of: Data Type Bytes used Counter uint32_t 4 Token length uint8_t 1 Token uint8_t[] 1-8 Serialized data uint8_t[] Variable Summing up the bytes used except the last one, the static size obtained is: 13 bytes. The remaining variable does not have a static length and highly depends on the URI observed. If the URI observed is an Object Instance, the Serialized data will have a longer buffer than if the URI was observed a Resource. But again it depends on the Resources data types. To estimate the serialized data, the TLV specification should be used. The complete specification of this Content Format can be found in the part 6.4.3 of the document OMA-TS-LightweightM2M-V1_0_2-20180209-A . With that in mind, let's take the following example: An Observation is placed by the Server on the URI /3303/0. The Object Instance has the Resources: Sensor Value (ID:5700), Min Measured Value (ID:5601), Max Measured Value (ID:5602), Min Range Value (ID:5603), Max Range Value (ID:5604), Sensor Units (ID:5701). On a Registration Update, no response is received from the Server and thus becomes no more reachable. The Client updates periodically the value of the Resource Sensor Value (ID:5700). The first notification is saved into the Application Storage by calling: iowa_system_queue_create() to create the Queue, iowa_system_queue_enqueue() to save the serialized Notification. Each subsequent call will only call iowa_system_queue_enqueue() . An example of the serialized Data can be: Payload : 41 bytes E4 16 44 41 BC 71 C4 E4 15 E1 41 BB 29 2 C E4 15 |.. DA . q .... A . ), ..| E2 41 C6 96 1 C E3 16 45 43 65 6 C E4 15 E3 C1 A0 |. A ..... ECel .....| 00 00 E4 15 E4 42 48 00 00 |..... BH ..| Type byte (hex) ID byte(s) (hex) Length byte(s) Value Total bytes E4 16 44 (ID:5700) No length 0x41BC71C4 7 E4 15 E1 (ID:5601) No length 0x41BB292C 7 E4 15 E2 (ID:5602) No length 0x41C6961C 7 E3 16 45 (ID:5701) No length 0x43656C 6 E4 15 E3 (ID:5603) No length 0xC1A00000 7 E4 15 E4 (ID:5604) No length 0x42480000 7 The total length of the serialized Notification passed to the application will be: 4 bytes (Counter) + 1 byte (Token length) + 8 bytes maximum (Token) + 41 bytes (Serialized data) = 54 bytes. If the Observation was on the URI /3303/0/5700: The serialized Data would have been: Payload : 7 bytes E4 16 44 41 BC 71 C4 |.. DA . q .| Type byte (hex) ID byte(s) (hex) Length byte(s) Value Total bytes E4 16 44 (ID:5700) No length 0x41BC71C4 7 As said earlier, for proper estimation of the Serialized data, the TLV specification should be used to estimate the serialization length depending on which URI the Observation will be placed. Loading a stored notification \u00b6 On the other side, IOWA reads frequently the stored Notifications. System abstraction functions are called only if the queue has been created on the Application side. When LWM2M_STORAGE_QUEUE_SUPPORT is defined, reading the stored notifications is done by calling the system abstraction function iowa_system_queue_dequeue() . Then the system abstraction function iowa_system_queue_enqueue() may be called depending if the following conditions are met: The Observation has no parameter, and the Server is not reachable. The value will be put back into the Queue. The Observation has parameters such as Minimum Period, Maximal Period, etc, and the Server is not reachable. If the conditions are not met, the value is put back into the Queue. When LWM2M_STORAGE_QUEUE_PEEK_SUPPORT is used, reading the stored notification is done by calling the system abstraction function iowa_system_queue_peek() . Then the system abstraction function iowa_system_queue_remove() is called if the notification was successfully received by the Server. Once the Server becomes reachable, the Queue is emptied and all the saved Notifications are sent to the Server. Note: When the Server becomes reachable, the Queue is not deleted once it's emptied. It will only be deleted when the Observation is cancelled.","title":"Application storage"},{"location":"ApplicationStorage/#application-storage","text":"Depending on features enabled during the IOWA build, IOWA can rely on the Application storage to store data. Two main features rely on the Application storage: The Context storage, The Notification storage.","title":"Application storage"},{"location":"ApplicationStorage/#context-storage","text":"Context saving/restoring can be enabled with the flag IOWA_STORAGE_CONTEXT_SUPPORT . When this flag is set two additional platform functions must be defined: iowa_system_store_context() and iowa_system_retrieve_context() . Note: Currently this feature is only available for the LwM2M Client.","title":"Context storage"},{"location":"ApplicationStorage/#client-pseudo-code","text":"#include \"iowa_client.h\" #include \"iowa_ipso.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; iowa_device_info_t devInfo ; iowa_sensor_t sensorId ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); devInfo . manufacturer = \"IOTEROP\" ; devInfo . deviceType = \"Context Storage example device\" ; devInfo . modelNumber = \"1\" ; devInfo . serialNumber = NULL ; devInfo . hardwareVersion = NULL ; devInfo . softwareVersion = NULL ; devInfo . optFlags = 0 ; result = iowa_client_configure ( iowaH , \"IOWA_Sample_Client\" , devInfo , NULL ); result = iowa_client_IPSO_add_sensor ( iowaH , IOWA_IPSO_VOLTAGE , 12.0 , \"V\" , \"Test DC\" , 0.0 , 0.0 , & sensorId ); result = iowa_load_context ( iowaH ); if ( result != IOWA_COAP_NO_ERROR ) { result = iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); } /****************** * \"Main loop\" */ while ( ! quit && result == IOWA_COAP_NO_ERROR ) { float sensorValue ; result = iowa_step ( iowaH , 5 ); sensorValue = read_battery_voltage (); result = iowa_client_IPSO_update_value ( iowaH , sensorId , sensorValue ); } if ( result == IOWA_COAP_NO_ERROR ) { result = iowa_save_context_snapshot ( iowaH ); } iowa_client_IPSO_remove_sensor ( iowaH , sensorId ); iowa_close ( iowaH ); return 0 ; }","title":"Client pseudo code"},{"location":"ApplicationStorage/#saving-the-context","text":"Context saving can be controlled through the APIs iowa_save_context() and iowa_save_context_snapshot() . Each call to theses APIs will call the platform function iowa_system_store_context() . The data passed to the platform is a serialized non-encrypted version of the IOWA Context. The buffer / buffer length pair can, depending of the Application use case, be serialized without modification or be encrypted before the serialization. The data is encoded using the CoAP option scheme which is a Type Length Value format with size optimizations. Each stored piece of information is prepended by a header between 1 and 4 bytes in size. On the Client side, the size of the buffer to save will depend on the presence of a LwM2M Bootstrap Server Account and the number of LwM2M Server Accounts configured at the time the Context is saved. Using iowa_save_context_snapshot() saves additional information for each server, including registration information, observations and attributes.","title":"Saving the context"},{"location":"ApplicationStorage/#bootstrap-server-and-server-accounts","text":"Both account types are composed of: Data Type Bytes used Server Short ID uint16_t 2 Security Object Instance ID uint16_t 2 Server Object Instance ID uint16_t 2 Registration lifetime int32_t 4 Binding mode uint8_t 1 Default Minimum Period uint32_t 4 Default Maximum Period uint32_t 4 Notification Storing bool 1 Bootstrap-Server bool 1 Disable Timeout int32_t 4 Security Mode uint8_t 1 Server URI string Variable (max length: 65535) Server MSISDN string Variable (max length: 15) Summing up the fields except the last two ones, the maximum static size is 26 bytes. The remaining variables do not have a static length and depend on the Server URI or Server MSISDN. The maximum length for a Server MSISDN is 15 bytes. For a Server URI, an approximation can be made by taking the following approach: The Server URI can be usually decomposed into three parts: [COAP_SCHEMA]://[HOSTNAME]:[PORT] . With this decomposition in mind, the following Server URI handles 90% of the cases: coaps://255.255.255.255:65535 which leads to an conservative size of 29 bytes. The encoding adds an average overhead of 22 bytes per Server Account. So, the LwM2M Bootstrap Server Account and LwM2M Server Accounts are mostly stored inside 77 bytes. Now let's take the following example: A LwM2M Client is launched, no LwM2M server is configured but a LwM2M Bootstrap Server is added by calling iowa_client_add_bootstrap_server . The Server URI is: coaps://217.182.95.250:5784 . If the Context is saved at this stage, the serialized buffer will have a length of 77 bytes. After the Bootstrap procedure, a LwM2M Server Account has been added to the LwM2M Client with the Server URI: coaps://18.195.192.63:5684 . If the Context is now saved, the serialized buffer will have a length of 77 bytes (LwM2M Bootstrap Server Account) + 80 bytes (LwM2M Server) = 157 bytes.","title":"Bootstrap Server and Server Accounts"},{"location":"ApplicationStorage/#access-control","text":"If [ IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT ][IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT] is set. Data Type Bytes used ACL Instance ID uint16_t 2 Object ID uint16_t 2 Instance ID uint16_t 2 Owner ID uint16_t 2 ACL Flags Buffer Variable ACL Flags may be present several times. The ACL Flags buffer is made of the following data: Data Type Bytes used Server ID uint16_t 2 Flags uint8_t 1","title":"Access Control"},{"location":"ApplicationStorage/#runtime-information","text":"When using iowa_save_context_snapshot() , runtime information, including observations and attributes, will also be stored when the context is saved. For LwM2M Server Account, runtime information are composed of: Data Type Bytes used Runtime Status uint8_t 1 Location string Variable Retry Count uint8_t 1 Sequence Retry Count uint8_t 1 Attributes Buffer Variable Observations Buffer Variable Storage Queue Buffer Variable Both observations and attributes key may be present several times in order to serialize each observation and attributes of the desired LwM2M Server Account. If LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flags are set, IOWA will call iowa_system_queue_backup() and save the returned buffer. When loading the context, IOWA calls iowa_system_queue_restore() with the saved buffer. The application must be able to restore the queue and the stored notifications using this buffer.","title":"Runtime Information"},{"location":"ApplicationStorage/#attributes","text":"For each URI with attributes, only set attributes will be saved. The size of this buffer depends on the LwM2M Client state. Data Type Bytes used URI uint8_t[] max size: 8 Minimum Period uint32_t 4 Maximum Period uint32_t 4 Greater Than double 8 Less Than double 8 Step double 8 Minimum Evaluation Period uint32_t 4 Maximum Evaluation Period uint32_t 4","title":"Attributes"},{"location":"ApplicationStorage/#observations","text":"Each observation will have a static size of 14 bytes. The remaining variables do not have a static length and depends on the URI and the number of token. Observation can also have several URI key. This leads to a maximum overhead of 8 bytes plus 9 bytes for each URI. Data Type Bytes used URI uint8_t[] max size: 8 URI flags uint8_t 1 Content Format uint16_t 2 Token uint8_t[] max size: 8 Last Notification Time uint32_t 4 Notification Counter uint32_t 4","title":"Observations"},{"location":"ApplicationStorage/#restoring-the-context","text":"On the other side, Context restoring can be controlled through the API iowa_load_context() . Each call to this API will call the platform function iowa_system_retrieve_context() . The data retrieved from the platform must be the serialized non-encrypted version of the IOWA Context. The buffer passed by argument has to be allocated by the Application. But the iowa_system_retrieve_context() function doesn't need to free the memory. This will be done by IOWA once the Context has been loaded into memory.","title":"Restoring the context"},{"location":"ApplicationStorage/#automatic-context-saving","text":"Automatic Context saving can be done when the flag IOWA_STORAGE_CONTEXT_AUTOMATIC_BACKUP is set. This feature only saves the Bootstrap Server and Server accounts just as iowa_save_context() . On the Client, the Context is then saved when the following events occur: Calling the functions iowa_client_add_bootstrap_server , iowa_client_remove_bootstrap_server , iowa_client_add_server and iowa_client_remove_server , After a successful Bootstrap sequence, A LwM2M Server writes a new value on the resources Lifetime (ID:1), Default Minimum Period (ID:2), Default Maximum Period (ID:3), Disable Timeout (ID:5), or Notification Storing When Disabled or Offline (ID:6) of the [ Server Object ][Server Object] (ID:1).","title":"Automatic Context saving"},{"location":"ApplicationStorage/#notification-storage","text":"Note: This feature is only available for the LwM2M Client. This is used by the Client when the Server is not available and the notifications need to be stored until the connection with the Server is reestablished. Notification storing is enabled when the resource Notification Storing When Disabled or Offline is set to true in the Server object. This can be done either by using the API iowa_client_use_reliable_notifications() or when a LwM2M Server writes in the resource 1/x/6 . When notification storing is enabled, notifications are stored in Queue if one the flags LWM2M_STORAGE_QUEUE_SUPPORT or LWM2M_STORAGE_QUEUE_PEEK_SUPPORT is set. When LWM2M_STORAGE_QUEUE_SUPPORT flag is set four additional system abstraction functions must be defined: iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_dequeue() , and iowa_system_queue_delete() . When LWM2M_STORAGE_QUEUE_PEEK_SUPPORT flag is set five additional system abstraction functions must be defined: iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_peek() , iowa_system_queue_remove() , and iowa_system_queue_delete() . When the LWM2M_STORAGE_QUEUE_SUPPORT or the LWM2M_STORAGE_QUEUE_PEEK_SUPPORT are defined, the system abstraction function iowa_system_queue_create() is called to create a queue to save notifications. This queue must be a FIFO (First In, First Out). Likewise, when the Observation is cancelled by the Server, if a queue was created, the system abstraction function iowa_system_queue_delete() is called to remove it. As said earlier, the notifications are stored when the Server is no more reachable. A Server is considered no more available when: On a Registration message, no acknowledgement has been received, On a Registration Update message, no acknowledgement has been received, On a Confirmable Notification message, no acknowledgement has been received, After the Server triggers the resource Disable (ID: 4) of the [ Server Object ][Server Object] (ID:1).","title":"Notification storage"},{"location":"ApplicationStorage/#saving-a-notification","text":"The data passed to the platform are a serialized non-encrypted version of a Notification encoded with TLV Content Format. The pair buffer / buffer length can, depend on the Application use case, be serialized without modification or be encrypted before the serialization. The size of the buffer to save will depend on the URI observed, the buffer is composed of: Data Type Bytes used Counter uint32_t 4 Token length uint8_t 1 Token uint8_t[] 1-8 Serialized data uint8_t[] Variable Summing up the bytes used except the last one, the static size obtained is: 13 bytes. The remaining variable does not have a static length and highly depends on the URI observed. If the URI observed is an Object Instance, the Serialized data will have a longer buffer than if the URI was observed a Resource. But again it depends on the Resources data types. To estimate the serialized data, the TLV specification should be used. The complete specification of this Content Format can be found in the part 6.4.3 of the document OMA-TS-LightweightM2M-V1_0_2-20180209-A . With that in mind, let's take the following example: An Observation is placed by the Server on the URI /3303/0. The Object Instance has the Resources: Sensor Value (ID:5700), Min Measured Value (ID:5601), Max Measured Value (ID:5602), Min Range Value (ID:5603), Max Range Value (ID:5604), Sensor Units (ID:5701). On a Registration Update, no response is received from the Server and thus becomes no more reachable. The Client updates periodically the value of the Resource Sensor Value (ID:5700). The first notification is saved into the Application Storage by calling: iowa_system_queue_create() to create the Queue, iowa_system_queue_enqueue() to save the serialized Notification. Each subsequent call will only call iowa_system_queue_enqueue() . An example of the serialized Data can be: Payload : 41 bytes E4 16 44 41 BC 71 C4 E4 15 E1 41 BB 29 2 C E4 15 |.. DA . q .... A . ), ..| E2 41 C6 96 1 C E3 16 45 43 65 6 C E4 15 E3 C1 A0 |. A ..... ECel .....| 00 00 E4 15 E4 42 48 00 00 |..... BH ..| Type byte (hex) ID byte(s) (hex) Length byte(s) Value Total bytes E4 16 44 (ID:5700) No length 0x41BC71C4 7 E4 15 E1 (ID:5601) No length 0x41BB292C 7 E4 15 E2 (ID:5602) No length 0x41C6961C 7 E3 16 45 (ID:5701) No length 0x43656C 6 E4 15 E3 (ID:5603) No length 0xC1A00000 7 E4 15 E4 (ID:5604) No length 0x42480000 7 The total length of the serialized Notification passed to the application will be: 4 bytes (Counter) + 1 byte (Token length) + 8 bytes maximum (Token) + 41 bytes (Serialized data) = 54 bytes. If the Observation was on the URI /3303/0/5700: The serialized Data would have been: Payload : 7 bytes E4 16 44 41 BC 71 C4 |.. DA . q .| Type byte (hex) ID byte(s) (hex) Length byte(s) Value Total bytes E4 16 44 (ID:5700) No length 0x41BC71C4 7 As said earlier, for proper estimation of the Serialized data, the TLV specification should be used to estimate the serialization length depending on which URI the Observation will be placed.","title":"Saving a notification"},{"location":"ApplicationStorage/#loading-a-stored-notification","text":"On the other side, IOWA reads frequently the stored Notifications. System abstraction functions are called only if the queue has been created on the Application side. When LWM2M_STORAGE_QUEUE_SUPPORT is defined, reading the stored notifications is done by calling the system abstraction function iowa_system_queue_dequeue() . Then the system abstraction function iowa_system_queue_enqueue() may be called depending if the following conditions are met: The Observation has no parameter, and the Server is not reachable. The value will be put back into the Queue. The Observation has parameters such as Minimum Period, Maximal Period, etc, and the Server is not reachable. If the conditions are not met, the value is put back into the Queue. When LWM2M_STORAGE_QUEUE_PEEK_SUPPORT is used, reading the stored notification is done by calling the system abstraction function iowa_system_queue_peek() . Then the system abstraction function iowa_system_queue_remove() is called if the notification was successfully received by the Server. Once the Server becomes reachable, the Queue is emptied and all the saved Notifications are sent to the Server. Note: When the Server becomes reachable, the Queue is not deleted once it's emptied. It will only be deleted when the Observation is cancelled.","title":"Loading a stored notification"},{"location":"Bootstrap/","text":"Bootstrap \u00b6 To enable the Bootstrap Interface on the client, IOWA must be built with the flag LWM2M_BOOTSTRAP . Furthermore to create a LwM2M Bootstrap Server, the flag LWM2M_BOOTSTRAP_SERVER_MODE must be set. Note: This flag can be set with LWM2M_SERVER_MODE , there is no conflict. Overview \u00b6 The Bootstrap mode is used to add one or more LwM2M Server Account into the LwM2M Client. IOWA currently supports the following Bootstrap mode: Factory Bootstrap Client initiated Bootstrap Bootstrap Mode \u00b6 Factory Bootstrap \u00b6 The LwM2M Client has, in this mode, already the LwM2M Server Account(s) configured. This mode does not require the LwM2M Client to connect to a LwM2M Bootstrap Server if the LwM2M Server accounts contain at least a LwM2M Server Information. Client initiated Bootstrap \u00b6 If no Server have been configured and a Bootstrap Server is supplied, the Client will connect to the Bootstrap Server to obtain the connection information of at least one Server. If the Client needs to connect to the Bootstrap Server with security, the keys need to be preloaded during Factory setup. Flow \u00b6 Bootstrap Request \u00b6 After Client booting, the Client sends a Bootstrap Request operation to the preloaded Bootstrap Server. On Bootstrap Request, the Bootstrap Server starts provisioning the Client with new LwM2M Server Accounts. Getting Bootstrap Information \u00b6 A typical client configuration flow is: Delete everything on the Client by sending a Delete operation on URI / , Optional step: Write a new LwM2M Bootstrap Server Account with Write operation on URI /0 , Write at least one LwM2M Server Account with Write operation on URI /0 and /1 . Writing a LwM2M Bootstrap Server Account is recommended. If the Client is unable to connect to the Server, it can fall back to Bootstrap mode. Instead of writing manually the Object Instance through Write operation, IOWA provides for the LwM2M Bootstrap Server high level operations: Add Bootstrap Server: add a [ Security Object ][Security Object] Instance, Remove Bootstrap Server: add the [ Security Object ][Security Object] Instance associated to the Bootstrap Server, Add Server: add a [ Security Object ][Security Object] Instance and a [ Server Object ][Server Object] Instance, Remove Server: remove the [ Security Object ][Security Object] Instance and the [ Server Object ][Server Object] Instance associated to the Server. These high level operations automatically provision the Resources of the Objects without the need to know how the Objects are structured. Bootstrap Finish \u00b6 Once the LwM2M Server Account have been provisioned, the Bootstrap Server sends a Bootstrap Finish operation to start the Bootstrap Consistency check. The Bootstrap Consistency checks if the information provided is correct before exiting the Bootstrap mode. If the information is incorrect, an error is sent back to the Bootstrap Server by the Client to inform that the LwM2M Server Account loaded is not consistent. Bootstrap Consistency can fail for the following reasons: No Server Account provided, Only one Bootstrap Server Account provided without Server Account, Server URI requires a secured connection but no Security information is provided, Server URI requires a non secured connection but Security information is provided, Server URI requires a specific binding but the Resource Binding (ID: 7) of the [ Server Object ][Server Object] is different, Security information is not consistent across the Resources Security Mode (ID: 2), Public Key or Identity (ID: 3), Server Public Key (ID: 4) and Secret Key (ID: 5) of the [ Security Object ][Security Object]. If the Bootstrap Consistency passed, the Client will respond with no error to the Bootstrap Finish operation. Server Registration \u00b6 Once the Bootstrap Consistency is done without error, the Client disconnects from the Bootstrap Server and starts a Registration to the loaded Server(s). If the Client does not get a response from the Server and if a Bootstrap Server is configured, the Client will fall back to Bootstrap mode. Notes \u00b6 IOWA Client (without Security) \u00b6 The Factory mode is supported through the API: iowa_client_add_bootstrap_server() and iowa_client_add_server() . Below is an example indicating how to to provision the Bootstrap Server and start the Client initiated Bootstrap. Be careful, if a Server is also configured, the Client will not go to Bootstrap mode and instead go to Registration mode on the configured Server. #include \"iowa_client.h\" static void prv_eventCallback ( iowa_event_t * eventP , void * userData , iowa_context_t contextP ) { switch ( eventP -> eventType ) { case IOWA_EVENT_REG_UNREGISTERED : printf ( \"Server (short ID: %d): Unregistered \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_REG_REGISTERING : printf ( \"Server (short ID: %d): Registering \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_REG_REGISTERED : printf ( \"Server (short ID: %d): Registered with lifetime %ds \\r\\n \" , eventP -> serverShortId , eventP -> details . registration . lifetime ); break ; case IOWA_EVENT_REG_UPDATING : printf ( \"Server (short ID: %d): Registration updating \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_REG_FAILED : printf ( \"Server (short ID: %d): Registration failed. \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_BS_PENDING : printf ( \"Server (short ID: %d): Bootstrapping \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_BS_FAILED : printf ( \"Server (short ID: %d): Bootstrap failed \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_BS_FINISHED : printf ( \"Server (short ID: %d): Bootstrap finished \\r\\n \" , eventP -> serverShortId ); break ; default : // Do nothing break ; } } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); iowa_client_configure ( iowaH , \"IOWA_Client\" , NULL , prv_eventCallback ); iowa_client_add_bootstrap_server ( iowaH , \"coap://localhost:5783\" , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_bootstrap_server ( iowaH ); iowa_close ( iowaH ); return 0 ; } Once the Client starts: On first step loop, the iowa_event_callback_t callback is called to inform Bootstrap mode is beginning with event IOWA_EVENT_BS_PENDING , When the Bootstrap Finish is received and if the Bootstrap Consistency is passed, the event callback is called with event IOWA_EVENT_BS_FINISHED , After that the event callback gets called with event IOWA_EVENT_REG_REGISTERING to report that the Client is registering to the Server. If the Client is not able to register to the Server, the event callback is called with IOWA_EVENT_REG_FAILED and depending if a Bootstrap Server is configured, the Client: Automatically falls back to Bootstrap mode if a Bootstrap Server is configured, Exits the step loop with IOWA_COAP_503_SERVICE_UNAVAILABLE if no Bootstrap Server is configured. The Bootstrap can fail (event IOWA_EVENT_BS_FAILED ) when no command is received from the Bootstrap Server during a certain amount of time. IOWA Client (with Security) \u00b6 The previous example can be extended to support the Security. This example serves just to demonstrate how to use IOWA security API. For instance, a better way could be to use a Secure element to store the security keys. For this purpose, two structures are added to store the keys by Server Account: security_t.serverUri . The implementation uses the concept of Linked List with the help of IOWA API: [ IOWA_UTILS_LIST_ADD() ][IOWA_UTILS_LIST_ADD] and [ IOWA_UTILS_LIST_REMOVE() ][IOWA_UTILS_LIST_REMOVE]. typedef struct security_data_t_ { struct security_data_t_ * next ; iowa_security_data_t securityData ; char * serverUri ; } security_t ; typedef struct { security_t * security ; } client_data_t ; The main is updated to pass the data security data structure: #include \"iowa_client.h\" #define SERVER_URI \"coaps: //localhost:5784\" #define PSK_CLIENT_IDENTITY \"IOWA_CLIENT\" #define PSK_CLIENT_KEY_LENGTH 10 #define PSK_CLIENT_KEY {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39} int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; client_data_t clientData ; iowa_security_data_t securityData ; unsigned char psk [ PSK_CLIENT_KEY_LENGTH ] = PSK_CLIENT_KEY ; /****************** * Initialization */ memset ( & clientData , 0 , sizeof ( client_data_t )); // Add the Bootstrap Security key to the linked list memset ( & securityData , 0 , sizeof ( iowa_security_data_t )); securityData . securityMode = IOWA_SEC_PRE_SHARED_KEY ; securityData . protocol . pskData . identityLen = strlen ( PSK_CLIENT_IDENTITY ); securityData . protocol . pskData . identity = iowa_system_malloc ( securityData . protocol . pskData . identityLen ); memcpy ( securityData . protocol . pskData . identity , PSK_CLIENT_IDENTITY , securityData . protocol . pskData . identityLen ); securityData . protocol . pskData . privateKeyLen = PSK_CLIENT_KEY_LENGTH ; securityData . protocol . pskData . privateKey = iowa_system_malloc ( PSK_CLIENT_KEY_LENGTH ); memcpy ( securityData . protocol . pskData . privateKey , psk , PSK_CLIENT_KEY_LENGTH ); iowa_system_security_data (( uint8_t * ) SERVER_URI , strlen ( SERVER_URI ), IOWA_SEC_CREATE , & securityData , & clientData ); // Initialize IOWA iowaH = iowa_init ( & clientData ); iowa_client_configure ( iowaH , \"IOWA_Client\" , NULL , NULL ); iowa_client_add_bootstrap_server ( iowaH , SERVER_URI , IOWA_SEC_PRE_SHARED_KEY ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_bootstrap_server ( iowaH ); iowa_close ( iowaH ); // Remove the Bootstrap Security key iowa_system_security_data (( uint8_t * ) SERVER_URI , strlen ( SERVER_URI ), IOWA_SEC_DELETE , NULL , & clientData ); return 0 ; } And iowa_system_security_data() is expanded with the handle of IOWA_SEC_CREATE and IOWA_SEC_DELETE to support adding and removing keys by the Bootstrap Server. iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ) { client_data_t * clientDataP ; clientDataP = ( client_data_t * ) userDataP ; switch ( securityOp ) { case IOWA_SEC_READ : { security_t * securityP ; securityP = clientDataP -> security ; while ( securityP != NULL && memcmp ( securityP -> serverUri , peerIdentity , peerIdentityLen ) != 0 ) { securityP = securityP -> next ; } if ( securityP == NULL ) { return IOWA_COAP_404_NOT_FOUND ; } securityDataP -> securityMode = securityP -> securityData . securityMode ; switch ( securityDataP -> securityMode ) { case IOWA_SEC_PRE_SHARED_KEY : // Copy the identity securityDataP -> protocol . pskData . identity = securityP -> securityData . protocol . pskData . identity ; securityDataP -> protocol . pskData . identityLen = securityP -> securityData . protocol . pskData . identityLen ; // Copy the private key securityDataP -> protocol . pskData . privateKey = securityP -> securityData . protocol . pskData . privateKey ; securityDataP -> protocol . pskData . privateKeyLen = securityP -> securityData . protocol . pskData . privateKeyLen ; break ; case IOWA_SEC_CERTIFICATE : // Copy the CA certificate securityDataP -> protocol . certData . caCertificate = securityP -> securityData . protocol . certData . caCertificate ; securityDataP -> protocol . certData . caCertificateLen = securityP -> securityData . protocol . certData . caCertificateLen ; // Copy the certificate securityDataP -> protocol . certData . certificate = securityP -> securityData . protocol . certData . certificate ; securityDataP -> protocol . certData . certificateLen = securityP -> securityData . protocol . certData . certificateLen ; // Copy the private key securityDataP -> protocol . certData . privateKey = securityP -> securityData . protocol . certData . privateKey ; securityDataP -> protocol . certData . privateKeyLen = securityP -> securityData . protocol . certData . privateKeyLen ; break ; case IOWA_SEC_RAW_PUBLIC_KEY : // Copy the X public key securityDataP -> protocol . rpkData . publicKeyX = securityP -> securityData . protocol . rpkData . publicKeyX ; securityDataP -> protocol . rpkData . publicKeyXLen = securityP -> securityData . protocol . rpkData . publicKeyXLen ; // Copy the Y public key securityDataP -> protocol . rpkData . publicKeyY = securityP -> securityData . protocol . rpkData . publicKeyY ; securityDataP -> protocol . rpkData . publicKeyYLen = securityP -> securityData . protocol . rpkData . publicKeyYLen ; // Copy the private key securityDataP -> protocol . rpkData . privateKey = securityP -> securityData . protocol . rpkData . privateKey ; securityDataP -> protocol . rpkData . privateKeyLen = securityP -> securityData . protocol . rpkData . privateKeyLen ; break ; default : break ; } break ; } case IOWA_SEC_CREATE : { security_t * newSecurityP ; newSecurityP = iowa_system_malloc ( sizeof ( security_t )); if ( newSecurityP == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } newSecurityP -> next = NULL ; newSecurityP -> securityData . securityMode = securityDataP -> securityMode ; switch ( newSecurityP -> securityData . securityMode ) { case IOWA_SEC_PRE_SHARED_KEY : // Copy the identity newSecurityP -> securityData . protocol . pskData . identity = iowa_system_malloc ( securityDataP -> protocol . pskData . identityLen ); if ( newSecurityP -> securityData . protocol . pskData . identity == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . pskData . identity , securityDataP -> protocol . pskData . identity , securityDataP -> protocol . pskData . identityLen ); newSecurityP -> securityData . protocol . pskData . identityLen = securityDataP -> protocol . pskData . identityLen ; // Copy the private key newSecurityP -> securityData . protocol . pskData . privateKey = iowa_system_malloc ( securityDataP -> protocol . pskData . privateKeyLen ); if ( newSecurityP -> securityData . protocol . pskData . privateKey == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . pskData . identity ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . pskData . privateKey , securityDataP -> protocol . pskData . privateKey , securityDataP -> protocol . pskData . privateKeyLen ); newSecurityP -> securityData . protocol . pskData . privateKeyLen = securityDataP -> protocol . pskData . privateKeyLen ; break ; case IOWA_SEC_CERTIFICATE : // Copy the CA certificate newSecurityP -> securityData . protocol . certData . caCertificate = iowa_system_malloc ( securityDataP -> protocol . certData . caCertificateLen ); if ( newSecurityP -> securityData . protocol . certData . caCertificate == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . certData . caCertificate , securityDataP -> protocol . certData . caCertificate , securityDataP -> protocol . certData . caCertificateLen ); newSecurityP -> securityData . protocol . certData . caCertificateLen = securityDataP -> protocol . certData . caCertificateLen ; // Copy the certificate newSecurityP -> securityData . protocol . certData . certificate = iowa_system_malloc ( securityDataP -> protocol . certData . certificateLen ); if ( newSecurityP -> securityData . protocol . certData . certificate == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . certData . caCertificate ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . certData . certificate , securityDataP -> protocol . certData . certificate , securityDataP -> protocol . certData . certificateLen ); newSecurityP -> securityData . protocol . certData . certificateLen = securityDataP -> protocol . certData . certificateLen ; // Copy the private key newSecurityP -> securityData . protocol . certData . privateKey = iowa_system_malloc ( securityDataP -> protocol . certData . privateKeyLen ); if ( newSecurityP -> securityData . protocol . certData . privateKey == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . certData . caCertificate ); iowa_system_free ( newSecurityP -> securityData . protocol . certData . certificate ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . certData . privateKey , securityDataP -> protocol . certData . privateKey , securityDataP -> protocol . certData . privateKeyLen ); newSecurityP -> securityData . protocol . certData . privateKeyLen = securityDataP -> protocol . certData . privateKeyLen ; break ; case IOWA_SEC_RAW_PUBLIC_KEY : // Copy the X public key newSecurityP -> securityData . protocol . rpkData . publicKeyX = iowa_system_malloc ( securityDataP -> protocol . rpkData . publicKeyXLen ); if ( newSecurityP -> securityData . protocol . rpkData . publicKeyX == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . rpkData . publicKeyX , securityDataP -> protocol . rpkData . publicKeyX , securityDataP -> protocol . rpkData . publicKeyXLen ); newSecurityP -> securityData . protocol . rpkData . publicKeyXLen = securityDataP -> protocol . rpkData . publicKeyXLen ; // Copy the Y public key newSecurityP -> securityData . protocol . rpkData . publicKeyY = iowa_system_malloc ( securityDataP -> protocol . rpkData . publicKeyYLen ); if ( newSecurityP -> securityData . protocol . rpkData . publicKeyY == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . rpkData . publicKeyX ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . rpkData . publicKeyY , securityDataP -> protocol . rpkData . publicKeyY , securityDataP -> protocol . rpkData . publicKeyYLen ); newSecurityP -> securityData . protocol . rpkData . publicKeyYLen = securityDataP -> protocol . rpkData . publicKeyYLen ; // Copy the private key newSecurityP -> securityData . protocol . rpkData . privateKey = iowa_system_malloc ( securityDataP -> protocol . rpkData . privateKeyLen ); if ( newSecurityP -> securityData . protocol . rpkData . privateKey == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . rpkData . publicKeyX ); iowa_system_free ( newSecurityP -> securityData . protocol . rpkData . publicKeyY ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . rpkData . privateKey , securityDataP -> protocol . rpkData . privateKey , securityDataP -> protocol . rpkData . privateKeyLen ); newSecurityP -> securityData . protocol . rpkData . privateKeyLen = securityDataP -> protocol . rpkData . privateKeyLen ; break ; default : break ; } newSecurityP -> serverUri = iowa_system_malloc ( peerIdentityLen ); if ( newSecurityP -> serverUri == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> serverUri , peerIdentity , peerIdentityLen ); // Add the new key clientDataP -> security = ( security_t * ) IOWA_UTILS_LIST_ADD ( clientDataP -> security , newSecurityP ); break ; } case IOWA_SEC_DELETE : { security_t * securityP ; securityP = clientDataP -> security ; while ( securityP != NULL && memcmp ( securityP -> serverUri , peerIdentity , peerIdentityLen ) != 0 ) { securityP = securityP -> next ; } if ( securityP == NULL ) { return IOWA_COAP_404_NOT_FOUND ; } switch ( securityP -> securityData . securityMode ) { case IOWA_SEC_PRE_SHARED_KEY : iowa_system_free ( securityP -> securityData . protocol . pskData . identity ); iowa_system_free ( securityP -> securityData . protocol . pskData . privateKey ); break ; case IOWA_SEC_CERTIFICATE : iowa_system_free ( securityP -> securityData . protocol . certData . caCertificate ); iowa_system_free ( securityP -> securityData . protocol . certData . certificate ); iowa_system_free ( securityP -> securityData . protocol . certData . privateKey ); break ; case IOWA_SEC_RAW_PUBLIC_KEY : iowa_system_free ( securityP -> securityData . protocol . rpkData . publicKeyX ); iowa_system_free ( securityP -> securityData . protocol . rpkData . publicKeyY ); iowa_system_free ( securityP -> securityData . protocol . rpkData . privateKey ); break ; default : break ; } clientDataP -> security = ( security_t * ) IOWA_UTILS_LIST_REMOVE ( clientDataP -> security , securityP ); iowa_system_free ( securityP -> serverUri ); iowa_system_free ( securityP ); } default : break ; } return IOWA_COAP_NO_ERROR ; }","title":"Bootstrap"},{"location":"Bootstrap/#bootstrap","text":"To enable the Bootstrap Interface on the client, IOWA must be built with the flag LWM2M_BOOTSTRAP . Furthermore to create a LwM2M Bootstrap Server, the flag LWM2M_BOOTSTRAP_SERVER_MODE must be set. Note: This flag can be set with LWM2M_SERVER_MODE , there is no conflict.","title":"Bootstrap"},{"location":"Bootstrap/#overview","text":"The Bootstrap mode is used to add one or more LwM2M Server Account into the LwM2M Client. IOWA currently supports the following Bootstrap mode: Factory Bootstrap Client initiated Bootstrap","title":"Overview"},{"location":"Bootstrap/#bootstrap-mode","text":"","title":"Bootstrap Mode"},{"location":"Bootstrap/#factory-bootstrap","text":"The LwM2M Client has, in this mode, already the LwM2M Server Account(s) configured. This mode does not require the LwM2M Client to connect to a LwM2M Bootstrap Server if the LwM2M Server accounts contain at least a LwM2M Server Information.","title":"Factory Bootstrap"},{"location":"Bootstrap/#client-initiated-bootstrap","text":"If no Server have been configured and a Bootstrap Server is supplied, the Client will connect to the Bootstrap Server to obtain the connection information of at least one Server. If the Client needs to connect to the Bootstrap Server with security, the keys need to be preloaded during Factory setup.","title":"Client initiated Bootstrap"},{"location":"Bootstrap/#flow","text":"","title":"Flow"},{"location":"Bootstrap/#bootstrap-request","text":"After Client booting, the Client sends a Bootstrap Request operation to the preloaded Bootstrap Server. On Bootstrap Request, the Bootstrap Server starts provisioning the Client with new LwM2M Server Accounts.","title":"Bootstrap Request"},{"location":"Bootstrap/#getting-bootstrap-information","text":"A typical client configuration flow is: Delete everything on the Client by sending a Delete operation on URI / , Optional step: Write a new LwM2M Bootstrap Server Account with Write operation on URI /0 , Write at least one LwM2M Server Account with Write operation on URI /0 and /1 . Writing a LwM2M Bootstrap Server Account is recommended. If the Client is unable to connect to the Server, it can fall back to Bootstrap mode. Instead of writing manually the Object Instance through Write operation, IOWA provides for the LwM2M Bootstrap Server high level operations: Add Bootstrap Server: add a [ Security Object ][Security Object] Instance, Remove Bootstrap Server: add the [ Security Object ][Security Object] Instance associated to the Bootstrap Server, Add Server: add a [ Security Object ][Security Object] Instance and a [ Server Object ][Server Object] Instance, Remove Server: remove the [ Security Object ][Security Object] Instance and the [ Server Object ][Server Object] Instance associated to the Server. These high level operations automatically provision the Resources of the Objects without the need to know how the Objects are structured.","title":"Getting Bootstrap Information"},{"location":"Bootstrap/#bootstrap-finish","text":"Once the LwM2M Server Account have been provisioned, the Bootstrap Server sends a Bootstrap Finish operation to start the Bootstrap Consistency check. The Bootstrap Consistency checks if the information provided is correct before exiting the Bootstrap mode. If the information is incorrect, an error is sent back to the Bootstrap Server by the Client to inform that the LwM2M Server Account loaded is not consistent. Bootstrap Consistency can fail for the following reasons: No Server Account provided, Only one Bootstrap Server Account provided without Server Account, Server URI requires a secured connection but no Security information is provided, Server URI requires a non secured connection but Security information is provided, Server URI requires a specific binding but the Resource Binding (ID: 7) of the [ Server Object ][Server Object] is different, Security information is not consistent across the Resources Security Mode (ID: 2), Public Key or Identity (ID: 3), Server Public Key (ID: 4) and Secret Key (ID: 5) of the [ Security Object ][Security Object]. If the Bootstrap Consistency passed, the Client will respond with no error to the Bootstrap Finish operation.","title":"Bootstrap Finish"},{"location":"Bootstrap/#server-registration","text":"Once the Bootstrap Consistency is done without error, the Client disconnects from the Bootstrap Server and starts a Registration to the loaded Server(s). If the Client does not get a response from the Server and if a Bootstrap Server is configured, the Client will fall back to Bootstrap mode.","title":"Server Registration"},{"location":"Bootstrap/#notes","text":"","title":"Notes"},{"location":"Bootstrap/#iowa-client-without-security","text":"The Factory mode is supported through the API: iowa_client_add_bootstrap_server() and iowa_client_add_server() . Below is an example indicating how to to provision the Bootstrap Server and start the Client initiated Bootstrap. Be careful, if a Server is also configured, the Client will not go to Bootstrap mode and instead go to Registration mode on the configured Server. #include \"iowa_client.h\" static void prv_eventCallback ( iowa_event_t * eventP , void * userData , iowa_context_t contextP ) { switch ( eventP -> eventType ) { case IOWA_EVENT_REG_UNREGISTERED : printf ( \"Server (short ID: %d): Unregistered \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_REG_REGISTERING : printf ( \"Server (short ID: %d): Registering \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_REG_REGISTERED : printf ( \"Server (short ID: %d): Registered with lifetime %ds \\r\\n \" , eventP -> serverShortId , eventP -> details . registration . lifetime ); break ; case IOWA_EVENT_REG_UPDATING : printf ( \"Server (short ID: %d): Registration updating \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_REG_FAILED : printf ( \"Server (short ID: %d): Registration failed. \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_BS_PENDING : printf ( \"Server (short ID: %d): Bootstrapping \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_BS_FAILED : printf ( \"Server (short ID: %d): Bootstrap failed \\r\\n \" , eventP -> serverShortId ); break ; case IOWA_EVENT_BS_FINISHED : printf ( \"Server (short ID: %d): Bootstrap finished \\r\\n \" , eventP -> serverShortId ); break ; default : // Do nothing break ; } } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); iowa_client_configure ( iowaH , \"IOWA_Client\" , NULL , prv_eventCallback ); iowa_client_add_bootstrap_server ( iowaH , \"coap://localhost:5783\" , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_bootstrap_server ( iowaH ); iowa_close ( iowaH ); return 0 ; } Once the Client starts: On first step loop, the iowa_event_callback_t callback is called to inform Bootstrap mode is beginning with event IOWA_EVENT_BS_PENDING , When the Bootstrap Finish is received and if the Bootstrap Consistency is passed, the event callback is called with event IOWA_EVENT_BS_FINISHED , After that the event callback gets called with event IOWA_EVENT_REG_REGISTERING to report that the Client is registering to the Server. If the Client is not able to register to the Server, the event callback is called with IOWA_EVENT_REG_FAILED and depending if a Bootstrap Server is configured, the Client: Automatically falls back to Bootstrap mode if a Bootstrap Server is configured, Exits the step loop with IOWA_COAP_503_SERVICE_UNAVAILABLE if no Bootstrap Server is configured. The Bootstrap can fail (event IOWA_EVENT_BS_FAILED ) when no command is received from the Bootstrap Server during a certain amount of time.","title":"IOWA Client (without Security)"},{"location":"Bootstrap/#iowa-client-with-security","text":"The previous example can be extended to support the Security. This example serves just to demonstrate how to use IOWA security API. For instance, a better way could be to use a Secure element to store the security keys. For this purpose, two structures are added to store the keys by Server Account: security_t.serverUri . The implementation uses the concept of Linked List with the help of IOWA API: [ IOWA_UTILS_LIST_ADD() ][IOWA_UTILS_LIST_ADD] and [ IOWA_UTILS_LIST_REMOVE() ][IOWA_UTILS_LIST_REMOVE]. typedef struct security_data_t_ { struct security_data_t_ * next ; iowa_security_data_t securityData ; char * serverUri ; } security_t ; typedef struct { security_t * security ; } client_data_t ; The main is updated to pass the data security data structure: #include \"iowa_client.h\" #define SERVER_URI \"coaps: //localhost:5784\" #define PSK_CLIENT_IDENTITY \"IOWA_CLIENT\" #define PSK_CLIENT_KEY_LENGTH 10 #define PSK_CLIENT_KEY {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39} int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; client_data_t clientData ; iowa_security_data_t securityData ; unsigned char psk [ PSK_CLIENT_KEY_LENGTH ] = PSK_CLIENT_KEY ; /****************** * Initialization */ memset ( & clientData , 0 , sizeof ( client_data_t )); // Add the Bootstrap Security key to the linked list memset ( & securityData , 0 , sizeof ( iowa_security_data_t )); securityData . securityMode = IOWA_SEC_PRE_SHARED_KEY ; securityData . protocol . pskData . identityLen = strlen ( PSK_CLIENT_IDENTITY ); securityData . protocol . pskData . identity = iowa_system_malloc ( securityData . protocol . pskData . identityLen ); memcpy ( securityData . protocol . pskData . identity , PSK_CLIENT_IDENTITY , securityData . protocol . pskData . identityLen ); securityData . protocol . pskData . privateKeyLen = PSK_CLIENT_KEY_LENGTH ; securityData . protocol . pskData . privateKey = iowa_system_malloc ( PSK_CLIENT_KEY_LENGTH ); memcpy ( securityData . protocol . pskData . privateKey , psk , PSK_CLIENT_KEY_LENGTH ); iowa_system_security_data (( uint8_t * ) SERVER_URI , strlen ( SERVER_URI ), IOWA_SEC_CREATE , & securityData , & clientData ); // Initialize IOWA iowaH = iowa_init ( & clientData ); iowa_client_configure ( iowaH , \"IOWA_Client\" , NULL , NULL ); iowa_client_add_bootstrap_server ( iowaH , SERVER_URI , IOWA_SEC_PRE_SHARED_KEY ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_bootstrap_server ( iowaH ); iowa_close ( iowaH ); // Remove the Bootstrap Security key iowa_system_security_data (( uint8_t * ) SERVER_URI , strlen ( SERVER_URI ), IOWA_SEC_DELETE , NULL , & clientData ); return 0 ; } And iowa_system_security_data() is expanded with the handle of IOWA_SEC_CREATE and IOWA_SEC_DELETE to support adding and removing keys by the Bootstrap Server. iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ) { client_data_t * clientDataP ; clientDataP = ( client_data_t * ) userDataP ; switch ( securityOp ) { case IOWA_SEC_READ : { security_t * securityP ; securityP = clientDataP -> security ; while ( securityP != NULL && memcmp ( securityP -> serverUri , peerIdentity , peerIdentityLen ) != 0 ) { securityP = securityP -> next ; } if ( securityP == NULL ) { return IOWA_COAP_404_NOT_FOUND ; } securityDataP -> securityMode = securityP -> securityData . securityMode ; switch ( securityDataP -> securityMode ) { case IOWA_SEC_PRE_SHARED_KEY : // Copy the identity securityDataP -> protocol . pskData . identity = securityP -> securityData . protocol . pskData . identity ; securityDataP -> protocol . pskData . identityLen = securityP -> securityData . protocol . pskData . identityLen ; // Copy the private key securityDataP -> protocol . pskData . privateKey = securityP -> securityData . protocol . pskData . privateKey ; securityDataP -> protocol . pskData . privateKeyLen = securityP -> securityData . protocol . pskData . privateKeyLen ; break ; case IOWA_SEC_CERTIFICATE : // Copy the CA certificate securityDataP -> protocol . certData . caCertificate = securityP -> securityData . protocol . certData . caCertificate ; securityDataP -> protocol . certData . caCertificateLen = securityP -> securityData . protocol . certData . caCertificateLen ; // Copy the certificate securityDataP -> protocol . certData . certificate = securityP -> securityData . protocol . certData . certificate ; securityDataP -> protocol . certData . certificateLen = securityP -> securityData . protocol . certData . certificateLen ; // Copy the private key securityDataP -> protocol . certData . privateKey = securityP -> securityData . protocol . certData . privateKey ; securityDataP -> protocol . certData . privateKeyLen = securityP -> securityData . protocol . certData . privateKeyLen ; break ; case IOWA_SEC_RAW_PUBLIC_KEY : // Copy the X public key securityDataP -> protocol . rpkData . publicKeyX = securityP -> securityData . protocol . rpkData . publicKeyX ; securityDataP -> protocol . rpkData . publicKeyXLen = securityP -> securityData . protocol . rpkData . publicKeyXLen ; // Copy the Y public key securityDataP -> protocol . rpkData . publicKeyY = securityP -> securityData . protocol . rpkData . publicKeyY ; securityDataP -> protocol . rpkData . publicKeyYLen = securityP -> securityData . protocol . rpkData . publicKeyYLen ; // Copy the private key securityDataP -> protocol . rpkData . privateKey = securityP -> securityData . protocol . rpkData . privateKey ; securityDataP -> protocol . rpkData . privateKeyLen = securityP -> securityData . protocol . rpkData . privateKeyLen ; break ; default : break ; } break ; } case IOWA_SEC_CREATE : { security_t * newSecurityP ; newSecurityP = iowa_system_malloc ( sizeof ( security_t )); if ( newSecurityP == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } newSecurityP -> next = NULL ; newSecurityP -> securityData . securityMode = securityDataP -> securityMode ; switch ( newSecurityP -> securityData . securityMode ) { case IOWA_SEC_PRE_SHARED_KEY : // Copy the identity newSecurityP -> securityData . protocol . pskData . identity = iowa_system_malloc ( securityDataP -> protocol . pskData . identityLen ); if ( newSecurityP -> securityData . protocol . pskData . identity == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . pskData . identity , securityDataP -> protocol . pskData . identity , securityDataP -> protocol . pskData . identityLen ); newSecurityP -> securityData . protocol . pskData . identityLen = securityDataP -> protocol . pskData . identityLen ; // Copy the private key newSecurityP -> securityData . protocol . pskData . privateKey = iowa_system_malloc ( securityDataP -> protocol . pskData . privateKeyLen ); if ( newSecurityP -> securityData . protocol . pskData . privateKey == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . pskData . identity ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . pskData . privateKey , securityDataP -> protocol . pskData . privateKey , securityDataP -> protocol . pskData . privateKeyLen ); newSecurityP -> securityData . protocol . pskData . privateKeyLen = securityDataP -> protocol . pskData . privateKeyLen ; break ; case IOWA_SEC_CERTIFICATE : // Copy the CA certificate newSecurityP -> securityData . protocol . certData . caCertificate = iowa_system_malloc ( securityDataP -> protocol . certData . caCertificateLen ); if ( newSecurityP -> securityData . protocol . certData . caCertificate == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . certData . caCertificate , securityDataP -> protocol . certData . caCertificate , securityDataP -> protocol . certData . caCertificateLen ); newSecurityP -> securityData . protocol . certData . caCertificateLen = securityDataP -> protocol . certData . caCertificateLen ; // Copy the certificate newSecurityP -> securityData . protocol . certData . certificate = iowa_system_malloc ( securityDataP -> protocol . certData . certificateLen ); if ( newSecurityP -> securityData . protocol . certData . certificate == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . certData . caCertificate ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . certData . certificate , securityDataP -> protocol . certData . certificate , securityDataP -> protocol . certData . certificateLen ); newSecurityP -> securityData . protocol . certData . certificateLen = securityDataP -> protocol . certData . certificateLen ; // Copy the private key newSecurityP -> securityData . protocol . certData . privateKey = iowa_system_malloc ( securityDataP -> protocol . certData . privateKeyLen ); if ( newSecurityP -> securityData . protocol . certData . privateKey == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . certData . caCertificate ); iowa_system_free ( newSecurityP -> securityData . protocol . certData . certificate ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . certData . privateKey , securityDataP -> protocol . certData . privateKey , securityDataP -> protocol . certData . privateKeyLen ); newSecurityP -> securityData . protocol . certData . privateKeyLen = securityDataP -> protocol . certData . privateKeyLen ; break ; case IOWA_SEC_RAW_PUBLIC_KEY : // Copy the X public key newSecurityP -> securityData . protocol . rpkData . publicKeyX = iowa_system_malloc ( securityDataP -> protocol . rpkData . publicKeyXLen ); if ( newSecurityP -> securityData . protocol . rpkData . publicKeyX == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . rpkData . publicKeyX , securityDataP -> protocol . rpkData . publicKeyX , securityDataP -> protocol . rpkData . publicKeyXLen ); newSecurityP -> securityData . protocol . rpkData . publicKeyXLen = securityDataP -> protocol . rpkData . publicKeyXLen ; // Copy the Y public key newSecurityP -> securityData . protocol . rpkData . publicKeyY = iowa_system_malloc ( securityDataP -> protocol . rpkData . publicKeyYLen ); if ( newSecurityP -> securityData . protocol . rpkData . publicKeyY == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . rpkData . publicKeyX ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . rpkData . publicKeyY , securityDataP -> protocol . rpkData . publicKeyY , securityDataP -> protocol . rpkData . publicKeyYLen ); newSecurityP -> securityData . protocol . rpkData . publicKeyYLen = securityDataP -> protocol . rpkData . publicKeyYLen ; // Copy the private key newSecurityP -> securityData . protocol . rpkData . privateKey = iowa_system_malloc ( securityDataP -> protocol . rpkData . privateKeyLen ); if ( newSecurityP -> securityData . protocol . rpkData . privateKey == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); iowa_system_free ( newSecurityP -> securityData . protocol . rpkData . publicKeyX ); iowa_system_free ( newSecurityP -> securityData . protocol . rpkData . publicKeyY ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> securityData . protocol . rpkData . privateKey , securityDataP -> protocol . rpkData . privateKey , securityDataP -> protocol . rpkData . privateKeyLen ); newSecurityP -> securityData . protocol . rpkData . privateKeyLen = securityDataP -> protocol . rpkData . privateKeyLen ; break ; default : break ; } newSecurityP -> serverUri = iowa_system_malloc ( peerIdentityLen ); if ( newSecurityP -> serverUri == NULL ) { fprintf ( stderr , \"Memory allocation failed\" ); iowa_system_free ( newSecurityP ); return IOWA_COAP_500_INTERNAL_SERVER_ERROR ; } memcpy ( newSecurityP -> serverUri , peerIdentity , peerIdentityLen ); // Add the new key clientDataP -> security = ( security_t * ) IOWA_UTILS_LIST_ADD ( clientDataP -> security , newSecurityP ); break ; } case IOWA_SEC_DELETE : { security_t * securityP ; securityP = clientDataP -> security ; while ( securityP != NULL && memcmp ( securityP -> serverUri , peerIdentity , peerIdentityLen ) != 0 ) { securityP = securityP -> next ; } if ( securityP == NULL ) { return IOWA_COAP_404_NOT_FOUND ; } switch ( securityP -> securityData . securityMode ) { case IOWA_SEC_PRE_SHARED_KEY : iowa_system_free ( securityP -> securityData . protocol . pskData . identity ); iowa_system_free ( securityP -> securityData . protocol . pskData . privateKey ); break ; case IOWA_SEC_CERTIFICATE : iowa_system_free ( securityP -> securityData . protocol . certData . caCertificate ); iowa_system_free ( securityP -> securityData . protocol . certData . certificate ); iowa_system_free ( securityP -> securityData . protocol . certData . privateKey ); break ; case IOWA_SEC_RAW_PUBLIC_KEY : iowa_system_free ( securityP -> securityData . protocol . rpkData . publicKeyX ); iowa_system_free ( securityP -> securityData . protocol . rpkData . publicKeyY ); iowa_system_free ( securityP -> securityData . protocol . rpkData . privateKey ); break ; default : break ; } clientDataP -> security = ( security_t * ) IOWA_UTILS_LIST_REMOVE ( clientDataP -> security , securityP ); iowa_system_free ( securityP -> serverUri ); iowa_system_free ( securityP ); } default : break ; } return IOWA_COAP_NO_ERROR ; }","title":"IOWA Client (with Security)"},{"location":"BootstrapServerAPI/","text":"Bootstrap Server Mode API Reference \u00b6 The functions explained below are defined inside the file include/iowa_server.h . Bootstrap Server pseudo code \u00b6 #include \"iowa_server.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; int bootstrapServerSocket ; /****************** * Initialization */ bootstrapServerSocket = open_udp_socket (); iowaH = iowa_init ( NULL ); result = iowa_bootstrap_server_configure ( iowaH , client_monitor , NULL ); /****************** * \"Main loop\" */ while ( result == IOWA_COAP_NO_ERROR ) { result = iowa_step ( iowaH , 10 ); if ( isDataAvailable ( bootstrapServerSocket )) { void * newConnection ; newConnection = create_new_connection (); result = iowa_server_new_incoming_connection ( iowaH , IOWA_CONN_DATAGRAM , newConnection ); } } iowa_close ( iowaH ); close ( bootstrapServerSocket ); return 0 ; } Callbacks \u00b6 iowa_bootstrap_result_callback_t \u00b6 The bootstrap APIs ( iowa_bootstrap_server_write() , iowa_bootstrap_server_delete() , iowa_bootstrap_server_finish() ) and iowa_bootstrap_server_add_server() ) are using an iowa_bootstrap_result_callback_t to asynchronously return the result of the operation. typedef void ( * iowa_bootstrap_result_callback_t ) ( iowa_bootstrap_operation_t operation , uint16_t clientId , uint16_t objectId , uint16_t instanceId , uint16_t resourceId , iowa_status_t status , size_t length , uint8_t * buffer , void * resultUserData , iowa_context_t contextP ); operation : The type of command matching this result. clientId : The ID of the client targeted by the command. objectId : The ID of the Object targeted by the command. instanceId : The ID of the Instance targeted by the command. This may be IOWA_LWM2M_ID_ALL . resourceId : The ID of the Resource targeted by the command. This may be IOWA_LWM2M_ID_ALL . status : The status of the command. length : The length of the payload when the operation is IOWA_BOOTSTRAP_DISCOVER . buffer : The payload containing the CoRE Link information when the operation is IOWA_BOOTSTRAP_DISCOVER . resultUserData : A pointer to application specific data. This is a parameter of the matching iowa_bootstrap_server...() API. contextP : The IOWA context on which the bootstrap API was called. \\clearpage API \u00b6 iowa_bootstrap_server_configure \u00b6 Prototype iowa_status_t iowa_bootstrap_server_configure ( iowa_context_t contextP , iowa_monitor_callback_t monitorCb , void * callbackUserData ); Description iowa_bootstrap_server_configure() sets the monitoring callback called when LwM2M Clients connect to the LwM2M Bootstrap Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. monitorCb : The callback called when Clients update their status. This can be nil. callbackUserData : A pointer to application specific data. This is passed as argument to monitorCb and resTypeCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. Header File iowa_server.h \\clearpage iowa_bootstrap_server_new_incoming_connection \u00b6 Prototype iowa_status_t iowa_bootstrap_server_new_incoming_connection ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); Description iowa_bootstrap_server_new_incoming_connection() informs the stack of a new incoming connection. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The type of the new connection. See iowa_connection_type_t . connP : The new connection of the same user-defined type as the one returned by iowa_system_connection_open() . isSecure : Set to true if the security must be enabled on this connection. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - type is not supported. Header File iowa_server.h \\clearpage iowa_bootstrap_server_read \u00b6 Prototype iowa_status_t iowa_bootstrap_server_read ( iowa_context_t contextP , uint32_t clientId , iowa_lwm2m_uri_t * uriP , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_bootstrap_server_read() performs a Bootstrap Read operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uriP : The URI targeted by the operation. responseCb : The callback called when the reply to this operation is known. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - uriP is nil. : - responseCb is nil. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - uriP cannot target Root, Resource or Resource Instance level : - uriP->objectId must target the [Server Object][Server Object] or the [Access Control List Object][Access Control List Object]. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes This API requires the compilation flag [ LWM2M_VERSION_1_1_SUPPORT ][LWM2M_VERSION_1_1_SUPPORT]. Per LwM2M specification, if the Bootstrap Read was successful, the Client will return a IOWA_COAP_205_CONTENT status code. The responseCb will be called with the operation set to IOWA_BOOTSTRAP_READ . \\clearpage iowa_bootstrap_server_write \u00b6 Prototype iowa_status_t iowa_bootstrap_server_write ( iowa_context_t contextP , uint32_t clientId , uint16_t objectId , uint16_t instanceId , size_t dataCount , iowa_lwm2m_data_t * dataArray , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_write() performs a Bootstrap Write operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . objectId : The Object targeted by the operation. instanceId : The Instance object targeted by the operation. dataCount : The number of data to write. dataArray : The data to write. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - objectId or instanceId is IOWA_LWM2M_ID_ALL . : - dataCount is zero or dataArray is nil. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_406_NOT_ACCEPTABLE : Either: : - dataArrayP contains several data with defined timestamp. : - dataArrayP contains several data with unsigned integer which are negative. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes Per LwM2M specification, if the Bootstrap Write was successful, the Client will return a IOWA_COAP_204_CHANGED status code. The IDs contained in the data must match objectId and instanceId . The resultCb will be called with the operation set to IOWA_BOOTSTRAP_WRITE . \\clearpage iowa_bootstrap_server_delete \u00b6 Prototype iowa_status_t iowa_bootstrap_server_delete ( iowa_context_t contextP , uint32_t clientId , uint16_t objectId , uint16_t instanceId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_delete() performs a Bootstrap Delete operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . objectId : The ID of the Object to delete. This can be IOWA_LWM2M_ID_ALL . instanceId : The ID of the instance to delete. This can be IOWA_LWM2M_ID_ALL . resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes Per LwM2M specification, if the Bootstrap Delete was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Per LwM2M specification, the Bootstrap Server can request the Client to delete all Objects and Object Instances (except for the Bootstrap Server account) in a single operation by setting objectId and instanceId to IOWA_LWM2M_ID_ALL . The resultCb will be called with the operation set to IOWA_BOOTSTRAP_DELETE . \\clearpage iowa_bootstrap_server_discover \u00b6 Prototype iowa_status_t iowa_bootstrap_server_discover ( iowa_context_t contextP , uint32_t clientId , uint16_t objectId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_discover() performs a Bootstrap Discover operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . objectId : The ID of the Object targeted by the operation. This can be IOWA_LWM2M_ID_ALL . resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't received all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes Per LwM2M specification, the Bootstrap Discover operation only returns the list of Objects and Object Instances with some attributes: LwM2M Enabler version (\"lwm2m=\"), Short Server ID (\"ssid=\"), and LwM2M Server URI (\"uri=\"). The resultCb will be called with the operation set to IOWA_BOOTSTRAP_DISCOVER . \\clearpage iowa_bootstrap_server_finish \u00b6 Prototype iowa_status_t iowa_bootstrap_server_finish ( iowa_context_t contextP , uint32_t clientId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_finish() performs a Bootstrap Server operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes Per LwM2M specification, if the Bootstrap Finish was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Otherwise the Client will return an IOWA_COAP_406_NOT_ACCEPTABLE status code. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_FINISH . \\clearpage iowa_bootstrap_server_add_server \u00b6 Prototype iowa_status_t iowa_bootstrap_server_add_server ( iowa_context_t contextP , uint32_t clientId , uint16_t shortServerId , const char * uri , uint32_t lifetime , iowa_security_data_t * securityDataP , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_add_server() adds the proper Security and Server object to the client to configure a Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . shortServerId : The short ID of the Server. uri : The URI of the Server. lifetime : The lifetime in seconds of the registration. securityDataP : The security data to use to connect properly to the Server. This can be nil. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - uri is nil. : - shortServerId is 0 or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes iowa_bootstrap_server_add_server() calls internally iowa_bootstrap_server_discover to retrieve the [ Security Object ][Security Object] Instances and [ Server Object ][Server Object] Instances, then calls iowa_bootstrap_server_write two times to write a new [ Security Object ][Security Object] Instance and a new [ Server Object ][Server Object] Instance. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_ADD_SERVER . Per LwM2M specification, if adding the server was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Currently, it is not possible to configure both OSCORE and another transport security through this API. If needed, use iowa_bootstrap_server_write() . \\clearpage iowa_bootstrap_server_remove_server \u00b6 Prototype iowa_status_t iowa_bootstrap_server_remove_server ( iowa_context_t contextP , uint32_t clientId , uint16_t shortServerId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_remove_server() removes the proper Security and [ Server Object ][Server Object] Instance associated to the Short Server ID from a client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . shortServerId : The short ID of the Server. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : shortServerId is 0 or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes iowa_bootstrap_server_remove_server() calls internally iowa_bootstrap_server_discover to retrieve the [ Security Object ][Security Object] Instances and [ Server Object ][Server Object] Instances, then calls iowa_bootstrap_server_delete two times to delete a [ Security Object ][Security Object] Instance and a [ Server Object ][Server Object] Instance. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_REMOVE_SERVER . Per LwM2M specification: if removing the server was successful, the Client will return an IOWA_COAP_202_DELETED status code. If the [ Security Object ][Security Object] Instance and/or the [ Server Object ][Server Object] Instance associated to the LwM2M Server have not been found after the Discover operation, the result callback will be called with the following parameters: objectId: IOWA_LWM2M_SECURITY_OBJECT_ID or IOWA_LWM2M_SERVER_OBJECT_ID instanceId: IOWA_LWM2M_ID_ALL resourceId: IOWA_LWM2M_ID_ALL status: IOWA_COAP_404_NOT_FOUND \\clearpage iowa_bootstrap_server_add_bootstrap_server \u00b6 Prototype iowa_status_t iowa_bootstrap_server_add_bootstrap_server ( iowa_context_t contextP , uint32_t clientId , const char * uri , int32_t clientHoldOff , uint32_t bootstrapAccountTimeout , iowa_security_data_t * securityDataP , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_add_bootstrap_server() adds the proper Security object to the client to configure a Bootstrap Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uri : The URI of the Server. clientHoldOff : The number of seconds to wait before initiating a Client Initiated Bootstrap. bootstrapAccountTimeout : Time to wait by the client before to purge the LwM2M Bootstrap-Server Account. securityDataP : The security data to use to connect properly to the Server. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_400_BAD_REQUEST : uri is nil. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes iowa_bootstrap_server_add_bootstrap_server() calls internally iowa_bootstrap_server_discover to retrieve the [ Security Object ][Security Object] Instances, then iowa_bootstrap_server_write to write a [ Security Object ][Security Object] Instance. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_ADD_BOOTSTRAP_SERVER . Per LwM2M specification, if adding the bootstrap server was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Currently, it is not possible to configure both OSCORE and another transport security through this API. If needed, use iowa_bootstrap_server_write() . \\clearpage iowa_bootstrap_server_remove_bootstrap_server \u00b6 Prototype iowa_status_t iowa_bootstrap_server_remove_bootstrap_server ( iowa_context_t contextP , uint32_t clientId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_remove_bootstrap_server() removes the proper [ Security Object ][Security Object] Instance associated to the Bootstrap Server from a client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes iowa_bootstrap_server_remove_bootstrap_server() calls internally iowa_bootstrap_server_discover to retrieve the [ Security Object ][Security Object] Instances, then calls iowa_bootstrap_server_delete to delete a [ Security Object ][Security Object] Instance. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_REMOVE_BOOTSTRAP_SERVER . Per LwM2M specification: if the removing the bootstrap server was successful, the Client will return an IOWA_COAP_202_DELETED status code. If the [ Security Object ][Security Object] Instance associated to the LwM2M Bootstrap Server have not been found after the Discover operation, the result callback will be called with the following parameters: objectId: IOWA_LWM2M_SECURITY_OBJECT_ID instanceId: IOWA_LWM2M_ID_ALL resourceId: IOWA_LWM2M_ID_ALL status: IOWA_COAP_404_NOT_FOUND","title":"Bootstrap Server APIs"},{"location":"BootstrapServerAPI/#bootstrap-server-mode-api-reference","text":"The functions explained below are defined inside the file include/iowa_server.h .","title":"Bootstrap Server Mode API Reference"},{"location":"BootstrapServerAPI/#bootstrap-server-pseudo-code","text":"#include \"iowa_server.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; int bootstrapServerSocket ; /****************** * Initialization */ bootstrapServerSocket = open_udp_socket (); iowaH = iowa_init ( NULL ); result = iowa_bootstrap_server_configure ( iowaH , client_monitor , NULL ); /****************** * \"Main loop\" */ while ( result == IOWA_COAP_NO_ERROR ) { result = iowa_step ( iowaH , 10 ); if ( isDataAvailable ( bootstrapServerSocket )) { void * newConnection ; newConnection = create_new_connection (); result = iowa_server_new_incoming_connection ( iowaH , IOWA_CONN_DATAGRAM , newConnection ); } } iowa_close ( iowaH ); close ( bootstrapServerSocket ); return 0 ; }","title":"Bootstrap Server pseudo code"},{"location":"BootstrapServerAPI/#callbacks","text":"","title":"Callbacks"},{"location":"BootstrapServerAPI/#iowa_bootstrap_result_callback_t","text":"The bootstrap APIs ( iowa_bootstrap_server_write() , iowa_bootstrap_server_delete() , iowa_bootstrap_server_finish() ) and iowa_bootstrap_server_add_server() ) are using an iowa_bootstrap_result_callback_t to asynchronously return the result of the operation. typedef void ( * iowa_bootstrap_result_callback_t ) ( iowa_bootstrap_operation_t operation , uint16_t clientId , uint16_t objectId , uint16_t instanceId , uint16_t resourceId , iowa_status_t status , size_t length , uint8_t * buffer , void * resultUserData , iowa_context_t contextP ); operation : The type of command matching this result. clientId : The ID of the client targeted by the command. objectId : The ID of the Object targeted by the command. instanceId : The ID of the Instance targeted by the command. This may be IOWA_LWM2M_ID_ALL . resourceId : The ID of the Resource targeted by the command. This may be IOWA_LWM2M_ID_ALL . status : The status of the command. length : The length of the payload when the operation is IOWA_BOOTSTRAP_DISCOVER . buffer : The payload containing the CoRE Link information when the operation is IOWA_BOOTSTRAP_DISCOVER . resultUserData : A pointer to application specific data. This is a parameter of the matching iowa_bootstrap_server...() API. contextP : The IOWA context on which the bootstrap API was called. \\clearpage","title":"iowa_bootstrap_result_callback_t"},{"location":"BootstrapServerAPI/#api","text":"","title":"API"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_configure","text":"Prototype iowa_status_t iowa_bootstrap_server_configure ( iowa_context_t contextP , iowa_monitor_callback_t monitorCb , void * callbackUserData ); Description iowa_bootstrap_server_configure() sets the monitoring callback called when LwM2M Clients connect to the LwM2M Bootstrap Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. monitorCb : The callback called when Clients update their status. This can be nil. callbackUserData : A pointer to application specific data. This is passed as argument to monitorCb and resTypeCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. Header File iowa_server.h \\clearpage","title":"iowa_bootstrap_server_configure"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_new_incoming_connection","text":"Prototype iowa_status_t iowa_bootstrap_server_new_incoming_connection ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); Description iowa_bootstrap_server_new_incoming_connection() informs the stack of a new incoming connection. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The type of the new connection. See iowa_connection_type_t . connP : The new connection of the same user-defined type as the one returned by iowa_system_connection_open() . isSecure : Set to true if the security must be enabled on this connection. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - type is not supported. Header File iowa_server.h \\clearpage","title":"iowa_bootstrap_server_new_incoming_connection"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_read","text":"Prototype iowa_status_t iowa_bootstrap_server_read ( iowa_context_t contextP , uint32_t clientId , iowa_lwm2m_uri_t * uriP , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_bootstrap_server_read() performs a Bootstrap Read operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uriP : The URI targeted by the operation. responseCb : The callback called when the reply to this operation is known. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - uriP is nil. : - responseCb is nil. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - uriP cannot target Root, Resource or Resource Instance level : - uriP->objectId must target the [Server Object][Server Object] or the [Access Control List Object][Access Control List Object]. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes This API requires the compilation flag [ LWM2M_VERSION_1_1_SUPPORT ][LWM2M_VERSION_1_1_SUPPORT]. Per LwM2M specification, if the Bootstrap Read was successful, the Client will return a IOWA_COAP_205_CONTENT status code. The responseCb will be called with the operation set to IOWA_BOOTSTRAP_READ . \\clearpage","title":"iowa_bootstrap_server_read"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_write","text":"Prototype iowa_status_t iowa_bootstrap_server_write ( iowa_context_t contextP , uint32_t clientId , uint16_t objectId , uint16_t instanceId , size_t dataCount , iowa_lwm2m_data_t * dataArray , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_write() performs a Bootstrap Write operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . objectId : The Object targeted by the operation. instanceId : The Instance object targeted by the operation. dataCount : The number of data to write. dataArray : The data to write. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - objectId or instanceId is IOWA_LWM2M_ID_ALL . : - dataCount is zero or dataArray is nil. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_406_NOT_ACCEPTABLE : Either: : - dataArrayP contains several data with defined timestamp. : - dataArrayP contains several data with unsigned integer which are negative. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes Per LwM2M specification, if the Bootstrap Write was successful, the Client will return a IOWA_COAP_204_CHANGED status code. The IDs contained in the data must match objectId and instanceId . The resultCb will be called with the operation set to IOWA_BOOTSTRAP_WRITE . \\clearpage","title":"iowa_bootstrap_server_write"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_delete","text":"Prototype iowa_status_t iowa_bootstrap_server_delete ( iowa_context_t contextP , uint32_t clientId , uint16_t objectId , uint16_t instanceId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_delete() performs a Bootstrap Delete operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . objectId : The ID of the Object to delete. This can be IOWA_LWM2M_ID_ALL . instanceId : The ID of the instance to delete. This can be IOWA_LWM2M_ID_ALL . resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes Per LwM2M specification, if the Bootstrap Delete was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Per LwM2M specification, the Bootstrap Server can request the Client to delete all Objects and Object Instances (except for the Bootstrap Server account) in a single operation by setting objectId and instanceId to IOWA_LWM2M_ID_ALL . The resultCb will be called with the operation set to IOWA_BOOTSTRAP_DELETE . \\clearpage","title":"iowa_bootstrap_server_delete"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_discover","text":"Prototype iowa_status_t iowa_bootstrap_server_discover ( iowa_context_t contextP , uint32_t clientId , uint16_t objectId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_discover() performs a Bootstrap Discover operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . objectId : The ID of the Object targeted by the operation. This can be IOWA_LWM2M_ID_ALL . resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't received all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes Per LwM2M specification, the Bootstrap Discover operation only returns the list of Objects and Object Instances with some attributes: LwM2M Enabler version (\"lwm2m=\"), Short Server ID (\"ssid=\"), and LwM2M Server URI (\"uri=\"). The resultCb will be called with the operation set to IOWA_BOOTSTRAP_DISCOVER . \\clearpage","title":"iowa_bootstrap_server_discover"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_finish","text":"Prototype iowa_status_t iowa_bootstrap_server_finish ( iowa_context_t contextP , uint32_t clientId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_finish() performs a Bootstrap Server operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes Per LwM2M specification, if the Bootstrap Finish was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Otherwise the Client will return an IOWA_COAP_406_NOT_ACCEPTABLE status code. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_FINISH . \\clearpage","title":"iowa_bootstrap_server_finish"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_add_server","text":"Prototype iowa_status_t iowa_bootstrap_server_add_server ( iowa_context_t contextP , uint32_t clientId , uint16_t shortServerId , const char * uri , uint32_t lifetime , iowa_security_data_t * securityDataP , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_add_server() adds the proper Security and Server object to the client to configure a Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . shortServerId : The short ID of the Server. uri : The URI of the Server. lifetime : The lifetime in seconds of the registration. securityDataP : The security data to use to connect properly to the Server. This can be nil. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - uri is nil. : - shortServerId is 0 or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes iowa_bootstrap_server_add_server() calls internally iowa_bootstrap_server_discover to retrieve the [ Security Object ][Security Object] Instances and [ Server Object ][Server Object] Instances, then calls iowa_bootstrap_server_write two times to write a new [ Security Object ][Security Object] Instance and a new [ Server Object ][Server Object] Instance. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_ADD_SERVER . Per LwM2M specification, if adding the server was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Currently, it is not possible to configure both OSCORE and another transport security through this API. If needed, use iowa_bootstrap_server_write() . \\clearpage","title":"iowa_bootstrap_server_add_server"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_remove_server","text":"Prototype iowa_status_t iowa_bootstrap_server_remove_server ( iowa_context_t contextP , uint32_t clientId , uint16_t shortServerId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_remove_server() removes the proper Security and [ Server Object ][Server Object] Instance associated to the Short Server ID from a client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . shortServerId : The short ID of the Server. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : shortServerId is 0 or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes iowa_bootstrap_server_remove_server() calls internally iowa_bootstrap_server_discover to retrieve the [ Security Object ][Security Object] Instances and [ Server Object ][Server Object] Instances, then calls iowa_bootstrap_server_delete two times to delete a [ Security Object ][Security Object] Instance and a [ Server Object ][Server Object] Instance. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_REMOVE_SERVER . Per LwM2M specification: if removing the server was successful, the Client will return an IOWA_COAP_202_DELETED status code. If the [ Security Object ][Security Object] Instance and/or the [ Server Object ][Server Object] Instance associated to the LwM2M Server have not been found after the Discover operation, the result callback will be called with the following parameters: objectId: IOWA_LWM2M_SECURITY_OBJECT_ID or IOWA_LWM2M_SERVER_OBJECT_ID instanceId: IOWA_LWM2M_ID_ALL resourceId: IOWA_LWM2M_ID_ALL status: IOWA_COAP_404_NOT_FOUND \\clearpage","title":"iowa_bootstrap_server_remove_server"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_add_bootstrap_server","text":"Prototype iowa_status_t iowa_bootstrap_server_add_bootstrap_server ( iowa_context_t contextP , uint32_t clientId , const char * uri , int32_t clientHoldOff , uint32_t bootstrapAccountTimeout , iowa_security_data_t * securityDataP , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_add_bootstrap_server() adds the proper Security object to the client to configure a Bootstrap Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uri : The URI of the Server. clientHoldOff : The number of seconds to wait before initiating a Client Initiated Bootstrap. bootstrapAccountTimeout : Time to wait by the client before to purge the LwM2M Bootstrap-Server Account. securityDataP : The security data to use to connect properly to the Server. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_400_BAD_REQUEST : uri is nil. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes iowa_bootstrap_server_add_bootstrap_server() calls internally iowa_bootstrap_server_discover to retrieve the [ Security Object ][Security Object] Instances, then iowa_bootstrap_server_write to write a [ Security Object ][Security Object] Instance. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_ADD_BOOTSTRAP_SERVER . Per LwM2M specification, if adding the bootstrap server was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Currently, it is not possible to configure both OSCORE and another transport security through this API. If needed, use iowa_bootstrap_server_write() . \\clearpage","title":"iowa_bootstrap_server_add_bootstrap_server"},{"location":"BootstrapServerAPI/#iowa_bootstrap_server_remove_bootstrap_server","text":"Prototype iowa_status_t iowa_bootstrap_server_remove_bootstrap_server ( iowa_context_t contextP , uint32_t clientId , iowa_bootstrap_result_callback_t resultCb , void * resultUserData ); Description iowa_bootstrap_server_remove_bootstrap_server() removes the proper [ Security Object ][Security Object] Instance associated to the Bootstrap Server from a client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - clientId is IOWA_LWM2M_ID_ALL IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : iowa_system_connection_send() returned an error. Header File iowa_server.h Notes iowa_bootstrap_server_remove_bootstrap_server() calls internally iowa_bootstrap_server_discover to retrieve the [ Security Object ][Security Object] Instances, then calls iowa_bootstrap_server_delete to delete a [ Security Object ][Security Object] Instance. The resultCb will be called with the operation set to IOWA_BOOTSTRAP_REMOVE_BOOTSTRAP_SERVER . Per LwM2M specification: if the removing the bootstrap server was successful, the Client will return an IOWA_COAP_202_DELETED status code. If the [ Security Object ][Security Object] Instance associated to the LwM2M Bootstrap Server have not been found after the Discover operation, the result callback will be called with the following parameters: objectId: IOWA_LWM2M_SECURITY_OBJECT_ID instanceId: IOWA_LWM2M_ID_ALL resourceId: IOWA_LWM2M_ID_ALL status: IOWA_COAP_404_NOT_FOUND","title":"iowa_bootstrap_server_remove_bootstrap_server"},{"location":"Changelog/","text":"Changelog \u00b6 2020-09.1 \u00b6 Behavior Changes When an Observation is set on asynchronous resources, the Client [event callback][iowa_event_callback_t] is called with an [IOWA_EVENT_READ][iowa_event_type_t] event. When using mbed TLS, the MTU is declared during the DTLS/TLS handshake. SDK Changes [ iowa_server_configuration_set() ][iowa_server_configuration_set] is deprecated and renamed [ iowa_client_set_server_configuration() ][iowa_client_set_server_configuration]. iowa_dimmer.h can now be imported without importing first iowa_ipso.h . Bug Fixes Fix a possible core dump when IOWA reconnects a disconnected CoAP peer. Fix a but where the Client was rejecting an Object Instance creation using TLV if the payload was not containing the new Object Instance ID. Fix a possible memory leak if the registration reply from the Server does not contain a location path. Avoid a compilation error when [IOWA_DEVICE_RSC_FACTORY_RESET_REMOVE][Device] is defined. When using mbed TLS, fix a bug preventing to send a payload larger than 16384 bytes over TLS. 2020-09 \u00b6 New Features Add two APIs [ iowa_client_get_server_count() ][iowa_client_get_server_count] and [ iowa_client_get_server_array() ][iowa_client_get_server_array] to retrieve the bootstrapped and declared LwM2M Servers. Add an API [ iowa_server_configuration_set() ][iowa_server_configuration_set] to update the lifetime and the queue mode of a LwM2M Server. Add an API [ iowa_client_update_device_information() ][iowa_client_update_device_information] to update the device information at runtime. Add a new API [ iowa_clock_reset() ][iowa_clock_reset] to inform IOWA of clock issues. The API [ iowa_client_set_device_error_code() ][iowa_client_set_device_error_code] now allow user-defined error codes. Behavior Changes For LwM2M Server applications, IOWA now takes care of the reassembly of CoAP block transfers. Events IOWA_EVENT_OBSERVATION_STARTED and IOWA_EVENT_OBSERVATION_CANCELED are now emitted after having updated the internal IOWA context. CoAP block-wise transfers use the negotiated block size during all the block-wise transfer. In the AT Command Object, the strings passed to [ iowa_client_at_command_set_response() ][iowa_client_at_command_set_response] are appended to the existing ones instead of replacing them. In CoAP messages, URI-Path option is not included when URI is \"/\". In the LwM2M layer, MAX_TRANSMIT_WAIT has a duration of 20 seconds for TCP peers and 120 seconds for LoRaWAN peers. The return value of [ iowa_system_security_data() ][iowa_system_security_data] is no longer checked when IOWA calls it for an IOWA_SEC_FREE operation. Add multiple parameters checks in Objects APIs. In [ iowa_client_light_control_set_state() ][iowa_client_light_control_set_state], [ iowa_system_gettime() ][iowa_system_gettime] is called only if the resource \"On Time\" is enabled. The LwM2M Client now ignores unexpected CoAP responses. SDK Changes Remove Dimmer object from IPSO objects and add its own API. All [ iowa_apn_connection_profile_details_t ][iowa_apn_connection_profile_details_t] integer members are now unsigned. [ iowa_device_time_info_t::currentTime ][iowa_device_time_info_t] was changed from uint32_t to int32_t . Included mbed TLS was updated to version 2.24.0. Bug Fixes Fix a bug when calling [ iowa_flush_before_pause() ][iowa_flush_before_pause] on TCP connections. Fix a possible deadlock when calling [ iowa_system_random_vector_generator() ][iowa_system_random_vector_generator]. Fix a possible core dump when reading a Resource Instance containing a nil value. Fix a buffer overflow in serialization of integer CoAP option with a number greater than 269. Fix a bug when parsing large RFC8323 COAP headers. For Bootstrap Server applications, fix a bug where the unexpected disconnection of a TCP Client may lead to an invalid read. Fix a potential invalid read if the Client fails to send its registration message. Fix a possible bug when generating a new token. Fix several bugs when the Client uses CoAP block transfers for the registration message. For LwM2M Server applications, fix a potential stack corruption when the connection type is one of UDP, SMS, or LoRaWAN, and when iowa_system_random_vector_generator() fails. Fix a possible memory leak when creating a new CoAP peer. Fix a possible bug when generating a new token. In several Objects, fix a potential invalid read when string Resources under Observation are modified repeatedly. In the Location and GPS Objects, fix a potential segmentation fault when allocating memory for a string value fails. Fix a possible memory leak when deleting an APN Object Instance. Fix a potential invalid free when calling [ iowa_client_send_sensor_data() ][iowa_client_send_sensor_data]. Fix a Bootstrap-Delete bug when ACL are enabled. 2020-06.2 \u00b6 Bug Fixes Fix an interoperability bug in SenML JSON related to base64 encoding of opaque values. Fix a potential invalid read when deleting an ACL Object instance. Fix a potential memory leak when creating a new CoAP peer fails. Correct several conversion compiler warnings. Fix an offset error when parsing long CoAP over TCP headers. Fix interoperability issue with CoAP FETCH method when using Block-Transfer. Fix a possible memory leak when deleting an APN Object Instance. 2020-06.1 \u00b6 Behavior Changes For RFC7252 CoAP connections, e.g. LwM2M over UDP, the initial message ID is now random (using [ iowa_system_random_vector_generator() ][iowa_system_random_vector_generator]). The LwM2M Registration will now fail if the transmission was successful but no response was received after a delay set to EXCHANGE_LIFETIME from RFC7252. Bug Fixes Fix a bug when the Current Time resource was read asynchronously. 2020-06 \u00b6 New Features Add support of the MQTT Broker Object (ID: 18330) and of the MQTT Publication Object (ID: 18831). See [MQTT Object API][MQTT Object API]. The CoAP retransmission parameters can be modified at runtime. See [ iowa_coap_peer_configuration_set() ][iowa_coap_peer_configuration_set] and [ iowa_coap_peer_configuration_get() ][iowa_coap_peer_configuration_get]. New APIs to retrieve the CoAP peer associated to a LwM2M Server to ease usage of the previous APIs. See [ iowa_client_get_server_coap_peer() ][iowa_client_get_server_coap_peer] and [ iowa_client_get_bootstrap_server_coap_peer() ][iowa_client_get_bootstrap_server_coap_peer]. Support of the \"Reset Error Code\" Resource of the [Device Object][Device Object]. For Client applications, add a new event when an notification for an Observation was generated and is about to be sent. See IOWA_EVENT_OBSERVATION_NOTIFICATION in [iowa_event_type_t][iowa_event_type_t]. For Client applications, the events related to Observations now include the ID of the specific resource under observation if any. Introduce a new special value IOWA_DEVICE_TIME_SENSOR_ID of an [ iowa_sensor_t ][iowa_sensor_t] to refer to the Current Time of the Device. Behavior Changes The API [ iowa_client_notification_lock() ][iowa_client_notification_lock] now also prevents registration updates. The IOWA_EVENT_BS_PENDING event is emitted when connecting to the LwM2M Bootstrap Server instead of after receiving the reply to the Bootstrap-Request operation. The IOWA_EVENT_REG_REGISTERING event is emitted when connecting to the LwM2M Server instead of after sending the Registration message. Returned error codes for Object related APIs are more consistent. Stricter checks of the parameters passed to [ iowa_client_IPSO_add_sensor() ][iowa_client_IPSO_add_sensor]. Improved OSCORE support for a better interoperability. SDK Changes [ iowa_client_device_update_battery() ][iowa_client_device_update_battery] can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_BATTERY_REMOVE . [ iowa_client_..._device_power_source() ][iowa_client_add_device_power_source] can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE . The file src/core/iowa_comms.c was removed. INVALID_SENSOR_ID is deprecated and renamed IOWA_INVALID_SENSOR_ID . Bug Fixes Fix a bug where an intermediate runtime state of a LwM2M Server was saved when calling [ iowa_save_context() ][iowa_save_context], preventing resuming. Fix a bug when creating multiple Magnetometer instances with different resources. Fix a bug when creating multiple Light Control instances with different resources. Fix a bug when reading an unknown Resource Instance. Fix a possible memory leak if iowa_coap_peer_new() failed. Fix a possible segmentation fault when an Object Resource value is a nil-string. Fix a bug when receiving a COAP block-transfer message and neither IOWA_COAP_BLOCK_MINIMAL_SUPPORT nor IOWA_COAP_BLOCK_SUPPORT are defined. Fix a bug when updating Magnetometer Object's compass direction. 2020-03.6 \u00b6 Bug Fixes Fix a bug where an intermediate runtime state of a LwM2M Server was saved when calling [ iowa_save_context() ][iowa_save_context], preventing resumption. 2020-03.5 \u00b6 Bug Fixes Fix a bug where switching the resource \"Notification Storing When Disabled or Offline\" to false would stop the Notification queue flushing. Fix a bug where Notifications of canceled Observations were not always removed from the queue in peek mode, blocking other notifications. Behavior Changes When receiving an Execute operation with arguments, the LwM2M Client will assume the arguments are encoded using text/plain when the CoAP option content-type is not present. 2020-03.4 \u00b6 Bug Fixes Fix a race condition issue where simultaneous registration update may generate a registration update failure event. 2020-03.3 \u00b6 Bug Fixes Fix a memory leak when receiving a block transfer. 2020-03.2 \u00b6 Bug Fixes Fix a potential issue with the size of the last block of a streamable resource. 2020-03.1 \u00b6 Bug Fixes Fix a potential deadlock in iowa_client_object_set_mode() when the sensor ID was unknown. Fix a possible wrong behaviour in the FSM of the registration when the Device is registered on the Server but not connected on the Security level. 2020-03 \u00b6 New Features For Client applications, add a new event when the epmin and epmax attributes are modified by the Server. See IOWA_EVENT_EVALUATION_PERIOD in [iowa_event_type_t][iowa_event_type_t]. Add new helper functions to convert an iowa_sensor_t to an iowa_lwm2m_uri_t and vice versa. See [ iowa_utils_uri_to_sensor() ][iowa_utils_uri_to_sensor]. Add a new event when the LwM2M Server requests a Read of a LwM2M Objects or custom LwM2M Objects resources which are defined as \"asynchronous\". See [ iowa_client_object_set_mode() ][iowa_client_object_set_mode] and IOWA_EVENT_READ in [iowa_event_type_t][iowa_event_type_t]. In custom LwM2M Objects, resources can be defined as streamable. See [Custom Object Streaming APIs][Custom Object Streaming APIs]. Add support of the \"Factory Reset\" resource of the Device Object. See[ iowa_client_factory_reset_callback_t ][iowa_client_factory_reset_callback_t]. Add a new CoAP API [ iowa_coap_block_request_block_number() ][iowa_coap_block_request_block_number] to ease resuming of Firmware Update download. Add new helper functions to retrieve the security session associated to a LwM2M Server or a LwM2M Client. See [ iowa_security_get_server_session() ][iowa_security_get_server_session]. Expose IOWA linked list functions. See [Example: Linked List usage][Example: Linked List usage]. Behavior Changes If the registration using LwM2M 1.1 fails, the Client tries to register using LwM2M 1.0. During the Bootstrap procedure, if the LwM2M Bootstrap Server did not provide the security credentials of a LwM2M Server, IOWA checks if credentials are known by the Application. See [iowa_security_operation_t][iowa_security_operation_t]. There is now one notifications storage queue per LwM2M Server instead of one per Observation. Unsent reliable notifications are no longer stored in memory. IOWA_LWM2M_ID_ALL can be used as parameter in [`iowa_client_set_notification_default_periods()][iowa_client_set_notification_default_periods]. [ iowa_client_remove_server() ][iowa_client_remove_server] called with IOWA_LWM2M_ID_ALL as parameter, also removes bootstrapped LwM2M Servers. Better handling of NaN and Infinity floating-point values in CBOR. SDK Changes IOWA has now internal checks done by using the assert() macro. Add a new flag to use the libc snprintf() when converting to text large floating-point values. See [IOWA_USE_SNPRINTF][IOWA_USE_SNPRINTF]. Rename the header file \"iowa_security_user.h\", \"iowa_security.h\". Clean up cross inclusion of header files. Deprecate several compilation flags. See [Deprecated Compilation Flags][Deprecated Compilation Flags]. Remove some functions deprecated in previous releases: iowa_client_add_lorawan_server() , iowa_server_dm_read() , iowa_server_dm_observe() , iowa_server_dm_observe_cancel() , iowa_server_dm_write() , iowa_server_dm_write_attributes() , and iowa_server_set_content_format() . Prototype of iowa_bearer_selection_update_state_callback_t , iowa_client_bearer_selection_update , iowa_client_cellular_connectivity_update , iowa_cellular_connectivity_update_state_callback_t and iowa_client_connectivity_monitoring_update have been updated to use a pointer to access to the structure. Bug Fixes Fix a bug where the Client was not always resending its new LwM2M Object if a previous Registration Update failed. Fix a bug where the Client was not always resetting its internal registration sequence counters, when registering to a LwM2M 1.1 Server. Improve the Client registration process resilience to network disconnections. Fix text and JSON encoding of very large float values. Fix the usage of the URI query in [ iowa_coap_peer_get() ][iowa_coap_peer_get]. Keep the previously declared LwM2M Bootstrap Server when failing to load a context snapshot containing a LwM2M Bootstrap Server. Fix pushing the firmware package with CoAP block which was rejected by the LwM2M Client. Fix an issue where modifying the Objects list or the lifetime during registration, or while disconnected, was not always triggering a Registration Update. Fix a possible derivation between the Registration timer and the Registration Update timer. 2019-12.1 \u00b6 Bug Fixes Allow the Context Storage feature to be built with Single Server mode. Use the correct defines to remove the resources UTC Offset and Timezone in the Device Object. Allow the ACL feature to be built with Single Server mode. Strengthen the checking of the loaded context version. Update the Power Source defines to reflect the version 1.1 of the Device Object. 2019-12 \u00b6 New Features Add the possibility to choose LwM2M protocol version to support. See [LwM2M Version][LwM2M Version]. LwM2M 1.1: The LwM2M operations Read, Write, Write-Attribute, and Observe can target Resource Instances. LwM2M 1.1: Add support of the epmin and epmax notification attributes. LwM2M 1.1: Add support of the Read-Composite, Write-Composite, and Observe-Composite operations. LwM2M 1.1: Add support of the LwM2M 1.1 Send operation. See the samples samples/client_1_1 and samples/server_1_1 . LwM2M 1.1: Add support of the new registration conditions. See [iowa_client_set_server_registration_behaviour][iowa_client_set_server_registration_behaviour]. LwM2M 1.1: Add support of the resource type Unsigned Integer. LwM2M 1.1: Add support of the Bootstrap Trigger resource. LwM2M 1.1: Add support of the Bootstrap Read operation. Add new CoAP APIs to ease downloading during Firmware Update. See [CoAP API Reference][CoAP API Reference] and the sample samples/fw_update_client . Add support of the Access Control List Object. See [Access Control List Object API][Access Control List Object API]. Add support of the Error Code resource in the Device Object. See [iowa_client_set_device_error_code][iowa_client_set_device_error_code]. Add new API for the application to provide data to be saved with the IOWA context. See [iowa_backup_register_callback][iowa_backup_register_callback]. The runtime information can be stored, allowing the Client to resume its operations seamlessly. See [Context Storage][Context Storage]. Behavior Changes Rework of the context storage feature: The format of the saved data has changed for a more flexible one. MSISDN can no longer be set on the Client side when SMS support is not enabled. SDK Changes The functions of the Security component are no longer exposed in the header file iowa_security.h . See [Security Component][Security Component]. Deprecated APIs: iowa_client_add_lorawan_server() and iowa_server_set_content_format . Advanced Features These features have not undergone full interoperability testings. LwM2M 1.1: Add support of OSCORE security. See [Security][Security]. 2019-08 \u00b6 New Features During Firmware Update Pushs, a time limit can be set for blocks reception. See the [\"Push\" method][\"Push\" method] section in [Device Update][Device Update]. New Client API to set the Bootstrap Hold Off Time. See [iowa_client_set_bootstrap_server_hold_off][iowa_client_set_bootstrap_server_hold_off]. New Server APIs to validate a Client registration ([iowa_server_set_verify_client_callback][iowa_server_set_verify_client_callback]) and to close a connection to a Client ([iowa_server_close_client_connection][iowa_server_close_client_connection]). Behavior Changes For LwM2M Clients, if [iowa_step][iowa_step] returns an error because no LwM2M Server can be reached, subsequent call to [iowa_step][iowa_step], will retry to register to the known LwM2M Servers, instead of staying in the failed state. Changes were made to the [Context storage][Context storage] feature making the saved contexts no longer compatible with the one of the previous version. The \"Binding\" resource of the [Device Object][Device Object] is now dependant on the compilation flags. SDK Changes Change the way provide a custom security implementation. See [Providing your security implementation][Providing your security implementation]. The [iowa_lwm2m_data_t][iowa_lwm2m_data_t] definition no longer depends on the [LWM2M_SUPPORT_TIMESTAMP][LWM2M_SUPPORT_TIMESTAMP] compilation flag. More compilation flags were added to reduce the code footprint of the LwM2M Client version. See [SDK Configuration][Configuration]. Add a new log part to filter logs generated by LwM2M Objects. See [IOWA_LOG_LEVEL and IOWA_LOG_PART][IOWA_LOG_LEVEL and IOWA_LOG_PART]. Update the provided MbedTLS to version 2.18.1. Samples are now usable on Windows. See [Samples Compilation][Samples Compilation]. Experimental Features These features have not undergone interoperability testings. They are provided for prototyping purpose only. Add the possibility to choose LwM2M version to support. The LwM2M operations Read, Write, Write-Attribute, and Observe can target Resource Instances. Add support of the epmin and epmax notification attributes. Add support of the LwM2M 1.1 operations Read-Composite, Write-Composite, and Observe-Composite. Add support of the LwM2M 1.1 Send operation. 2019-05 \u00b6 New Features Support of timestamped values in IPSO Objects and custom Objects. See [ iowa_client_IPSO_update_values ][iowa_client_IPSO_update_values] and [Custom Object][Monitoring the temperature during a period] section. Support of SenML JSON, SenML CBOR and CBOR data encodings. Support of the [Software Management Objects][Software Management] for FOTA. Support of the power source and timezone information in the LwM2M Device Object. See [ iowa_client_add_device_power_source ][iowa_client_add_device_power_source] and [ iowa_client_update_device_time_information ][iowa_client_update_device_time_information]. Support of CoAP Block-Wise transfer for the Device Update push method. See IOWA_COAP_BLOCK_SUPPORT and IOWA_COAP_BLOCK_MINIMAL_SUPPORT in [IOWA Configuration][IOWA Configuration]. Experimental support of the TCP transport. This feature has not undergone interoperability testings. Behavior Changes In the custom Objects [iowa_RWE_callback_t][iowa_RWE_callback_t], new operation IOWA_DM_FREE to allow the release of the memory potentially allocated when the callback was called with IOWA_DM_READ . In the security layer, the certificates are parsed in DER format. New APIs to manipulate the [APN Connection Profile Object][APN Connection Profile Object]. Previous ones are marked as deprecated but are still functionnal. The user application can implement its own log functions. See [Logger Component][Logger Component]. SDK Changes All iowa files had their name prepended with iowa_ to avoid filename collisions on some build systems. Numerous compilation flags were added to reduce the code footprint of the LwM2M Client version. See [SDK Configuration][Configuration]. Using the Firmware Update feature now requires the definition of the compilation flag IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT . See [Firmware Update Object][Firmware Update Object]. APIs related to iowa-supported LwM2M Objects were moved in their separate header and source files. The header files are located in the \"include/objects\" folder. [ iowa_lwm2m_data_type_t ][iowa_lwm2m_data_type_t] enumeration was converted to a list of defines. the const keyword was added to several APIs arguments. Remove client build dependency on files object_connectivity_stats.c and object_light_control.c The abstraction layer function iowa_system_connection_is_same_peer() is no longer required.","title":"Changelog"},{"location":"Changelog/#changelog","text":"","title":"Changelog"},{"location":"Changelog/#2020-091","text":"Behavior Changes When an Observation is set on asynchronous resources, the Client [event callback][iowa_event_callback_t] is called with an [IOWA_EVENT_READ][iowa_event_type_t] event. When using mbed TLS, the MTU is declared during the DTLS/TLS handshake. SDK Changes [ iowa_server_configuration_set() ][iowa_server_configuration_set] is deprecated and renamed [ iowa_client_set_server_configuration() ][iowa_client_set_server_configuration]. iowa_dimmer.h can now be imported without importing first iowa_ipso.h . Bug Fixes Fix a possible core dump when IOWA reconnects a disconnected CoAP peer. Fix a but where the Client was rejecting an Object Instance creation using TLV if the payload was not containing the new Object Instance ID. Fix a possible memory leak if the registration reply from the Server does not contain a location path. Avoid a compilation error when [IOWA_DEVICE_RSC_FACTORY_RESET_REMOVE][Device] is defined. When using mbed TLS, fix a bug preventing to send a payload larger than 16384 bytes over TLS.","title":"2020-09.1"},{"location":"Changelog/#2020-09","text":"New Features Add two APIs [ iowa_client_get_server_count() ][iowa_client_get_server_count] and [ iowa_client_get_server_array() ][iowa_client_get_server_array] to retrieve the bootstrapped and declared LwM2M Servers. Add an API [ iowa_server_configuration_set() ][iowa_server_configuration_set] to update the lifetime and the queue mode of a LwM2M Server. Add an API [ iowa_client_update_device_information() ][iowa_client_update_device_information] to update the device information at runtime. Add a new API [ iowa_clock_reset() ][iowa_clock_reset] to inform IOWA of clock issues. The API [ iowa_client_set_device_error_code() ][iowa_client_set_device_error_code] now allow user-defined error codes. Behavior Changes For LwM2M Server applications, IOWA now takes care of the reassembly of CoAP block transfers. Events IOWA_EVENT_OBSERVATION_STARTED and IOWA_EVENT_OBSERVATION_CANCELED are now emitted after having updated the internal IOWA context. CoAP block-wise transfers use the negotiated block size during all the block-wise transfer. In the AT Command Object, the strings passed to [ iowa_client_at_command_set_response() ][iowa_client_at_command_set_response] are appended to the existing ones instead of replacing them. In CoAP messages, URI-Path option is not included when URI is \"/\". In the LwM2M layer, MAX_TRANSMIT_WAIT has a duration of 20 seconds for TCP peers and 120 seconds for LoRaWAN peers. The return value of [ iowa_system_security_data() ][iowa_system_security_data] is no longer checked when IOWA calls it for an IOWA_SEC_FREE operation. Add multiple parameters checks in Objects APIs. In [ iowa_client_light_control_set_state() ][iowa_client_light_control_set_state], [ iowa_system_gettime() ][iowa_system_gettime] is called only if the resource \"On Time\" is enabled. The LwM2M Client now ignores unexpected CoAP responses. SDK Changes Remove Dimmer object from IPSO objects and add its own API. All [ iowa_apn_connection_profile_details_t ][iowa_apn_connection_profile_details_t] integer members are now unsigned. [ iowa_device_time_info_t::currentTime ][iowa_device_time_info_t] was changed from uint32_t to int32_t . Included mbed TLS was updated to version 2.24.0. Bug Fixes Fix a bug when calling [ iowa_flush_before_pause() ][iowa_flush_before_pause] on TCP connections. Fix a possible deadlock when calling [ iowa_system_random_vector_generator() ][iowa_system_random_vector_generator]. Fix a possible core dump when reading a Resource Instance containing a nil value. Fix a buffer overflow in serialization of integer CoAP option with a number greater than 269. Fix a bug when parsing large RFC8323 COAP headers. For Bootstrap Server applications, fix a bug where the unexpected disconnection of a TCP Client may lead to an invalid read. Fix a potential invalid read if the Client fails to send its registration message. Fix a possible bug when generating a new token. Fix several bugs when the Client uses CoAP block transfers for the registration message. For LwM2M Server applications, fix a potential stack corruption when the connection type is one of UDP, SMS, or LoRaWAN, and when iowa_system_random_vector_generator() fails. Fix a possible memory leak when creating a new CoAP peer. Fix a possible bug when generating a new token. In several Objects, fix a potential invalid read when string Resources under Observation are modified repeatedly. In the Location and GPS Objects, fix a potential segmentation fault when allocating memory for a string value fails. Fix a possible memory leak when deleting an APN Object Instance. Fix a potential invalid free when calling [ iowa_client_send_sensor_data() ][iowa_client_send_sensor_data]. Fix a Bootstrap-Delete bug when ACL are enabled.","title":"2020-09"},{"location":"Changelog/#2020-062","text":"Bug Fixes Fix an interoperability bug in SenML JSON related to base64 encoding of opaque values. Fix a potential invalid read when deleting an ACL Object instance. Fix a potential memory leak when creating a new CoAP peer fails. Correct several conversion compiler warnings. Fix an offset error when parsing long CoAP over TCP headers. Fix interoperability issue with CoAP FETCH method when using Block-Transfer. Fix a possible memory leak when deleting an APN Object Instance.","title":"2020-06.2"},{"location":"Changelog/#2020-061","text":"Behavior Changes For RFC7252 CoAP connections, e.g. LwM2M over UDP, the initial message ID is now random (using [ iowa_system_random_vector_generator() ][iowa_system_random_vector_generator]). The LwM2M Registration will now fail if the transmission was successful but no response was received after a delay set to EXCHANGE_LIFETIME from RFC7252. Bug Fixes Fix a bug when the Current Time resource was read asynchronously.","title":"2020-06.1"},{"location":"Changelog/#2020-06","text":"New Features Add support of the MQTT Broker Object (ID: 18330) and of the MQTT Publication Object (ID: 18831). See [MQTT Object API][MQTT Object API]. The CoAP retransmission parameters can be modified at runtime. See [ iowa_coap_peer_configuration_set() ][iowa_coap_peer_configuration_set] and [ iowa_coap_peer_configuration_get() ][iowa_coap_peer_configuration_get]. New APIs to retrieve the CoAP peer associated to a LwM2M Server to ease usage of the previous APIs. See [ iowa_client_get_server_coap_peer() ][iowa_client_get_server_coap_peer] and [ iowa_client_get_bootstrap_server_coap_peer() ][iowa_client_get_bootstrap_server_coap_peer]. Support of the \"Reset Error Code\" Resource of the [Device Object][Device Object]. For Client applications, add a new event when an notification for an Observation was generated and is about to be sent. See IOWA_EVENT_OBSERVATION_NOTIFICATION in [iowa_event_type_t][iowa_event_type_t]. For Client applications, the events related to Observations now include the ID of the specific resource under observation if any. Introduce a new special value IOWA_DEVICE_TIME_SENSOR_ID of an [ iowa_sensor_t ][iowa_sensor_t] to refer to the Current Time of the Device. Behavior Changes The API [ iowa_client_notification_lock() ][iowa_client_notification_lock] now also prevents registration updates. The IOWA_EVENT_BS_PENDING event is emitted when connecting to the LwM2M Bootstrap Server instead of after receiving the reply to the Bootstrap-Request operation. The IOWA_EVENT_REG_REGISTERING event is emitted when connecting to the LwM2M Server instead of after sending the Registration message. Returned error codes for Object related APIs are more consistent. Stricter checks of the parameters passed to [ iowa_client_IPSO_add_sensor() ][iowa_client_IPSO_add_sensor]. Improved OSCORE support for a better interoperability. SDK Changes [ iowa_client_device_update_battery() ][iowa_client_device_update_battery] can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_BATTERY_REMOVE . [ iowa_client_..._device_power_source() ][iowa_client_add_device_power_source] can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE . The file src/core/iowa_comms.c was removed. INVALID_SENSOR_ID is deprecated and renamed IOWA_INVALID_SENSOR_ID . Bug Fixes Fix a bug where an intermediate runtime state of a LwM2M Server was saved when calling [ iowa_save_context() ][iowa_save_context], preventing resuming. Fix a bug when creating multiple Magnetometer instances with different resources. Fix a bug when creating multiple Light Control instances with different resources. Fix a bug when reading an unknown Resource Instance. Fix a possible memory leak if iowa_coap_peer_new() failed. Fix a possible segmentation fault when an Object Resource value is a nil-string. Fix a bug when receiving a COAP block-transfer message and neither IOWA_COAP_BLOCK_MINIMAL_SUPPORT nor IOWA_COAP_BLOCK_SUPPORT are defined. Fix a bug when updating Magnetometer Object's compass direction.","title":"2020-06"},{"location":"Changelog/#2020-036","text":"Bug Fixes Fix a bug where an intermediate runtime state of a LwM2M Server was saved when calling [ iowa_save_context() ][iowa_save_context], preventing resumption.","title":"2020-03.6"},{"location":"Changelog/#2020-035","text":"Bug Fixes Fix a bug where switching the resource \"Notification Storing When Disabled or Offline\" to false would stop the Notification queue flushing. Fix a bug where Notifications of canceled Observations were not always removed from the queue in peek mode, blocking other notifications. Behavior Changes When receiving an Execute operation with arguments, the LwM2M Client will assume the arguments are encoded using text/plain when the CoAP option content-type is not present.","title":"2020-03.5"},{"location":"Changelog/#2020-034","text":"Bug Fixes Fix a race condition issue where simultaneous registration update may generate a registration update failure event.","title":"2020-03.4"},{"location":"Changelog/#2020-033","text":"Bug Fixes Fix a memory leak when receiving a block transfer.","title":"2020-03.3"},{"location":"Changelog/#2020-032","text":"Bug Fixes Fix a potential issue with the size of the last block of a streamable resource.","title":"2020-03.2"},{"location":"Changelog/#2020-031","text":"Bug Fixes Fix a potential deadlock in iowa_client_object_set_mode() when the sensor ID was unknown. Fix a possible wrong behaviour in the FSM of the registration when the Device is registered on the Server but not connected on the Security level.","title":"2020-03.1"},{"location":"Changelog/#2020-03","text":"New Features For Client applications, add a new event when the epmin and epmax attributes are modified by the Server. See IOWA_EVENT_EVALUATION_PERIOD in [iowa_event_type_t][iowa_event_type_t]. Add new helper functions to convert an iowa_sensor_t to an iowa_lwm2m_uri_t and vice versa. See [ iowa_utils_uri_to_sensor() ][iowa_utils_uri_to_sensor]. Add a new event when the LwM2M Server requests a Read of a LwM2M Objects or custom LwM2M Objects resources which are defined as \"asynchronous\". See [ iowa_client_object_set_mode() ][iowa_client_object_set_mode] and IOWA_EVENT_READ in [iowa_event_type_t][iowa_event_type_t]. In custom LwM2M Objects, resources can be defined as streamable. See [Custom Object Streaming APIs][Custom Object Streaming APIs]. Add support of the \"Factory Reset\" resource of the Device Object. See[ iowa_client_factory_reset_callback_t ][iowa_client_factory_reset_callback_t]. Add a new CoAP API [ iowa_coap_block_request_block_number() ][iowa_coap_block_request_block_number] to ease resuming of Firmware Update download. Add new helper functions to retrieve the security session associated to a LwM2M Server or a LwM2M Client. See [ iowa_security_get_server_session() ][iowa_security_get_server_session]. Expose IOWA linked list functions. See [Example: Linked List usage][Example: Linked List usage]. Behavior Changes If the registration using LwM2M 1.1 fails, the Client tries to register using LwM2M 1.0. During the Bootstrap procedure, if the LwM2M Bootstrap Server did not provide the security credentials of a LwM2M Server, IOWA checks if credentials are known by the Application. See [iowa_security_operation_t][iowa_security_operation_t]. There is now one notifications storage queue per LwM2M Server instead of one per Observation. Unsent reliable notifications are no longer stored in memory. IOWA_LWM2M_ID_ALL can be used as parameter in [`iowa_client_set_notification_default_periods()][iowa_client_set_notification_default_periods]. [ iowa_client_remove_server() ][iowa_client_remove_server] called with IOWA_LWM2M_ID_ALL as parameter, also removes bootstrapped LwM2M Servers. Better handling of NaN and Infinity floating-point values in CBOR. SDK Changes IOWA has now internal checks done by using the assert() macro. Add a new flag to use the libc snprintf() when converting to text large floating-point values. See [IOWA_USE_SNPRINTF][IOWA_USE_SNPRINTF]. Rename the header file \"iowa_security_user.h\", \"iowa_security.h\". Clean up cross inclusion of header files. Deprecate several compilation flags. See [Deprecated Compilation Flags][Deprecated Compilation Flags]. Remove some functions deprecated in previous releases: iowa_client_add_lorawan_server() , iowa_server_dm_read() , iowa_server_dm_observe() , iowa_server_dm_observe_cancel() , iowa_server_dm_write() , iowa_server_dm_write_attributes() , and iowa_server_set_content_format() . Prototype of iowa_bearer_selection_update_state_callback_t , iowa_client_bearer_selection_update , iowa_client_cellular_connectivity_update , iowa_cellular_connectivity_update_state_callback_t and iowa_client_connectivity_monitoring_update have been updated to use a pointer to access to the structure. Bug Fixes Fix a bug where the Client was not always resending its new LwM2M Object if a previous Registration Update failed. Fix a bug where the Client was not always resetting its internal registration sequence counters, when registering to a LwM2M 1.1 Server. Improve the Client registration process resilience to network disconnections. Fix text and JSON encoding of very large float values. Fix the usage of the URI query in [ iowa_coap_peer_get() ][iowa_coap_peer_get]. Keep the previously declared LwM2M Bootstrap Server when failing to load a context snapshot containing a LwM2M Bootstrap Server. Fix pushing the firmware package with CoAP block which was rejected by the LwM2M Client. Fix an issue where modifying the Objects list or the lifetime during registration, or while disconnected, was not always triggering a Registration Update. Fix a possible derivation between the Registration timer and the Registration Update timer.","title":"2020-03"},{"location":"Changelog/#2019-121","text":"Bug Fixes Allow the Context Storage feature to be built with Single Server mode. Use the correct defines to remove the resources UTC Offset and Timezone in the Device Object. Allow the ACL feature to be built with Single Server mode. Strengthen the checking of the loaded context version. Update the Power Source defines to reflect the version 1.1 of the Device Object.","title":"2019-12.1"},{"location":"Changelog/#2019-12","text":"New Features Add the possibility to choose LwM2M protocol version to support. See [LwM2M Version][LwM2M Version]. LwM2M 1.1: The LwM2M operations Read, Write, Write-Attribute, and Observe can target Resource Instances. LwM2M 1.1: Add support of the epmin and epmax notification attributes. LwM2M 1.1: Add support of the Read-Composite, Write-Composite, and Observe-Composite operations. LwM2M 1.1: Add support of the LwM2M 1.1 Send operation. See the samples samples/client_1_1 and samples/server_1_1 . LwM2M 1.1: Add support of the new registration conditions. See [iowa_client_set_server_registration_behaviour][iowa_client_set_server_registration_behaviour]. LwM2M 1.1: Add support of the resource type Unsigned Integer. LwM2M 1.1: Add support of the Bootstrap Trigger resource. LwM2M 1.1: Add support of the Bootstrap Read operation. Add new CoAP APIs to ease downloading during Firmware Update. See [CoAP API Reference][CoAP API Reference] and the sample samples/fw_update_client . Add support of the Access Control List Object. See [Access Control List Object API][Access Control List Object API]. Add support of the Error Code resource in the Device Object. See [iowa_client_set_device_error_code][iowa_client_set_device_error_code]. Add new API for the application to provide data to be saved with the IOWA context. See [iowa_backup_register_callback][iowa_backup_register_callback]. The runtime information can be stored, allowing the Client to resume its operations seamlessly. See [Context Storage][Context Storage]. Behavior Changes Rework of the context storage feature: The format of the saved data has changed for a more flexible one. MSISDN can no longer be set on the Client side when SMS support is not enabled. SDK Changes The functions of the Security component are no longer exposed in the header file iowa_security.h . See [Security Component][Security Component]. Deprecated APIs: iowa_client_add_lorawan_server() and iowa_server_set_content_format . Advanced Features These features have not undergone full interoperability testings. LwM2M 1.1: Add support of OSCORE security. See [Security][Security].","title":"2019-12"},{"location":"Changelog/#2019-08","text":"New Features During Firmware Update Pushs, a time limit can be set for blocks reception. See the [\"Push\" method][\"Push\" method] section in [Device Update][Device Update]. New Client API to set the Bootstrap Hold Off Time. See [iowa_client_set_bootstrap_server_hold_off][iowa_client_set_bootstrap_server_hold_off]. New Server APIs to validate a Client registration ([iowa_server_set_verify_client_callback][iowa_server_set_verify_client_callback]) and to close a connection to a Client ([iowa_server_close_client_connection][iowa_server_close_client_connection]). Behavior Changes For LwM2M Clients, if [iowa_step][iowa_step] returns an error because no LwM2M Server can be reached, subsequent call to [iowa_step][iowa_step], will retry to register to the known LwM2M Servers, instead of staying in the failed state. Changes were made to the [Context storage][Context storage] feature making the saved contexts no longer compatible with the one of the previous version. The \"Binding\" resource of the [Device Object][Device Object] is now dependant on the compilation flags. SDK Changes Change the way provide a custom security implementation. See [Providing your security implementation][Providing your security implementation]. The [iowa_lwm2m_data_t][iowa_lwm2m_data_t] definition no longer depends on the [LWM2M_SUPPORT_TIMESTAMP][LWM2M_SUPPORT_TIMESTAMP] compilation flag. More compilation flags were added to reduce the code footprint of the LwM2M Client version. See [SDK Configuration][Configuration]. Add a new log part to filter logs generated by LwM2M Objects. See [IOWA_LOG_LEVEL and IOWA_LOG_PART][IOWA_LOG_LEVEL and IOWA_LOG_PART]. Update the provided MbedTLS to version 2.18.1. Samples are now usable on Windows. See [Samples Compilation][Samples Compilation]. Experimental Features These features have not undergone interoperability testings. They are provided for prototyping purpose only. Add the possibility to choose LwM2M version to support. The LwM2M operations Read, Write, Write-Attribute, and Observe can target Resource Instances. Add support of the epmin and epmax notification attributes. Add support of the LwM2M 1.1 operations Read-Composite, Write-Composite, and Observe-Composite. Add support of the LwM2M 1.1 Send operation.","title":"2019-08"},{"location":"Changelog/#2019-05","text":"New Features Support of timestamped values in IPSO Objects and custom Objects. See [ iowa_client_IPSO_update_values ][iowa_client_IPSO_update_values] and [Custom Object][Monitoring the temperature during a period] section. Support of SenML JSON, SenML CBOR and CBOR data encodings. Support of the [Software Management Objects][Software Management] for FOTA. Support of the power source and timezone information in the LwM2M Device Object. See [ iowa_client_add_device_power_source ][iowa_client_add_device_power_source] and [ iowa_client_update_device_time_information ][iowa_client_update_device_time_information]. Support of CoAP Block-Wise transfer for the Device Update push method. See IOWA_COAP_BLOCK_SUPPORT and IOWA_COAP_BLOCK_MINIMAL_SUPPORT in [IOWA Configuration][IOWA Configuration]. Experimental support of the TCP transport. This feature has not undergone interoperability testings. Behavior Changes In the custom Objects [iowa_RWE_callback_t][iowa_RWE_callback_t], new operation IOWA_DM_FREE to allow the release of the memory potentially allocated when the callback was called with IOWA_DM_READ . In the security layer, the certificates are parsed in DER format. New APIs to manipulate the [APN Connection Profile Object][APN Connection Profile Object]. Previous ones are marked as deprecated but are still functionnal. The user application can implement its own log functions. See [Logger Component][Logger Component]. SDK Changes All iowa files had their name prepended with iowa_ to avoid filename collisions on some build systems. Numerous compilation flags were added to reduce the code footprint of the LwM2M Client version. See [SDK Configuration][Configuration]. Using the Firmware Update feature now requires the definition of the compilation flag IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT . See [Firmware Update Object][Firmware Update Object]. APIs related to iowa-supported LwM2M Objects were moved in their separate header and source files. The header files are located in the \"include/objects\" folder. [ iowa_lwm2m_data_type_t ][iowa_lwm2m_data_type_t] enumeration was converted to a list of defines. the const keyword was added to several APIs arguments. Remove client build dependency on files object_connectivity_stats.c and object_light_control.c The abstraction layer function iowa_system_connection_is_same_peer() is no longer required.","title":"2019-05"},{"location":"ClientAPI/","text":"Client Mode API Reference \u00b6 The functions explained below are defined inside the file include/iowa_client.h and the Objects folder include/objects . Client pseudo code \u00b6 #include \"iowa_client.h\" #include \"iowa_ipso.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; iowa_device_info_t devInfo ; iowa_sensor_t sensorId ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); devInfo . manufacturer = \"IOTEROP\" ; devInfo . deviceType = \"Example device\" ; devInfo . modelNumber = \"1\" ; devInfo . serialNumber = NULL ; devInfo . hardwareVersion = NULL ; devInfo . softwareVersion = NULL ; devInfo . optFlags = 0 ; result = iowa_client_configure ( iowaH , \"IOWA_Sample_Client\" , devInfo , NULL ); result = iowa_client_IPSO_add_sensor ( iowaH , IOWA_IPSO_VOLTAGE , 12.0 , \"V\" , \"Test DC\" , 0.0 , 0.0 , & sensorId ); result = iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ while ( result == IOWA_COAP_NO_ERROR ) { float sensorValue ; result = iowa_step ( iowaH , 5 ); sensorValue = read_battery_voltage (); result = iowa_client_IPSO_update_value ( iowaH , sensorId , sensorValue ); } iowa_client_IPSO_remove_sensor ( iowaH , sensorId ); iowa_close ( iowaH ); return 0 ; } \\clearpage Data types \u00b6 iowa_server_setting_id_t \u00b6 typedef uint8_t iowa_server_setting_id_t ; Possible Values \u00b6 IOWA_SERVER_SETTING_QUEUE_MODE : A flag to set the queue mode of a server. IOWA_SERVER_SETTING_LIFETIME : A flag to set the lifetime of a server. iowa_lwm2m_binding_t \u00b6 typedef uint8_t iowa_lwm2m_binding_t ; IOWA_LWM2M_BINDING_UNKNOWN : The flag to define Unknown binding. IOWA_LWM2M_BINDING_UDP : The flag to define UDP binding. IOWA_LWM2M_BINDING_TCP : The flag to define TCP binding. IOWA_LWM2M_BINDING_SMS : The flag to define SMS binding. IOWA_LWM2M_BINDING_NON_IP : The flag to define Non-IP binding. iowa_server_info_t \u00b6 typedef struct { uint16_t shortId ; const char * uriP ; int32_t lifetime ; iowa_lwm2m_binding_t binding ; bool queueMode ; } iowa_server_info_t ; The iowa_server_info_t structure is used to get the shortID and the parameters of the configured servers. shortId : the Short ID assigned to the server. uriP : The uri to connect with the server. lifetime : The lifetime in seconds of the registration to the server. binding : The binding used to connect to the server. queueMode : The state of the Queue mode of the server. iowa_device_info_t \u00b6 typedef struct { const char * manufacturer ; const char * deviceType ; const char * modelNumber ; const char * serialNumber ; const char * hardwareVersion ; const char * firmwareVersion ; const char * softwareVersion ; const char * msisdn ; uint16_t optFlags ; const char * utcOffsetP ; const char * timezoneP ; iowa_client_time_update_callback_t dataTimeUpdateCallback ; iowa_client_factory_reset_callback_t factoryResetCallback ; void * callbackUserDataP ; } iowa_device_info_t ; The iowa_device_info_t structure exists only for the sake of the readability of iowa_client_configure() . It contains pointers to nil-terminated strings described below. As all these information are optional in a LwM2M Client, these pointers can be nil. The LwM2M standard does not mandate any format for these strings. They are manufacturer specific. manufacturer : A human readable manufacturer name. deviceType : The type of the device. modelNumber : The number of the model. serialNumber : The serial number of the device. hardwareVersion : The current version of the device hardware. firmwareVersion : The current version of the device firmware. softwareVersion : The current version of the device software. msisdn : The phone number of the device. optFlags : Flags used to enable optional features. This value is a combination of: IOWA_DEVICE_RSC_BATTERY : enables the battery level and status exposed in the [ Device Object ][Device Object]. To update battery level you need to call iowa_client_device_update_battery() . IOWA_DEVICE_RSC_POWER_SOURCE : enables the power sources information in the [ Device Object ][Device Object]. To add any new power source you need to call iowa_client_add_device_power_source() . IOWA_DEVICE_RSC_CURRENT_TIME : enables the use of current time in the [ Device Object ][Device Object] (default value: 0). IOWA_DEVICE_RSC_UTC_OFFSET : enables the use of UTC offset in the [ Device Object ][Device Object] (default value: utcOffsetP). IOWA_DEVICE_RSC_TIMEZONE : enables the use of timezone in the [ Device Object ][Device Object] (default value: 0). utcOffsetP : Indicates the UTC offset currently in effect for this LwM2M Device. It should be in the ISO 8601 format (UTC+X). timezoneP : Indicates in which time zone the LwM2M Device is located, in IANA Timezone (TZ) database format. dataTimeUpdateCallback : The callback called when the time information is updated by the LwM2M Server. factoryResetCallback : The callback called on a Factory Reset. callbackUserDataP : Passed as argument to the callbacks dataTimeUpdateCallback and factoryResetCallback . Notes To update time information (current time, UTC offset, timezone) you need to call iowa_client_update_device_time_information() To update device related information (manufacturer, model number, serial number, firmware version, device type, hardware version, software version.) you need to call iowa_client_update_device_information() . iowa_event_type_t \u00b6 typedef enum { IOWA_EVENT_UNDEFINED = 0 , IOWA_EVENT_REG_UNREGISTERED , IOWA_EVENT_REG_REGISTERING , IOWA_EVENT_REG_REGISTERED , IOWA_EVENT_REG_UPDATING , IOWA_EVENT_REG_FAILED , IOWA_EVENT_REG_UPDATE_FAILED , IOWA_EVENT_BS_PENDING , IOWA_EVENT_BS_FINISHED , IOWA_EVENT_BS_FAILED , IOWA_EVENT_OBSERVATION_STARTED , IOWA_EVENT_OBSERVATION_NOTIFICATION , IOWA_EVENT_OBSERVATION_CANCELED , IOWA_EVENT_OBJECT_INSTANCE_CREATED , IOWA_EVENT_OBJECT_INSTANCE_DELETED , IOWA_EVENT_EVALUATION_PERIOD , IOWA_EVENT_READ } iowa_event_type_t ; The iowa_event_type_t contains the possible events that can be reported by the IOWA stack. iowa_event_t \u00b6 typedef struct { iowa_event_type_t eventType ; uint16_t serverShortId ; union { struct { uint32_t lifetime ; } registration ; struct { iowa_sensor_t sensorId ; uint16_t resourceId ; uint32_t minPeriod ; uint32_t maxPeriod ; uint32_t minEvalPeriod ; uint32_t maxEvalPeriod ; } observation ; struct { iowa_lwm2m_uri_t * uriP ; } objectInstance ; struct { iowa_lwm2m_uri_t * uriP ; uint32_t minEvalPeriod ; uint32_t maxEvalPeriod ; } evalPeriod ; struct { iowa_sensor_t sensorId ; } sensor ; } details ; } iowa_event_t ; eventType : the event type. serverShortId : the short server ID of the LwM2M Server generating this event. details : the details of the event. details::registration : filled when the event is of type IOWA_EVENT_REG_UNREGISTERED , IOWA_EVENT_REG_REGISTERING , IOWA_EVENT_REG_REGISTERED , IOWA_EVENT_REG_UPDATING , IOWA_EVENT_REG_FAILED or IOWA_EVENT_REG_UPDATE_FAILED . details::registration::lifetime : the lifetime of the registration to the LwM2M Server generating this event. details::observation : filled when the event is of type IOWA_EVENT_OBSERVATION_STARTED , IOWA_EVENT_OBSERVATION_NOTIFICATION , or IOWA_EVENT_OBSERVATION_CANCELED details::observation::sensorId : the ID of the sensor under observation. details::observation::resourceId : the ID of the specific resource under observation of the sensor. This may be IOWA_LWM2M_ID_ALL . details::observation::minPeriod : the minimum time in seconds to wait between notifications for the observation. If not set the minPeriod is to 0. details::observation::maxPeriod : the maximum time in seconds to wait between notifications for the observation. If not set the maxPeriod is to UINT32_MAX. details::observation::minEvalPeriod : the minimum sample time in seconds for the observed sensor in LwM2M 1.1 or later. If not set the minEvalPeriod is to 0. details::observation::maxEvalPeriod : the maximum sample time in seconds for the observed sensor in LwM2M 1.1 or later. If not set the maxEvalPeriod is to UINT32_MAX. details::instance : filled when the event is of type IOWA_EVENT_OBJECT_INSTANCE_CREATED or IOWA_EVENT_OBJECT_INSTANCE_DELETED . details::instance::uri : a pointer to the iowa_lwm2m_uri_t of the instance that has been created or deleted. details::evalPeriod : filled when the event is of type IOWA_EVENT_EVALUATION_PERIOD . Available when the flag IOWA_LWM2M_VERSION_1_1 is set. details::evalPeriod::uriP : a pointer to the iowa_lwm2m_uri_t of the uri where evaluation period has been set. details::evalPeriod::minEvalPeriod : the minimum sample time in seconds for the concerned uri. If the LwM2M Server unsets it or does not set it, the value is 0. details::evalPeriod::maxEvalPeriod : the maximum sample time in seconds for the concerned uri. If the LwM2M Server unsets it or does not set it, the value is UINT32_MAX. details::sensor : filled when the event is of type IOWA_EVENT_READ . details::sensor::sensorId : the ID of the sensor targeted by a Read operation from the LwM2M Server. The iowa_event_t is used by iowa_event_callback_t when an event occurred on a client. These events are described by iowa_event_type_t . The IOWA stack handles the minimum and maximum observation periods. They are provided in iowa_event_t as an information for the application. Embedded devices may use this information to tune their measurement or sleeping schedule. The IOWA stack does not handle the minimum and maximum evaluation observation periods. They are provided in iowa_event_t as sample times for the application. Embedded devices may use those sample times to tune their measurement or sleeping schedule. iowa_device_time_info_t \u00b6 typedef struct { uint16_t flags ; int32_t currentTime ; const char * utcOffsetP ; const char * timezoneP ; } iowa_device_time_info_t ; flags : Flags used to enable optional time information. This value is a combination of: IOWA_DEVICE_RSC_CURRENT_TIME : current time has a new current time value from server IOWA_DEVICE_RSC_UTC_OFFSET : current time has a new UTC offset value from server IOWA_DEVICE_RSC_TIMEZONE : current time has a new timezone value from server currentTime : Current UNIX time of the LwM2M Client in seconds. utcOffsetP : Indicates the UTC offset currently in effect for this LwM2M Device. It should be in the ISO 8601 format (UTC+X). Could be nil, if not UTC offset is enable. timezoneP : Indicates in which time zone the LwM2M Device is located, in IANA Timezone (TZ) database format. Could be nil, if not Timezone is enable. iowa_ipso_timed_value_t \u00b6 typedef struct { float value ; int32_t timestamp ; } iowa_ipso_timed_value_t ; value : The timestamped value. timestamp : The timestamp associated to the value in seconds. This can not be negative. iowa_sensor_t \u00b6 This must be treated as an opaque type. It is internally mapped to a 32-bit unsigned integer. Special Values \u00b6 IOWA_INVALID_SENSOR_ID : Used to indicate an error by APIs returning an iowa_sensor_t . IOWA_DEVICE_TIME_SENSOR_ID : The sensor ID of the Current Time of the device. This is internally mapped to the resource 13 in the [Device Object][Device Object]. iowa_lwm2m_resource_desc_t \u00b6 This structure contains the description of a LwM2M resource. typedef struct { uint16_t id ; iowa_lwm2m_data_type_t type ; uint8_t operations ; uint8_t flags ; } iowa_lwm2m_resource_desc_t ; id : ID of the resource. type : The datatype of the resource. operations : The operations allowed on the resource. : This is a mask of values IOWA_OPERATION_READ , IOWA_OPERATION_WRITE and IOWA_OPERATION_EXECUTE . flags : The flags of the resource. : This is a mask of values IOWA_RESOURCE_FLAG_NONE , IOWA_RESOURCE_FLAG_OPTIONAL , IOWA_RESOURCE_FLAG_MANDATORY , IOWA_RESOURCE_FLAG_MULTIPLE , and IOWA_RESOURCE_FLAG_ASYNCHRONOUS . iowa_sensor_uri_t \u00b6 This structure describes a sensor URI. typedef struct { iowa_sensor_t id ; uint16_t resourceId ; } iowa_sensor_uri_t ; id : ID of the object. resourceId : The ID of the resource. This can be IOWA_LWM2M_ID_ALL . \\clearpage Callbacks \u00b6 iowa_event_callback_t \u00b6 This is the event callback, called when an event such as registration update or unregister occurred. typedef void ( * iowa_event_callback_t ) ( iowa_event_t * eventP , void * userData , iowa_context_t contextP ); eventP : The event stored in a structure. userData : A pointer to application specific data. This is a parameter of iowa_init() . contextP : The IOWA context on which iowa_client_configure() was called. iowa_client_time_update_callback_t \u00b6 This callback is called when time information are updated by server. typedef void ( * iowa_client_time_update_callback_t ) ( iowa_device_time_info_t * timeInfoP , void * userDataP , iowa_context_t contextP ); timeInfoP : Current device time information. userDataP : A pointer to application specific data. This is the parameter of iowa_client_configure() . contextP : The IOWA context on which iowa_client_configure() was called. iowa_client_factory_reset_callback_t \u00b6 This callback is called when a factory reset is requested. typedef void ( * iowa_client_factory_reset_callback_t ) ( void * userDataP , iowa_context_t contextP ); userDataP : A pointer to application specific data. This is the parameter of iowa_client_configure() . contextP : The IOWA context on which iowa_client_configure() was called. iowa_RWE_callback_t \u00b6 This callback is called when a Read, Write or Execute operation is performed on a resource of a custom LwM2M Object. typedef iowa_status_t ( * iowa_RWE_callback_t ) ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t contextP ); operation : The operation to perform on the resource among IOWA_DM_READ , IOWA_DM_WRITE and IOWA_DM_EXECUTE . dataP : An array of the URIs of the targeted resources. : For a Write operation, it also contains the value to write. : For a Read operation, the result is to be stored in this. numData : Number of resources in dataP. userData : A pointer to application specific data. This is the parameter of iowa_client_add_custom_object() . contextP : The IOWA context on which iowa_client_add_custom_object() was called. Notes \u00b6 Before calling this callback, the IOWA stack performs checks on the resource existence and its allowed operations. In case of a Write operation, the data type is also checked for conformance. The LwM2M Execute operation may have parameters. If so, they are provided as a string in dataP . After IOWA_DM_READ operation, the callback is called with IOWA_DM_FREE operation to permit the deallocation of memory that may have been allocated by the callback previously. iowa_CD_callback_t \u00b6 This callback is called when a Create or Delete operation is performed on an instance of a custom LwM2M Object. typedef iowa_status_t ( * iowa_CD_callback_t ) ( iowa_dm_operation_t operation , uint16_t objectID , uint16_t instanceID , void * userData , iowa_context_t contextP ); operation : The operation to perform on the resource among IOWA_DM_CREATE and IOWA_DM_DELETE . objectID : The ID of the targeted Object. instanceID : The ID of the targeted instance. userData : A pointer to application specific data. This is the parameter of iowa_client_add_custom_object() . contextP : The IOWA context on which iowa_client_add_custom_object() was called. iowa_RI_callback_t \u00b6 This callback is called to retrieve the list of current resource instance IDs for a multiple resource. typedef iowa_status_t ( * iowa_RI_callback_t ) ( uint16_t objectID , uint16_t instanceID , uint16_t resourceID , uint16_t * nbResInstanceP , uint16_t ** resInstanceArrayP , void * userData , iowa_context_t contextP ); objectID : The ID of the Object the resource belongs to. instanceID : The ID of the Object Instance the resource belongs to. resourceID : The ID of the targeted resource. nbResInstanceP : Used to store the number of elements in resInstanceArrayP. resInstanceArrayP : Used to store an array containing the resource instances IDs. This array will be freed by the caller by calling iowa_system_free() . userData : A pointer to application specific data. This is the parameter of iowa_client_add_custom_object() . contextP : The IOWA context on which iowa_client_add_custom_object() was called. \\clearpage API \u00b6 iowa_client_configure \u00b6 Prototype iowa_status_t iowa_client_configure ( iowa_context_t contextP , const char * identity , iowa_device_info_t * infoP , iowa_event_callback_t eventCb ); Description iowa_client_configure() sets the information of the LwM2M Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. identity : The unique identity of the LwM2M Client as a nil-terminated string. infoP : The optional information of the LwM2M Client. This can be nil. eventCb : The callback called when an event occurred. This can be nil. Return Value IOWA_COAP_NO_ERROR : success. COAP_400_BAD_REQUEST : either: : - identity is nil or empty and LWM2M_VERSION_1_1_SUPPORT is not set. : - the maximum length of infoP->msisdn is 15 digits. : - infoP->msisdn is not nil, but IOWA_SMS_SUPPORT is not defined. IOWA_COAP_412_PRECONDITION_FAILED : the client was already configured in this context. To reconfigure the client, close than reopen a fresh IOWA context with iowa_close() and iowa_init() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes The nil-terminated strings pointed by the fields of infoP are not duplicated nor freed by IOWA. Make sure they are available until iowa_close() is called. It is advised to use static strings. The LwM2M Client information are exposed to the LwM2M Server through the Resources of the [ Device Object ][Device Object] (ID: 3). The following table explained the mapping: Resource ID Resource Name API 0 Manufacturer manufacturer field of the iowa_device_info_t structure. 1 Model Number modelNumber field of the iowa_device_info_t structure. 2 Serial Number serialNumber field of the iowa_device_info_t structure. 3 Firmware Version firmwareVersion field of the iowa_device_info_t structure. 4 Reboot 5 Factory Reset 6 Available Power Sources Set the flag IOWA_DEVICE_RSC_POWER_SOURCE in optFlags field of the structure iowa_device_info_t . Then use iowa_client_..._device_power_source to control it. 7 Power Source Voltage Set the flag IOWA_DEVICE_RSC_POWER_SOURCE in optFlags field of the structure iowa_device_info_t . Then use iowa_client_..._device_power_source to control it. 8 Power Source Current Set the flag IOWA_DEVICE_RSC_POWER_SOURCE in optFlags field of the structure iowa_device_info_t . Then use iowa_client_..._device_power_source to control it. 9 Battery Level Set the flag IOWA_DEVICE_RSC_BATTERY in optFlags field of the structure iowa_device_info_t . Then use iowa_client_device_update_battery to control it. 10 Memory Free Not exposed by IOWA. 11 Error Code Use iowa_client_..._device_error_code to control it. 12 Reset Error Code Set the flag IOWA_DEVICE_RSC_RESET_ERROR in optFlags field of the structure iowa_device_info_t . 13 Current Time Set the flag IOWA_DEVICE_RSC_CURRENT_TIME in optFlags field of the structure iowa_device_info_t . Then use iowa_client_update_device_time_information to control it. 14 UTC Offset utcOffsetP field and set the flag IOWA_DEVICE_RSC_UTC_OFFSET in optFlags field of the structure iowa_device_info_t . Then use iowa_client_update_device_time_information to control it. 15 Timezone timezoneP field and set the flag IOWA_DEVICE_RSC_TIMEZONE in optFlags field of the structure iowa_device_info_t . Then use iowa_client_update_device_time_information to control it. 16 Supported Binding and Modes Cannot be updated directly but depends on the Server URI schema. 17 Device Type deviceType field of the iowa_device_info_t structure. 18 Hardware Version hardwareVersion field of the iowa_device_info_t structure. 19 Software Version softwareVersion field of the iowa_device_info_t structure. 20 Battery Status Set the flag IOWA_DEVICE_RSC_BATTERY in optFlags field of the structure iowa_device_info_t . Then use iowa_client_device_update_battery to control it. 21 Memory Total Not exposed by IOWA. 22 ExtDevInfo Not exposed by IOWA. \\clearpage iowa_client_new_incoming_connection \u00b6 Prototype iowa_status_t iowa_client_new_incoming_connection ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); Description iowa_client_new_incoming_connection() informs the stack of a new incoming connection. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The type of the new connection. See iowa_connection_type_t . connP : The new connection of the same user-defined type as the one returned by iowa_system_connection_open() . isSecure : Set to true if the security must be enabled on this connection. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - the connection type is not supported. Make sure to verify the corresponding IOWA_..._SUPPORT flag has been enabled during IOWA build. : - isSecure is true, but no security layer has been built. Make sure to verify the corresponding IOWA_SECURITY_LAYER_... flag has been enabled during IOWA build. Header File iowa_client.h Notes iowa_client_new_incoming_connection() can only be called when IOWA is built with the flag LWM2M_CLIENT_INCOMING_CONNECTION_SUPPORT . \\clearpage iowa_client_add_bootstrap_server \u00b6 Prototype iowa_status_t iowa_client_add_bootstrap_server ( iowa_context_t contextP , const char * uri , iowa_security_mode_t securityMode ); Description iowa_client_add_bootstrap_server() declares a new LwM2M Bootstrap Server for the LwM2M Client to connect to. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. The context MUST be configured with iowa_client_configure() to add a bootstrap server. uri : The URI to reach this bootstrap server as a nil-terminated string e.g. \"coaps://[::1]:5684\", \"coap://lwm2m.example.org:5683\" or \"sms://+331020304050\". securityMode : The security mode to use when connecting to this LwM2M Bootstrap Server. See iowa_security_mode_t . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : uri is nil. IOWA_COAP_403_FORBIDDEN : a bootstrap server is already configured. To reconfigure the LwM2M Bootstrap Server, call first iowa_client_remove_bootstrap_server . IOWA_COAP_404_NOT_FOUND : client is not configured. Call first iowa_client_configure() . IOWA_COAP_406_NOT_ACCEPTABLE : uri is invalid. For example, if the transport is not supported or if uri does not match securityMode . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes iowa_client_add_bootstrap_server() can only be called when IOWA is built with the flag LWM2M_BOOTSTRAP . uri is duplicated internally by IOWA and can be freed by the caller. Only one bootstrap server can be configured. \\clearpage iowa_client_remove_bootstrap_server \u00b6 Prototype iowa_status_t iowa_client_remove_bootstrap_server ( iowa_context_t contextP ); Description iowa_client_remove_bootstrap_server() removes a LwM2M Bootstrap Server added by iowa_client_add_bootstrap_server() from the LwM2M Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : no bootstrap server is configured. iowa_client_add_bootstrap_server() was not called before, or failed. Header File iowa_client.h Notes iowa_client_remove_bootstrap_server() can only be called when IOWA is built with the flag LWM2M_BOOTSTRAP . \\clearpage iowa_client_set_bootstrap_server_hold_off \u00b6 Prototype iowa_status_t iowa_client_set_bootstrap_server_hold_off ( iowa_context_t contextP , int32_t holdOff ); Description iowa_client_set_bootstrap_server_hold_off() sets the Bootstrap Hold Off time. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. holdOff : The Hold Off time. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : holdOff is negative. IOWA_COAP_404_NOT_FOUND : no bootstrap server is configured. iowa_client_add_bootstrap_server() was not called before, or failed. Header File iowa_client.h Notes iowa_client_set_bootstrap_server_hold_off() can only be called when IOWA is built with the flag LWM2M_BOOTSTRAP . \\clearpage iowa_client_get_bootstrap_server_coap_peer \u00b6 Prototype iowa_coap_peer_t * iowa_client_get_bootstrap_server_coap_peer ( iowa_context_t contextP ); Description iowa_client_get_bootstrap_server_coap_peer() returns the CoAP peer associated to a LwM2M Bootstrap Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value A pointer to the iowa_coap_peer_t associated to the LwM2M Bootstrap Server. This pointer may be nil if IOWA did not yet initiate, or has finished, the Bootstrap process. Header File iowa_client.h Notes iowa_client_get_bootstrap_server_coap_peer() can only be called when IOWA is built with the flag LWM2M_BOOTSTRAP . \\clearpage iowa_client_add_server \u00b6 Prototype iowa_status_t iowa_client_add_server ( iowa_context_t contextP , uint16_t shortID , const char * uri , uint32_t lifetime , uint16_t configFlags , iowa_security_mode_t securityMode ); Description iowa_client_add_server() declares a new LwM2M Server for the LwM2M Client to connect to. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. The context MUST be configured with iowa_client_configure() to add a server. shortID : The ID assigned to this server. This cannot be zero nor IOWA_LWM2M_ID_ALL nor an existing one. uri : The URI to reach this server as a nil-terminated string e.g. \"coaps://[::1]:5684\", \"coap://lwm2m.example.org:5683\" or \"sms://+331020304050\". lifetime : The lifetime in seconds of the registration to this server. configFlags : A bit-mask of configuration flags for this LwM2M Server. securityMode : The security mode to use when connecting to this LwM2M Server. See iowa_security_mode_t . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : uri is nil. IOWA_COAP_403_FORBIDDEN : shortID is either zero, IOWA_LWM2M_ID_ALL or already in use. IOWA_COAP_404_NOT_FOUND : client is not configured. Call first iowa_client_configure() . IOWA_COAP_406_NOT_ACCEPTABLE : uri is invalid. For example, if the transport is not supported or if uri does not match securityMode . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes If lifetime is set to zero, the registration lifetime is set to a default value of: 30 days (2,592,000 seconds) for LoRaWAN transport 24 hours (86,400 seconds) for other transports (UDP, TCP, SMS ...) uri is duplicated internally by IOWA and can be freed by the caller. configFlags is a combination of the following: IOWA_LWM2M_QUEUE_MODE : Enable LwM2M Queue Mode for this LwM2M Server. \\clearpage iowa_client_remove_server \u00b6 Prototype iowa_status_t iowa_client_remove_server ( iowa_context_t contextP , uint16_t shortID ); Description iowa_client_remove_server() removes a LwM2M Server added by iowa_client_add_server() from the LwM2M Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to this server or IOWA_LWM2M_ID_ALL . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortID is zero. IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h \\clearpage iowa_client_set_server_configuration \u00b6 Prototype iowa_status_t iowa_client_set_server_configuration ( iowa_context_t contextP , uint16_t shortId , iowa_server_setting_id_t settingId , void * argP ); Description iowa_client_set_server_configuration() configures the settings of a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The short ID of a LwM2M Server. settingId : The setting to set. See iowa_server_setting_id_t . argP : A pointer to the setting value. Dependent on settingId . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortId does not match any known server. IOWA_COAP_405_METHOD_NOT_ALLOWED : settingId is nil. IOWA_COAP_501_NOT_IMPLEMENTED : invalid settingId value. Header File iowa_client.h \\clearpage iowa_client_set_server_msisdn \u00b6 Prototype iowa_status_t iowa_client_set_server_msisdn ( iowa_context_t contextP , uint16_t shortID , const char * msisdn ); Description iowa_client_set_server_msisdn() sets the MSISDN of a previously added LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : the Short ID assigned to a LwM2M Server. msisdn : the MSISDN to reach this Server e.g. \"0102030405\" or \"+33102030405\". This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : the maximum length of msisdn is 15 digits. IOWA_COAP_403_FORBIDDEN : shortID is either zero or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes iowa_client_set_server_msisdn() can only be called when IOWA is built with the flag IOWA_SMS_SUPPORT . To unset the MSISDN, the parameter msisdn can take the value NULL. An MSISDN can not be set for the Bootstrap Server. \\clearpage iowa_client_set_server_registration_behaviour \u00b6 Prototype iowa_status_t iowa_client_set_server_registration_behaviour ( iowa_context_t contextP , uint16_t shortId , uint16_t priorityOrder , int32_t initialDelayTimer , bool blockOnFailure , bool bootstrapOnFailure ); Description iowa_client_set_server_registration_behaviour() set the registration behaviour of a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to the server. priorityOrder : The Server priority order for the registration sequence. initialDelayTimer : The initial delay to wait before to send the registration. blockOnFailure : If registration fails and true is set, the registration sequence is interrupted. bootstrapOnFailure : If registration fails and true is set, a bootstrap sequence is initiated. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - initialDelayTimer is negative. : - bootstrapOnFailure is equals to true but [ LWM2M_BOOTSTRAP ][LWM2M_BOOTSTRAP] is not set. IOWA_COAP_403_FORBIDDEN : shortID is either zero or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h Notes This API requires LWM2M_VERSION_1_1_SUPPORT to be set. If IOWA_SERVER_RSC_REGISTRATION_BEHAVIOUR_REMOVE is set, this API cannot be called. \\clearpage iowa_client_set_server_communication_attempts \u00b6 Prototype iowa_status_t iowa_client_set_server_communication_attempts ( iowa_context_t contextP , uint16_t shortId , uint8_t retryCount , int32_t retryDelayTimer , uint8_t sequenceRetryCount , int32_t sequenceDelayTimer ); Description iowa_client_set_server_communication_attempts() set the communication attempts of a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to the server. retryCount : The number of successive registration attempts before which a registration sequence is considered as failed. retryDelayTimer : The number to wait between each registration sequence. The value is multiplied by two to the power of the registration retry attempt minus one (2**(retry attempt-1)) to create an exponential back-off. sequenceRetryCount : The number of successive registration sequences before which a registration attempt is considered as failed. sequenceDelayTimer : The number to wait between each successive registration sequences. The value is multiplied by two to the power of the registration retry attempt minus one (2**(retry attempt-1)) to create an exponential back-off. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - retryCount is superior to 32. : - retryDelayTimer is negative. : - sequenceRetryCount is superior to 32. : - sequenceDelayTimer is negative. IOWA_COAP_403_FORBIDDEN : shortID is either zero or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h Notes This API requires LWM2M_VERSION_1_1_SUPPORT to be set. If IOWA_SERVER_RSC_COMMUNICATION_ATTEMPTS_REMOVE is set, this API cannot be called. \\clearpage iowa_client_get_server_count \u00b6 Prototype iowa_status_t iowa_client_get_server_count ( iowa_context_t contextP , size_t * serversCountP ); Description iowa_client_get_server_count() get the count of all configured LwM2M Servers. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. serversCountP : A pointer to the count of all configured LwM2M Servers. Return Value IOWA_COAP_NO_ERROR : success. Header File iowa_client.h \\clearpage iowa_client_get_server_array \u00b6 Prototype iowa_status_t iowa_client_get_server_array ( iowa_context_t contextP , size_t serversCount , iowa_server_info_t * serverArrayP ); Description iowa_client_get_server_array() retrieves the configured LwM2M Servers with theirs associated information. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. serversCount : A pointer to the count of LwM2M Servers. serverArrayP : An Array of iowa_server_info_t with a size equal to the count of the current configured LwM2M Servers. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : serverListP is nil. IOWA_COAP_408_REQUEST_ENTITY_INCOMPLETE : The count of configured LwM2M servers has been changed since the call of iowa_client_get_server_count() . Header File iowa_client.h Notes To get the count of the current configured LwM2M Servers you need to call iowa_client_get_server_count() . \\clearpage iowa_client_get_server_coap_peer \u00b6 Prototype iowa_coap_peer_t * iowa_client_get_server_coap_peer ( iowa_context_t contextP , uint16_t shortId ); Description iowa_client_get_server_coap_peer() returns the CoAP peer associated to a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to the server. Return Value A pointer to the iowa_coap_peer_t associated to the LwM2M Server. This pointer may be nil if shortId is invalid or if IOWA did not yet initiate the registration to the LwM2M Server. Header File iowa_client.h \\clearpage iowa_client_set_notification_default_periods \u00b6 Prototype iowa_status_t iowa_client_set_notification_default_periods ( iowa_context_t contextP , uint16_t shortID , uint32_t minPeriod , uint32_t maxPeriod ); Description iowa_client_set_notification_default_periods() configures the default periods for notifications sent to a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to the server or IOWA_LWM2M_ID_ALL . minPeriod : The default minimum time in seconds between two notifications sent to the LwM2M Server for the same observation. maxPeriod : The default maximum time in seconds between two notifications sent to the LwM2M Server for the same observation. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortID is zero. IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h Notes When IOWA_LWM2M_ID_ALL is used as shortID , only already known LwM2M Servers will have the default periods configured. If a LwM2M Server is added after the call to this API, by default it will not have default periods. Setting the default periods does not affect already running observations. A minimum period set to zero is equivalent to having no minimum period defined. Same for maximum period. If maxPeriod is inferior to minPeriod , it is cleared (i.e. set to zero). \\clearpage iowa_client_use_reliable_notifications \u00b6 Prototype iowa_status_t iowa_client_use_reliable_notifications ( iowa_context_t contextP , uint16_t shortId , bool enable ); Description iowa_client_use_reliable_notifications() configures the LwM2M Client to ensure that notifications are received by the LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The ID assigned to the server or IOWA_LWM2M_ID_ALL . enable : If true, notifications will be reliable. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortID is zero. IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h Notes When IOWA_LWM2M_ID_ALL is used as shortID , only already known LwM2M Servers will have reliable notifications. If a LwM2M Server is added after the call to this API, by default it will not use reliable notifications. If enable is true: on unreliable transports like UDP, the notifications are sent as Confirmable messages. if a notification does not reach the LwM2M Server, IOWA stores it until the LwM2M Server is reachable again. See [ LWM2M_STORAGE_QUEUE_SUPPORT ][LWM2M_STORAGE_QUEUE_SUPPORT] and [ LWM2M_STORAGE_QUEUE_PEEK_SUPPORT ][LWM2M_STORAGE_QUEUE_PEEK_SUPPORT]. \\clearpage iowa_client_object_set_mode \u00b6 Prototype iowa_status_t iowa_client_object_set_mode ( iowa_context_t contextP , iowa_sensor_t id , uint8_t mode ); Description iowa_client_object_set_mode() sets the sensor mode. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The ID of the sensor. mode : Flags used to enable modes. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known sensor. Header File iowa_client.h Notes To use this API, the compilation flag [ LWM2M_CLIENT_ASYNCHRONOUS_OPERATION_SUPPORT ][LWM2M_CLIENT_ASYNCHRONOUS_OPERATION_SUPPORT] must be set. To set the sensor mode, you can use the following flag: IOWA_OBJECT_MODE_DEFAULT IOWA_OBJECT_MODE_ASYNCHRONOUS By default, sensors are synchronous. A call to iowa_client_object_set_mode() affects all the sensors of the same type. \\clearpage iowa_client_device_update_battery \u00b6 Prototype iowa_status_t iowa_client_device_update_battery ( iowa_context_t contextP , uint8_t batteryLevel , iowa_device_battery_status_t batteryStatus ); Description iowa_client_device_update_battery() updates the battery level and status exposed in the [ Device Object ][Device Object]. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. batteryLevel : The battery level in percent. batteryStatus : The battery status. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_405_METHOD_NOT_ALLOWED : client has been configured without the flag IOWA_DEVICE_RSC_BATTERY in the iowa_device_info_t structure. To reconfigure the client, close than reopen a fresh IOWA Client context with iowa_close() , iowa_init() and iowa_client_configure() . IOWA_COAP_406_NOT_ACCEPTABLE : batteryLevel is outside the range [0; 100]. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . Header File iowa_client.h Notes For the device to expose its battery level and status, iowa_client_configure() must have been to called with the IOWA_DEVICE_RSC_BATTERY flag. Before the first call to iowa_client_device_update_battery() , default value of batteryStatus is IOWA_DEVICE_BATTERY_STATUS_UNKNOWN . iowa_client_device_update_battery() can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_BATTERY_REMOVE . iowa_device_battery_status_t \u00b6 This is an enumeration of the following values: IOWA_DEVICE_BATTERY_STATUS_NORMAL : The battery is operating normally and not on power. IOWA_DEVICE_BATTERY_STATUS_CHARGING : The battery is currently charging. IOWA_DEVICE_BATTERY_STATUS_CHARGE_COMPLETE : The battery is fully charged and still on power. IOWA_DEVICE_BATTERY_STATUS_DAMAGED : The battery has some problem. IOWA_DEVICE_BATTERY_STATUS_LOW_BATTERY : The battery is low on charge. IOWA_DEVICE_BATTERY_STATUS_NOT_INSTALLED : The battery is not installed. IOWA_DEVICE_BATTERY_STATUS_UNKNOWN : The battery information is not available. \\clearpage iowa_client_add_device_power_source \u00b6 Prototype iowa_status_t iowa_client_add_device_power_source ( iowa_context_t context , iowa_power_source_type_t type , int voltageValue , int currentValue , iowa_sensor_t * idP ); Description iowa_client_add_device_power_source() adds a power source to Device object with initial value of voltage and current. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : power source type. voltageValue : initial voltage value (mV). currentValue : initial current value (mA). idP : Used to store the ID of the created power source. Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_405_METHOD_NOT_ALLOWED : client has been configured without the flag IOWA_DEVICE_RSC_POWER_SOURCE in the iowa_device_info_t structure. To reconfigure the client, close than reopen a fresh IOWA Client context with iowa_close() , iowa_init() and iowa_client_configure() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes For the device to expose its power source information, iowa_client_configure() must have been to called with the IOWA_DEVICE_RSC_POWER_SOURCE flag. To update a power source values, you need to call iowa_client_update_device_power_source() . To remove a power source, you need to call iowa_client_remove_device_power_source() . iowa_client_add_device_power_source() can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE . iowa_power_source_type_t \u00b6 This is an enumeration of the following values: IOWA_POWER_SOURCE_DC_POWER : DC power supply. IOWA_POWER_SOURCE_INTERNAL_BATTERY : Internal battery. IOWA_POWER_SOURCE_EXTERNAL_BATTERY : External battery. IOWA_POWER_SOURCE_FUEL_CELL : Fuel Cell IOWA_POWER_SOURCE_POWER_OVER_ETHERNET : Power Over Ethernet. IOWA_POWER_SOURCE_USB : USB. IOWA_POWER_SOURCE_AC_MAIN_POWER : AC power supply. IOWA_POWER_SOURCE_SOLAR : Solar energy. \\clearpage iowa_client_remove_device_power_source \u00b6 Prototype iowa_status_t iowa_client_remove_device_power_source ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_device_power_source() removes a power source from the Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the power source to remove. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_404_NOT_FOUND : id is not a device's power source. Valid id are only returned by iowa_client_add_device_power_source() . IOWA_COAP_405_METHOD_NOT_ALLOWED : client has been configured without the flag IOWA_DEVICE_RSC_POWER_SOURCE in the iowa_device_info_t structure. To reconfigure the client, close than reopen a fresh IOWA Client context with iowa_close() , iowa_init() and iowa_client_configure() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes For the device to expose its power source information, iowa_client_configure() must have been to called with the IOWA_DEVICE_RSC_POWER_SOURCE flag. iowa_client_remove_device_power_source() can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE . \\clearpage iowa_client_update_device_power_source \u00b6 Prototype iowa_status_t iowa_client_update_device_power_source ( iowa_context_t context , iowa_sensor_t id , int voltageValue , int currentValue ); Description iowa_client_update_device_power_source() updates a power source values to Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the power source. voltageValue : new voltage value (mV). currentValue : new current value (mA). Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_404_NOT_FOUND : id is not a device's power source. Valid id are only returned by iowa_client_add_device_power_source() . IOWA_COAP_405_METHOD_NOT_ALLOWED : client has been configured without the flag IOWA_DEVICE_RSC_POWER_SOURCE in the iowa_device_info_t structure. To reconfigure the client, close than reopen a fresh IOWA Client context with iowa_close() , iowa_init() and iowa_client_configure() . Header File iowa_client.h Notes For the device to expose its power source information, iowa_client_configure() must have been to called with the IOWA_DEVICE_RSC_POWER_SOURCE flag. iowa_client_update_device_power_source() can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE . \\clearpage iowa_client_update_device_information \u00b6 Prototype iowa_status_t iowa_client_update_device_information ( iowa_context_t contextP , iowa_device_info_t * deviceInfoP ); Description iowa_client_update_device_information() updates the device information. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. infoP : pointer to the new device's information. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : deviceInfoP is nil. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . Header File iowa_client.h Notes This function update only the supported device resources that has been set previously in iowa_client_configure() . The parameters that can be updated are : Manufacturer. Model number. Serial number. Firmware version. Device type. Hardware version. Software version. Nil values in deviceInfoP will be ignored and won't make any changes. \\clearpage iowa_client_set_device_error_code \u00b6 Prototype iowa_status_t iowa_client_set_device_error_code ( iowa_context_t context , uint8_t errorCode ); Description iowa_client_set_device_error_code() sets an error code on Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. errorCode : The error code value to set between 1 and 32. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_402_BAD_OPTION : errorCode is not a valid parameter. IOWA_COAP_404_NOT_FOUND : errorCode is IOWA_ERROR_CODE_NO_ERROR but there is no error to clear. IOWA_COAP_409_CONFLICT : errorCode has already been set. Header File iowa_client.h Notes To clear one error code, you need to call iowa_client_clear_device_error_code() . To clear all error codes, you can call iowa_client_set_device_error_code() with errorCode argument set to IOWA_ERROR_CODE_NO_ERROR. The error code is an integer between 1 and 32. The LwM2M protocol defines eight values between 1 and 8 detailed below. Values between 9 and 15 are reserved for future use. The device maker or the application can use the values between 16 and 32 as proprietary error codes. LwM2M defined error code values are: IOWA_ERROR_CODE_NO_ERROR : No error. IOWA_ERROR_CODE_LOW_BATTERY_POWER (1) : Low battery power. IOWA_ERROR_CODE_EXTERNAL_POWER_SUPPLY_OFF (2) : External power supply off. IOWA_ERROR_CODE_GPS_MODULE_FAILURE (3) : GPS module failure. IOWA_ERROR_CODE_LOW_RECEIVED_SIGNAL_STRENGTH (4) : Low received signal strength. IOWA_ERROR_CODE_OUT_OF_MEMORY (5) : Out of memory. IOWA_ERROR_CODE_SMS_FAILURE (6) : SMS failure. IOWA_ERROR_CODE_IP_CONNECTIVITY_FAILURE (7) : IP connectivity failure. IOWA_ERROR_CODE_PERIPHERAL_MALFUNCTION (8) : Peripheral malfunction. \\clearpage iowa_client_clear_device_error_code \u00b6 Prototype iowa_status_t iowa_client_clear_device_error_code ( iowa_context_t context , uint8_t errorCode ); Description iowa_client_clear_device_error_code() clears an error code from the Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. errorCode : The error code to clear between 1 and 32. It can't be IOWA_ERROR_CODE_NO_ERROR . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_402_BAD_OPTION : The error code IOWA_ERROR_CODE_NO_ERROR can't be cleared. IOWA_COAP_404_NOT_FOUND : The error code is not set. Header File iowa_client.h Notes LwM2M defined error code values are enumerated in iowa_client_set_device_error_code() . \\clearpage iowa_client_update_device_time_information \u00b6 Prototype iowa_status_t iowa_client_update_device_time_information ( iowa_context_t contextP , iowa_device_time_info_t * timeInfoP ); Description iowa_client_update_device_time_information() updates time information to Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. timeInfoP : Current device time information: iowa_device_time_info_t . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : timeInfoP is nil. : currentTime in timeInfoP is set with a negative value. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . Header File iowa_client.h Notes For the device to expose its time information, iowa_client_configure() must have been to called with time information used. \\clearpage iowa_client_add_custom_object \u00b6 Prototype iowa_status_t iowa_client_add_custom_object ( iowa_context_t contextP , uint16_t objectID , size_t instanceCount , uint16_t * instanceIDs , size_t resourceCount , iowa_lwm2m_resource_desc_t * resourceArray , iowa_RWE_callback_t dataCallback , iowa_CD_callback_t instanceCallback , iowa_RI_callback_t resInstanceCallback , void * userData ); Description iowa_client_add_custom_object() adds a new custom Object for the LwM2M Client to handle. The object is defined by its ID and a the list of the resources it contains. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectID : The ID of the Object. instanceCount : The number of elements in instanceIDs . This can be 0. instanceIDs : The IDs of the instances of the Object. This can be nil. resourceCount : The number of elements in resourceArray . resourceArray : An array of iowa_lwm2m_resource_desc_t composing the Object. dataCallback : The callback to perform Read, Write and Execute operations on the resources. instanceCallback : The callback to perform Create and Delete operations on Object instances. This can be nil. resInstanceCallback : The callback to retrieve the list of instances of resources declared as multiple. This can be nil. userData : Passed as argument to the callbacks. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_403_FORBIDDEN : objectID is 0, 1 or 3 which are reserved Object IDs. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - objectID is IOWA_LWM2M_ID_ALL (65535). : - resourceCount is zero. : - resourceArray is nil. : - dataCallback is nil. : - instanceIDs is nil and instanceCount is not zero. : - resInstanceCallback is nil and one of the resources in resourceArray has the IOWA_RESOURCE_FLAG_MULTIPLE flag set. IOWA_COAP_409_CONFLICT : this object already exists. Call first iowa_client_remove_custom_object() . Header File iowa_client.h Notes Object IDs 0, 1 and 3 are reserved and cannot be used. Per Lightweight M2M specification, the ID of the instance of a single-instance Object is 0. When creating a single-instance Object, you can set instanceCount to zero and instanceCallback to nil. IOWA will automatically create an instance with ID 0. When the LwM2M Server creates a new instance of the custom object, instanceCallback is first called with the new instance ID then dataCallback is called with operation set to IOWA_DM_WRITE to initialize the instance. Thus if instanceCallback is defined, dataCallback must handle the Write operation even on resources declared as read-only. \\clearpage iowa_client_remove_custom_object \u00b6 Prototype iowa_status_t iowa_client_remove_custom_object ( iowa_context_t contextP , uint16_t objectID ); Description iowa_client_remove_custom_object() removes a custom Object created with iowa_client_add_custom_object() . Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectID : The ID of the Object. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : objectID is 0, 1 or 3 which are reserved Object IDs. IOWA_COAP_404_NOT_FOUND : objectID does not match any known object. IOWA_COAP_406_NOT_ACCEPTABLE : objectID is IOWA_LWM2M_ID_ALL (65535). Header File iowa_client.h \\clearpage iowa_client_object_resource_changed \u00b6 Prototype iowa_status_t iowa_client_object_resource_changed ( iowa_context_t contextP , uint16_t objectID , uint16_t instanceID , uint16_t resourceID ); Description iowa_client_object_resource_changed() informs the IOWA stack that the value of a LwM2M Object resource changed. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectID : The ID of the Object containing the resource. instanceID : The ID of the Instance containing the resource. This can be IOWA_LWM2M_ID_ALL . resourceID : The ID of the resource. This can be IOWA_LWM2M_ID_ALL . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : objectID is 0, 1 or 3 which are reserved Object IDs. IOWA_COAP_406_NOT_ACCEPTABLE : objectID is IOWA_LWM2M_ID_ALL (65535). Header File iowa_client.h Notes This API does not check if the LwM2M Object resource exists. That's why this API does not return IOWA_COAP_404_NOT_FOUND. Actually, iowa_client_object_resource_changed() is only searching a match between the running observation and the URI provided. If a match is found a notification is sent, else nothing happens. \\clearpage iowa_client_object_instance_changed \u00b6 Prototype iowa_status_t iowa_client_object_instance_changed ( iowa_context_t contextP , uint16_t objectID , uint16_t instanceID , iowa_dm_operation_t operation ); Description iowa_client_object_instance_changed() informs the IOWA stack that an instance of a LwM2M Object was created or deleted. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectID : The ID of the Object containing the instance. instanceID : The ID of the created or deleted Instance. operation : IOWA_DM_CREATE if it is a new instance. IOWA_DM_DELETE if the instance was removed. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_403_FORBIDDEN : objectID is 0, 1 or 3 which are reserved Object IDs. IOWA_COAP_404_NOT_FOUND : either: : - objectID does not match any known object. : - operation is IOWA_DM_DELETE and instanceID does not match any known instance. IOWA_COAP_405_METHOD_NOT_ALLOWED : operation is neither IOWA_DM_CREATE nor IOWA_DM_DELETE . IOWA_COAP_406_NOT_ACCEPTABLE : either: : - objectID is IOWA_LWM2M_ID_ALL (65535). : - operation is IOWA_DM_CREATE and instanceID was already present. Header File iowa_client.h \\clearpage iowa_client_notification_lock \u00b6 Prototype void iowa_client_notification_lock ( iowa_context_t contextP , bool enter ); Description iowa_client_notification_lock() prevents or allows the IOWA stack to send notifications and registration updates. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. enter : true to stop the notification, false to resume the notification. Return Value None. Header File iowa_client.h Notes The main use is to perform several calls to iowa_client_object_resource_changed() on an Object without generating a notification each time if the Object is under observation. Registration updates are also blocked, allowing to add or remove several Objects or Object Instances. This function is useful only if IOWA is built with the IOWA_MULTITHREAD_SUPPORT flag. Inside a custom object callback, notifications are already disabled. \\clearpage iowa_client_send_heartbeat \u00b6 Prototype iowa_status_t iowa_client_send_heartbeat ( iowa_context_t contextP , uint16_t shortID ); Description iowa_client_send_heartbeat() sends an heartbeat message to a server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The Short ID assigned to this Server. Can be equal to IOWA_LWM2M_ID_ALL . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortID is zero. IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. IOWA_COAP_412_PRECONDITION_FAILED : client is not connected to the server with shortID . This can happen when: : - The Server is a Bootstrap Server and the Client is already connect to a Server. : - The Client is configured with more than one Server and has established the connection with only one. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : heartbeat message has not been sent by the platform. Header File iowa_client.h Notes If shortID is equal to IOWA_LWM2M_ID_ALL , the heartbeat message will be sent to all servers. For non LoRaWAN Servers, a registration update message is sent to the Server. The iowa_event_callback_t will be called with a IOWA_EVENT_REG_UPDATING event. Then, if a reply is received from the Server, the iowa_event_callback_t will be called with either a IOWA_EVENT_REG_REGISTERED or IOWA_EVENT_REG_FAILED event. Nothing is done when no reply is received from the Server. In the IOWA_EVENT_REG_REGISTERED case, the registration lifetime timer for the LwM2M Server is resetted. \\clearpage iowa_client_send_sensor_data \u00b6 Prototype iowa_status_t iowa_client_send_sensor_data ( iowa_context_t contextP , uint16_t shortId , iowa_sensor_uri_t * sensorUriP , size_t sensorUriCount , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_client_send_sensor_data() sends data from iowa_sensor_t to server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The ID of the server. It can be IOWA_LWM2M_ID_ALL to send to all registered servers. sensorUriP , sensorUriCount : The sensor uri to send. responseCb : The callback called when the reply to this operation is known. This can be nil. userDataP : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : sensorUriCount is zero or sensorUriP is nil. IOWA_COAP_401_UNAUTHORIZED : The destination LwM2M Server does not have the Read Access Right to the sent data. Refer to the [Access Control List Object][Access Control List Object] for details. IOWA_COAP_403_FORBIDDEN : shortId is not an acceptable value. IOWA_COAP_404_NOT_FOUND : either: : - shortId does not match a known server. : - at least one sensorUriP[x] does not match a known resource. IOWA_COAP_405_METHOD_NOT_ALLOWED : at least one sensorUriP[x] 's resource is not readable. IOWA_COAP_412_PRECONDITION_FAILED : the receiving LwM2M Server has muted the Send feature. See the Mute Send resource of the [Server Object][Server Object]. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : the client is not registered to the requested LwM2M Server or the communication with the requested LwM2M Server failed. Header File iowa_client.h Notes This API requires the compilation flag [ LWM2M_DATA_PUSH_SUPPORT ][LWM2M_DATA_PUSH_SUPPORT]. The responseCb will be called with the operation set to IOWA_DM_DATA_PUSH . If shortId is IOWA_LWM2M_ID_ALL , the responseCb will be called for each registered LwM2M Server which has not muted the Client. \\clearpage iowa_client_send_data \u00b6 Prototype iowa_status_t iowa_client_send_data ( iowa_context_t contextP , uint16_t shortId , iowa_lwm2m_data_t * dataArrayP , size_t dataCount , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_client_send_data() sends data to server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The ID of the server. It can be IOWA_LWM2M_ID_ALL to send to all registered servers. dataArrayP , dataCount : The data to send. responseCb : The callback called when the reply to this operation is known. This can be nil. resultUserDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - at least one dataArrayP[x].resourceID is IOWA_LWM2M_ID_ALL . : - dataCount is zero or dataArrayP is nil. IOWA_COAP_401_UNAUTHORIZED : The destination LwM2M Server does not have the Read Access Right to the sent data. Refer to the [Access Control List Object][Access Control List Object] for details. IOWA_COAP_403_FORBIDDEN : shortId is not an acceptable value. IOWA_COAP_404_NOT_FOUND : either: : - shortId does not match a known server. : - at least one dataArrayP[x] does not match a known resource. IOWA_COAP_405_METHOD_NOT_ALLOWED : at least one dataArrayP[x] 's resource is not readable. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - one of the timestamped value has an negative timestamp. : - at least one dataArrayP[x] has negative value with unsigned integer type IOWA_COAP_412_PRECONDITION_FAILED : the receiving LwM2M Server has muted the Send feature. See the Mute Send resource of the [Server Object][Server Object]. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : the client is not registered to the requested LwM2M Server or the communication with the requested LwM2M Server failed. Header File iowa_client.h Notes This API requires the compilation flag [ LWM2M_DATA_PUSH_SUPPORT ][LWM2M_DATA_PUSH_SUPPORT]. The responseCb will be called with the operation set to IOWA_DM_DATA_PUSH . If shortId is IOWA_LWM2M_ID_ALL , the responseCb will be called for each registered LwM2M Server which has not muted the Client. \\clearpage Accelerometer Object API \u00b6 This IPSO object can be used to represent a 1-3 axis accelerometer. To be able to use this object, iowa_accelerometer.h must be included. iowa_client_add_accelerometer_object \u00b6 Prototype iowa_status_t iowa_client_add_accelerometer_object ( iowa_context_t context , uint16_t optFlags , float minRangeValue , float maxRangeValue , const char * sensorUnits , iowa_sensor_t * idP ); Description iowa_client_add_accelerometer_object() creates an accelerometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. minRangeValue : Minimal range value for the accelerometer. maxRangeValue : Maximal range value for the accelerometer. sensorUnits : Measurement units definition idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : minRangeValue argument is superior to maxRangeValue argument. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_accelerometer.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_ACCELEROMETER_RSC_Y_VALUE IOWA_ACCELEROMETER_RSC_Z_VALUE IOWA_ACCELEROMETER_RSC_MIN_RANGE_VALUE IOWA_ACCELEROMETER_RSC_MAX_RANGE_VALUE Moreover, you can add several optional resources at one time by using the following flags: IOWA_ACCELEROMETER_3_AXIS IOWA_ACCELEROMETER_RANGE_VALUE \\clearpage iowa_client_remove_accelerometer_object \u00b6 Prototype iowa_status_t iowa_client_remove_accelerometer_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_accelerometer_object() removes an accelerometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an accelerometer object. Valid id are only returned by iowa_client_add_accelerometer_object() . IOWA_COAP_404_NOT_FOUND : accelerometer referred by id does not exist. Header File objects/iowa_accelerometer.h \\clearpage iowa_client_accelerometer_update_axis \u00b6 Prototype iowa_status_t iowa_client_accelerometer_update_axis ( iowa_context_t context , iowa_sensor_t id , float xValue , float yValue , float zValue ); Description iowa_client_accelerometer_update_axis() updates values of an accelerometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object xValue : X value axis yValue : Y value axis zValue : Z value axis Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an accelerometer object. Valid id are only returned by iowa_client_add_accelerometer_object() . IOWA_COAP_404_NOT_FOUND : accelerometer referred by id does not exist. Header File objects/iowa_accelerometer.h \\clearpage Access Control List Object API \u00b6 This LwM2M Object is used to check whether the LwM2M Server has access right for performing an operation. To be able to use this object, iowa_access_control_list.h must be included and the define [ IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT ][IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT] must bet set. iowa_client_acl_rights_server_set \u00b6 Prototype iowa_status_t iowa_client_acl_rights_server_set ( iowa_context_t contextP , uint16_t objectId , uint16_t instanceId , uint16_t serverId , uint8_t accessRights ); Description iowa_client_acl_rights_server_set() set the access rights for a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectId : ID of the Object. instanceId : ID of the Object Instance. serverId : Short Server ID of a LwM2M Server or IOWA_ACL_DEFAULT_ID . accessRights : new access rights to set. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : either: : if instanceId is IOWA_LWM2M_ID_ALL , accessRights must be IOWA_ACL_CREATE_RIGHT . : if instanceId is not IOWA_LWM2M_ID_ALL , accessRights cannot included IOWA_ACL_CREATE_RIGHT . IOWA_COAP_403_FORBIDDEN : either: : objectId is IOWA_LWM2M_ID_ALL . : serverId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : either: : objectId does not refer to a supported Object. : if instanceId is not IOWA_LWM2M_ID_ALL , instanceId does not refer to an instanciated Object Instance. : serverId does not refer to a known Server Short ID nor IOWA_ACL_DEFAULT_ID . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_access_control_list.h Notes accessRights is a bit field which can contain the following values: IOWA_ACL_NONE_RIGHT : No access IOWA_ACL_READ_RIGHT : Read access IOWA_ACL_WRITE_RIGHT : Write access IOWA_ACL_EXECUTE_RIGHT : Execute access IOWA_ACL_DELETE_RIGHT : Delete access IOWA_ACL_CREATE_RIGHT : Create access If access rights are already set for the targeted objectId , instanceId and serverId , they will be overwritten. Access rights set through iowa_client_acl_rights_server_set() cannot be modified by any Server, since the Server Owner ID will be IOWA_LWM2M_ID_ALL (means Bootstrap Server). To set the default access rights, serverId can be IOWA_ACL_DEFAULT_ID . \\clearpage iowa_client_acl_rights_server_clear \u00b6 Prototype iowa_status_t iowa_client_acl_rights_server_clear ( iowa_context_t contextP , uint16_t objectId , uint16_t instanceId , uint16_t serverId ); Description iowa_client_acl_rights_server_clear() unset the access rights for a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectId : ID of the Object. instanceId : ID of the Object Instance. serverId : Short Server ID of a LwM2M Server or IOWA_ACL_DEFAULT_ID . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : objectId or serverId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : objectId , instanceId or serverId do not have access rights set. Header File objects/iowa_access_control_list.h \\clearpage iowa_client_acl_rights_object_clear \u00b6 Prototype iowa_status_t iowa_client_acl_rights_object_clear ( iowa_context_t contextP , uint16_t objectId , uint16_t instanceId ); Description iowa_client_acl_rights_object_clear() clears the access rights for an Object/Object Instance. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectId : ID of the Object. instanceId : ID of the Object Instance. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : objectId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : objectId or instanceId do not have access rights set. Header File objects/iowa_access_control_list.h \\clearpage APN Connection Profile Object API \u00b6 This LwM2M object specifies resources to enable a device to connect to an APN. To be able to use this object, iowa_apn_connection_profile.h must be included. Data Structures and Constants \u00b6 iowa_apn_connection_profile_details_t \u00b6 typedef struct { char * apn ; bool autoSelect ; bool enableStatus ; uint8_t authenticationType ; char * userName ; char * secret ; char * reconnectSchedule ; char ** validityList ; uint16_t validityNumber ; uint32_t * connectionEstablishmentTimeList ; uint16_t connectionEstablishmentTimeNumber ; uint8_t * connectionEstablishmentResultList ; uint16_t connectionEstablishmentResultNumber ; uint8_t * connectionEstablishmentRejectCauseList ; uint16_t connectionEstablishmentRejectCauseNumber ; uint32_t * connectionEndTimeList ; uint16_t connectionEndTimeNumber ; uint32_t totalBytesSent ; uint32_t totalBytesReceived ; char ** ipAddressList ; uint16_t ipAddressNumber ; char ** prefixLengthList ; uint16_t prefixLengthNumber ; char ** subnetMaskList ; uint16_t subnetMaskNumber ; char ** gatewayList ; uint16_t gatewayNumber ; char ** primaryDnsAddressList ; uint16_t primaryDnsAddressNumber ; char ** secondaryDnsAddressList ; uint16_t secondaryDnsAddressNumber ; uint8_t qci ; uint32_t totalPacketsSent ; uint8_t pdnType ; uint32_t apnRateControl ; } iowa_apn_connection_profile_details_t ; apn : APN of the APN connection profile. autoSelect : It enables the device to choose an APN according to a device specific algorithm. enableStatus : Allows the profile to be remotely activated or deactivated. authenticationType : 0: PAP, 1: CHAP, 2: PAP or CHAP, 3: None. userName : Used with e.g. PAP. secret : Used with e.g. PAP. reconnectSchedule : List of retry delay values in seconds to be used in case of unsuccessful connection establishment attempts. validity : Coma separated mobile country code, then mobile network code. connectionEstablishmentTime : UTC time of connection request. connectionEstablishmentResult : 0 = accepted, 1 = rejected. connectionEstablishmentRejectCause : Reject cause. connectionEndTime : UTC time of connection end. totalBytesSent : Rolling counter for total number of bytes sent via this interface since last device reset. totalBytesReceived : Rolling counter for total number of bytes sent via this interface since last device reset. ipAddress : May be IPv4 or IPv6 address. prefixLength : Associated with IPv6 address. subnetMask : Subnet mask. gateway : Gateway. primaryDnsAddress : Primary DNS address. secondaryDnsAddress : Secondary DNS address. qci : Quality of service Class Identifier. For LTE and NB-IoT only. totalPacketsSent : Rolling counter for total number of packets sent via this interface since last device reset. pdnType : 0=Non-IP, 1=IPv4, 2=IPv6, 3=IPv4v6. apnRateControl : Number of allowed uplink PDU transmissions per time interval per APN. \\clearpage Callbacks \u00b6 iowa_apn_connection_profile_update_callback_t \u00b6 This callback is called when the Server writes new information on the APN connection profile object. typedef iowa_status_t ( * iowa_apn_connection_profile_update_callback_t )( char * profileName , iowa_dm_operation_t operation , uint32_t flags , iowa_apn_connection_profile_details_t * detailsP , void * userDataCallback , iowa_context_t contextP ); profileName : Unique name of the APN connection profile. This may be new. operation : The operation performed by the Server on this APN connection profile (creation, deletion, or write). flags : Specify values set in detailsP. detailsP : APN connection profile details. This may be nil. userDataCallback : User data callback. contextP : The IOWA context. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage API \u00b6 iowa_client_enable_apn_connection_profile_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_enable_apn_connection_profile_object ( iowa_context_t contextP , iowa_apn_connection_profile_update_callback_t updateCallback , void * userDataCallback ); Description \u00b6 iowa_client_enable_apn_connection_profile_object() enables APN connection profiles management. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. updateCallback : Called to update state of the APN connection profile. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no update state callback provided means updateCallback is nil. IOWA_COAP_409_CONFLICT : APN connection profiles management was already enabled. Call first iowa_client_disable_apn_connection_profile_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_apn_connection_profile.h Notes \u00b6 Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... \\clearpage iowa_client_disable_apn_connection_profile_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_disable_apn_connection_profile_object ( iowa_context_t contextP ); Description \u00b6 iowa_client_disable_apn_connection_profile_object() disables APN connection profiles management. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : APN connection profiles management was not enabled. iowa_client_enable_apn_connection_profile_object() was not called before, or failed. Header File \u00b6 objects/iowa_apn_connection_profile.h \\clearpage iowa_client_add_apn_connection_profile \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_apn_connection_profile ( iowa_context_t contextP , const char * profileName , uint32_t optFlags , iowa_apn_connection_profile_details_t * detailsP ); Description \u00b6 iowa_client_add_apn_connection_profile() add an APN connection profile. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. profileName : Unique name of the APN connection profile. optFlags : Optional flags to add optional resources. detailsP : Apn connection profile details. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : inconsistent data inside detailsP . IOWA_COAP_406_NOT_ACCEPTABLE : either: : - no profile name provided means profileName is nil. : - no details provided means detailsP is nil. : - authenticationType 's value is outside the [0, 3] range. : - connectionEstablishmentResult 's value is different of 0 or 1. : - connectionEstablishmentRejectCause 's value is outside the [0, 111] range. : - qci 's value is outside the [0, 9] range. : - pdnType 's value is outside the [0, 3] range. IOWA_COAP_409_CONFLICT : APN connection profile with profileName already exists. IOWA_COAP_412_PRECONDITION_FAILED : APN connection profile management was not enabled. Call first iowa_client_enable_apn_connection_profile_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_apn_connection_profile.h Notes \u00b6 When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_APN_CONNECTION_PROFILE_RSC_APN IOWA_APN_CONNECTION_PROFILE_RSC_AUTO_SELECT_APN_DEVICE IOWA_APN_CONNECTION_PROFILE_RSC_ENABLE_STATUS IOWA_APN_CONNECTION_PROFILE_RSC_USER_NAME IOWA_APN_CONNECTION_PROFILE_RSC_SECRET IOWA_APN_CONNECTION_PROFILE_RSC_RECONNECT_SCHEDULE IOWA_APN_CONNECTION_PROFILE_RSC_VALIDITY IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_TIME IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_RESULT IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_REJECT_CAUSE IOWA_APN_CONNECTION_PROFILE_RSC_CONNECTION_END_TIME IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_SENT IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_RECEIVED IOWA_APN_CONNECTION_PROFILE_RSC_IP_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_PREFIX_LENGTH IOWA_APN_CONNECTION_PROFILE_RSC_SUBNET_MASK IOWA_APN_CONNECTION_PROFILE_RSC_GATEWAY IOWA_APN_CONNECTION_PROFILE_RSC_PRIMARY_DNS_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_SECONDARY_DNS_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_QCI IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_PACKETS_SENT IOWA_APN_CONNECTION_PROFILE_RSC_PDN_TYPE IOWA_APN_CONNECTION_PROFILE_RSC_APN_RATE_CONTROL \\clearpage iowa_client_remove_apn_connection_profile \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_apn_connection_profile ( iowa_context_t contextP , const char * profileName ); Description \u00b6 iowa_client_remove_apn_connection_profile() removes an APN connection profile created with iowa_client_add_apn_connection_profile() . Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. profileName : Unique name of the APN connection profile. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : profileName does not match any known APN connection profile. IOWA_COAP_406_NOT_ACCEPTABLE : no profile name provided meaning profileName is nil. IOWA_COAP_412_PRECONDITION_FAILED : APN connection profile management was not enabled. Call first iowa_client_enable_apn_connection_profile_object() . Header File \u00b6 objects/iowa_apn_connection_profile.h \\clearpage iowa_client_update_apn_connection_profile \u00b6 Prototype \u00b6 iowa_status_t iowa_client_update_apn_connection_profile ( iowa_context_t contextP , const char * profileName , uint32_t flags , iowa_apn_connection_profile_details_t * detailsP ); Description \u00b6 iowa_client_update_apn_connection_profile() updates an APN connection profile. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. profileName : Unique name of the APN connection profile. flags : Specify resources to update. detailsP : The APN connection profile details. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : inconsistent data inside detailsP . IOWA_COAP_404_NOT_FOUND : APN connection profile does not exist. Add first the profile with iowa_client_add_apn_connection_profile() . IOWA_COAP_406_NOT_ACCEPTABLE : either: : - no profile name provided means profileName is nil. : - no details provided means detailsP is nil. : - authenticationType 's value is outside the [0, 3] range. : - connectionEstablishmentResult 's value is different of 0 or 1. : - connectionEstablishmentRejectCause 's value is outside the [0, 111] range. : - qci 's value is outside the [0, 9] range. : - pdnType 's value is outside the [0, 3] range. IOWA_COAP_412_PRECONDITION_FAILED : APN connection profile management was not enabled. Call first iowa_client_enable_apn_connection_profile_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_apn_connection_profile.h Notes \u00b6 To specify resources to update, you can use the following flags: IOWA_APN_CONNECTION_PROFILE_RSC_APN IOWA_APN_CONNECTION_PROFILE_RSC_AUTO_SELECT_APN_DEVICE IOWA_APN_CONNECTION_PROFILE_RSC_ENABLE_STATUS IOWA_APN_CONNECTION_PROFILE_RSC_AUTHENTICATION_TYPE IOWA_APN_CONNECTION_PROFILE_RSC_USER_NAME IOWA_APN_CONNECTION_PROFILE_RSC_SECRET IOWA_APN_CONNECTION_PROFILE_RSC_RECONNECT_SCHEDULE IOWA_APN_CONNECTION_PROFILE_RSC_VALIDITY IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_TIME IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_RESULT IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_REJECT_CAUSE IOWA_APN_CONNECTION_PROFILE_RSC_CONNECTION_END_TIME IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_SENT IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_RECEIVED IOWA_APN_CONNECTION_PROFILE_RSC_IP_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_PREFIX_LENGTH IOWA_APN_CONNECTION_PROFILE_RSC_SUBNET_MASK IOWA_APN_CONNECTION_PROFILE_RSC_GATEWAY IOWA_APN_CONNECTION_PROFILE_RSC_PRIMARY_DNS_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_SECONDARY_DNS_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_QCI IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_PACKETS_SENT IOWA_APN_CONNECTION_PROFILE_RSC_PDN_TYPE IOWA_APN_CONNECTION_PROFILE_RSC_APN_RATE_CONTROL \\clearpage iowa_client_get_apn_connection_profile_object_link \u00b6 Prototype \u00b6 iowa_status_t iowa_client_get_apn_connection_profile_object_link ( iowa_context_t contextP , const char * profileName , iowa_lwm2m_object_link_t * objectLinkP ); Description \u00b6 iowa_client_get_apn_connection_profile_object_link() retrieves the LwM2M Object Link to an APN connection profile. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. profileName : Unique name of the APN connection profile. objectLinkP : Pointer to an iowa_lwm2m_object_link_t where to store the LwM2M Object Link to the APN connection profile. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : APN connection profile does not exist. Add first the profile with iowa_client_add_apn_connection_profile() . IOWA_COAP_406_NOT_ACCEPTABLE : profileName or objectLinkP is nil. IOWA_COAP_412_PRECONDITION_FAILED : APN connection profile management was not enabled. Call first iowa_client_enable_apn_connection_profile_object() . Header File \u00b6 objects/iowa_apn_connection_profile.h Notes \u00b6 This function is useful to fill the activatedProfileNamesList field of the iowa_cellular_connectivity_info_t structure. \\clearpage AT Command Object API \u00b6 This LwM2M object can be used to execute an AT command on a cellular modem. To be able to use this object, iowa_at_command.h must be included. Callbacks \u00b6 iowa_at_command_run_t \u00b6 This callback is used to execute an AT command. typedef iowa_status_t ( * iowa_at_command_run_t )( iowa_sensor_t id , char * command , int timeout , void * userDataCallback , iowa_context_t contextP ); id : ID of the object. command : The AT command to run. timeout : Amount of time in seconds allowed for the modem to respond to the command. userDataCallback : Application specific data from iowa_client_add_at_command_object . Can be nil. contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. Header File \u00b6 objects/iowa_at_command.h \\clearpage API \u00b6 iowa_client_add_at_command_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_at_command_object ( iowa_context_t contextP , uint16_t optFlags , iowa_at_command_run_t run , void * userDataCallback , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_at_command_object() creates an AT Command object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. run : Called to send an AT command to the modem. userDataCallback : Application specific data pass to the callback. Can be nil. idP : Used to store the ID of the object. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no run callback provided means run is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_at_command.h Notes \u00b6 Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_AT_COMMAND_RSC_TIMEOUT \\clearpage iowa_client_remove_at_command_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_at_command_object ( iowa_context_t contextP , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_at_command_object() removes an AT Command object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an AT Command object. Valid id are only returned by iowa_client_add_at_command_object() . IOWA_COAP_404_NOT_FOUND : AT Command referred by id does not exist. Header File \u00b6 objects/iowa_at_command.h \\clearpage iowa_client_at_command_set_response \u00b6 Prototype \u00b6 iowa_status_t iowa_client_at_command_set_response ( iowa_context_t contextP , iowa_sensor_t id , const char * command , const char * response , const char * status ); Description \u00b6 iowa_client_at_command_set_response() updates result values after having executed an AT command. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. command : The executed AT command. response : Response to the command. status : Status of the command execution as returned by the modem. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an AT Command object. Valid id are only returned by iowa_client_add_at_command_object() . IOWA_COAP_404_NOT_FOUND : AT Command referred by id does not exist. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_at_command.h Notes \u00b6 response and status can spread on multiple lines. To reset response and status update their values with empty string : - iowa_client_at_command_set_response(contextP, Id, NULL, NULL, \"\"); to reset the AT command's status. - iowa_client_at_command_set_response(contextP, Id, NULL, \"\", NULL); to reset the AT command's response. \\clearpage Bearer Selection Object API \u00b6 This LwM2M object allows via remote bearer and network configuration to overwrite automatic network and bearer selection e.g. as supported by the UICC. To be able to use this object, iowa_bearer_selection.h must be included. Data Structures and Constants \u00b6 iowa_bearer_selection_info_t \u00b6 typedef struct { uint8_t * preferredCommBearerList ; uint16_t preferredCommBearerNumber ; int8_t acceptableGsm ; int8_t acceptableUmts ; int16_t acceptableLte ; int16_t acceptableEvDo ; char * cellLockList ; char * operatorList ; bool operatorListMode ; char * availablePlmns ; int16_t acceptableRsrpNbIot ; int32_t plmnSearchTimer ; bool attachWoPdnConnection ; } iowa_bearer_selection_info_t ; preferredCommBearer : Preferred communications bearer. acceptableGsm : Provides guide to the application when performing manual network selection. acceptableUmts : Provides guide to the application when performing manual network selection. acceptableLte : Provides guide to the application when performing manual network selection. acceptableEvDo : Provides guide to the application when performing manual network selection. cellLockList : List of allowed Global Cell Identities. operatorList : List of MCC+MNC of operators, in priority order. operatorListMode : Indicates whether resource operator list represents the allowed operator list (white list), or, the preferred operator list. availablePlmns : Allows server to see results of network scan. acceptableRsrpNbIot : Provides guide to the application when performing manual network selection. plmnSearchTimer : Interval between periodic searches for higher priority PLMNs. attachWoPdnConnection : 0=attach with PDN connection, 1=attach without PDN connection \\clearpage Callbacks \u00b6 iowa_bearer_selection_update_state_callback_t \u00b6 This callback is called when the Server writes new information on the Bearer selection object. typedef iowa_status_t ( * iowa_bearer_selection_update_state_callback_t ) ( iowa_sensor_t id , iowa_bearer_selection_info_t * infoP , void * userDataCallback , iowa_context_t contextP ); id : The instance of the Bearer selection. infoP : The bearer selection info. userDataCallback : The user data callback. contextP : The IOWA context. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage API \u00b6 iowa_client_add_bearer_selection_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_bearer_selection_object ( iowa_context_t contextP , uint16_t optFlags , iowa_bearer_selection_update_state_callback_t updateStateCallback , void * userDataCallback , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_bearer_selection_object() creates a Bearer selection object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. updateStateCallback : Called to update state of the bearer selection. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. idP : Used to store the ID of the object. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - optFlags is equals to zero. : - no update state callback provided means updateStateCallback is nil. IOWA_COAP_409_CONFLICT : a bearer selection object already exists. To reconfigure the bearer selection object, call first iowa_client_remove_bearer_selection_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_bearer_selection.h Notes \u00b6 Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... Since this object has no mandatory resource, at least one optional resource must be used. To add optional resources, you can use the following flags: IOWA_BEARER_SELECTION_RSC_PREFERRED_COMM_BEARER IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_GSM IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSCP_UMTS IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_LTE IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_EV_DO IOWA_BEARER_SELECTION_RSC_CELL_LOCK_LIST IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST_MODE IOWA_BEARER_SELECTION_RSC_AVAILABLE_PLMNS IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_NB_IOT IOWA_BEARER_SELECTION_RSC_PLMN_SEARCH_TIMER IOWA_BEARER_SELECTION_RSC_ATTACH_WO_PDN_CONNECTION \\clearpage iowa_client_remove_bearer_selection_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_bearer_selection_object ( iowa_context_t contextP , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_bearer_selection_object() removes a Bearer selection object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a bearer selection object. Valid id are only returned by iowa_client_add_bearer_selection_object() . IOWA_COAP_404_NOT_FOUND : bearer selection referred by id does not exist. Header File \u00b6 objects/iowa_bearer_selection.h \\clearpage iowa_client_bearer_selection_update \u00b6 Prototype \u00b6 iowa_status_t iowa_client_bearer_selection_update ( iowa_context_t contextP , iowa_sensor_t id , uint16_t flags , iowa_bearer_selection_info_t * infoP ); Description \u00b6 iowa_client_bearer_selection_update() updates the Bearer selection information. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. flags : Optional flags to update resources. info : The Bearer selection information to update. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a bearer selection object. Valid id are only returned by iowa_client_add_bearer_selection_object() . IOWA_COAP_404_NOT_FOUND : bearer selection referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - acceptableGsm 's value is outside the [-48, -110] range. : - acceptableUmts 's value is outside the [-25, -120] range. : - acceptableLte 's value is outside the [-44, -140] range. : - acceptableRsrpNbIot 's value is outside the [-44, -158] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_bearer_selection.h Notes \u00b6 To specify resources to update, you can use the following flags: IOWA_BEARER_SELECTION_RSC_PREFERRED_COMM_BEARER IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_GSM IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSCP_UMTS IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_LTE IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_EV_DO IOWA_BEARER_SELECTION_RSC_CELL_LOCK_LIST IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST_MODE IOWA_BEARER_SELECTION_RSC_AVAILABLE_PLMNS IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_NB_IOT IOWA_BEARER_SELECTION_RSC_PLMN_SEARCH_TIMER IOWA_BEARER_SELECTION_RSC_ATTACH_WO_PDN_CONNECTION \\clearpage Cellular Connectivity Object API \u00b6 This LwM2M object specifies resources to enable a device to connect to a 3GPP or 3GPP2 bearer, including GPRS/EDGE, UMTS, LTE, NB-IoT, SMS. To be able to use this object, iowa_cellular_connectivity.h must be included. Data Structures and Constants \u00b6 iowa_cellular_connectivity_info_t \u00b6 typedef struct { iowa_lwm2m_object_link_t * activatedProfileNamesList ; uint16_t activatedProfileNamesNumber ; char * smsc ; int32_t disableRadioPeriod ; char * moduleActivationCode ; int32_t psmTimer ; int32_t activeTimer ; uint32_t servingPlmnRateControl ; char * edrxParamIuMode ; char * edrxParamWbS1Mode ; char * edrxParamNbS1Mode ; char * edrxParamAGbmMode ; } iowa_cellular_connectivity_info_t ; activatedProfileNamesList : list of links to instances of the APN connection profile object representing every APN connection profile that has an activated connection to a PDN. activatedProfileNamesNumber : number of links to instances of the APN connection profile object representing every APN connection profile that has an activated connection to a PDN. smsc : address of the sms center. disableRadioPeriod : time period for which the device shall disconnect from cellular radio. moduleActivationCode : configurable in case the application needs to issue a code. psmTimer : Power Saving Mode timer. activeTimer : active timer. servingPlmnRateControl : maximum number of allowed uplink PDU transmissions. edrxParamIuMode : Extended DRX parameters for lu mode. edrxParamWbS1Mode : Extended DRX parameters for WB-S1 mode. edrxParamNbS1Mode : Extended DRX parameters for NB-S1 mode. edrxParamAGbmMode : Extended DRX parameters for A/Gb mode. \\clearpage Callbacks \u00b6 iowa_cellular_connectivity_update_state_callback_t \u00b6 This callback is called when the Server writes new information on the Cellular connectivity object. typedef iowa_status_t ( * iowa_cellular_connectivity_update_state_callback_t )( iowa_sensor_t id , iowa_cellular_connectivity_info_t * infoP , void * userDataCallback , iowa_context_t contextP ); id : The instance of the Cellular connectivity. infoP : The Cellular connectivity info. userDataCallback : The user data callback. contextP : The IOWA context. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage API \u00b6 iowa_client_add_cellular_connectivity_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_cellular_connectivity_object ( iowa_context_t contextP , uint16_t optFlags , iowa_cellular_connectivity_update_state_callback_t updateStateCallback , void * userDataCallback , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_cellular_connectivity_object() creates a Cellular connectivity object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. updateStateCallback : Called to update state of the cellular connectivity. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. idP : Used to store the ID of the object. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no update state callback provided means updateStateCallback is nil. IOWA_COAP_409_CONFLICT : a cellular connectivity object already exists. Call first iowa_client_remove_cellular_connectivity_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_cellular_connectivity.h Notes \u00b6 Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_CELLULAR_CONNECTIVITY_RSC_SMSC_ADDRESS IOWA_CELLULAR_CONNECTIVITY_RSC_DISABLE_RADIO_PERIOD IOWA_CELLULAR_CONNECTIVITY_RSC_MODULE_ACTIVATION_CODE IOWA_CELLULAR_CONNECTIVITY_RSC_PSM_TIMER IOWA_CELLULAR_CONNECTIVITY_RSC_ACTIVE_TIMER IOWA_CELLULAR_CONNECTIVITY_RSC_PLMN_RATE_CONTROL IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_IU_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_WB_S1_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_NB_S1_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_A_GB_MODE \\clearpage iowa_client_remove_cellular_connectivity_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_cellular_connectivity_object ( iowa_context_t contextP , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_cellular_connectivity_object() removes a Cellular connectivity object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a cellular connectivity object. Valid id are only returned by iowa_client_add_cellular_connectivity_object() . IOWA_COAP_404_NOT_FOUND : cellular connectivity referred by id does not exist. Header File \u00b6 objects/iowa_cellular_connectivity.h \\clearpage iowa_client_cellular_connectivity_update \u00b6 Prototype \u00b6 iowa_status_t iowa_client_cellular_connectivity_update ( iowa_context_t contextP , iowa_sensor_t id , uint16_t flags , iowa_cellular_connectivity_info_t * infoP ); Description \u00b6 iowa_client_cellular_connectivity_update() updates the Cellular connectivity information. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. flags : Optional flags to update resources. infoP : The Cellular connectivity information to update. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a cellular connectivity object. Valid id are only returned by iowa_client_add_cellular_connectivity_object() . IOWA_COAP_404_NOT_FOUND : cellular connectivity referred by id does not exist. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_cellular_connectivity.h Notes \u00b6 To specify resources to update, you can use the following flags: IOWA_CELLULAR_CONNECTIVITY_RSC_SMSC_ADDRESS IOWA_CELLULAR_CONNECTIVITY_RSC_DISABLE_RADIO_PERIOD IOWA_CELLULAR_CONNECTIVITY_RSC_MODULE_ACTIVATION_CODE IOWA_CELLULAR_CONNECTIVITY_RSC_PSM_TIMER IOWA_CELLULAR_CONNECTIVITY_RSC_ACTIVE_TIMER IOWA_CELLULAR_CONNECTIVITY_RSC_PLMN_RATE_CONTROL IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_IU_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_WB_S1_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_NB_S1_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_A_GB_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_ACTIVATED_PROFILE_NAMES \\clearpage Connectivity Monitoring Object API \u00b6 This LwM2M Object enables monitoring of parameters related to network connectivity. To be able to use this object, iowa_connectivity_monitoring.h must be included. Data Structures and Constants \u00b6 iowa_connectivity_monitoring_info_t \u00b6 typedef struct { uint8_t networkBearer ; uint8_t * availableNetworkBearerList ; uint8_t availableNetworkBearerNumber ; int16_t radioSignalStrength ; int16_t linkQuality ; char ** ipAddressList ; uint16_t ipAddressNumber ; char ** routerIpAddressesList ; uint16_t routerIpAddressesNumber ; uint8_t linkUtilization ; char ** apnList ; uint16_t apnNumber ; uint64_t cellId ; uint16_t smnc ; uint16_t smcc ; } iowa_connectivity_monitoring_info_t ; networkBearer : Network bearer used for the current session. availableNetworkBearerList : List of current available network bearers. availableNetworkBearerNumber : Number of current available network bearers. radioSignalStrength : Average value of the received signal strength indication. linkQuality : Received link quality. ipAddressList : List of IP addresses assigned to the connectivity interface. ipAddressNumber : Number of IP addresses assigned to the connectivity interface. routerIpAddressesList : List of IP addresses of the next-hop IP router. routerIpAddressesNumber : Number of IP addresses of the next-hop IP router. linkUtilization : The percentage indicating the average utilization of the link to the next-hop IP router. apnList : List of Access Point Names. apnNumber : Number of Access Point Names. cellId : Serving Cell ID. smnc : Serving Mobile Network Code. smcc : Serving Mobile Country Code. \\clearpage API \u00b6 iowa_client_add_connectivity_monitoring_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_connectivity_monitoring_object ( iowa_context_t contextP , uint16_t optFlags , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_connectivity_monitoring_object() creates a Connectivity monitoring object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. idP : Used to store the ID of the object. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_409_CONFLICT : a connectivity monitoring object already exists. Call first iowa_client_remove_connectivity_monitoring_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_connectivity_monitoring.h Notes \u00b6 Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_CONNECTIVITY_MONITORING_RSC_LINK_QUALITY IOWA_CONNECTIVITY_MONITORING_RSC_ROUTER_IP_ADDR IOWA_CONNECTIVITY_MONITORING_RSC_LINK_USAGE IOWA_CONNECTIVITY_MONITORING_RSC_APN IOWA_CONNECTIVITY_MONITORING_RSC_CELL_ID IOWA_CONNECTIVITY_MONITORING_RSC_SMNC IOWA_CONNECTIVITY_MONITORING_RSC_SMCC \\clearpage iowa_client_remove_connectivity_monitoring_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_connectivity_monitoring_object ( iowa_context_t contextP , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_connectivity_monitoring_object() removes a Connectivity monitoring object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a connectivity monitoring object. Valid id are only returned by iowa_client_add_connectivity_monitoring_object() . IOWA_COAP_404_NOT_FOUND : connectivity monitoring referred by id does not exist. Header File \u00b6 objects/iowa_connectivity_monitoring.h \\clearpage iowa_client_connectivity_monitoring_update \u00b6 Prototype \u00b6 iowa_status_t iowa_client_connectivity_monitoring_update ( iowa_context_t contextP , iowa_sensor_t id , uint16_t flags , iowa_connectivity_monitoring_info_t * infoP ); Description \u00b6 iowa_client_connectivity_monitoring_update() updates the Connectivity monitoring information. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. flags : Optional flags to update resources. infoP : The Connectivity monitoring information to update. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a connectivity monitoring object. Valid id are only returned by iowa_client_add_connectivity_monitoring_object() . IOWA_COAP_404_NOT_FOUND : connectivity monitoring referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - networkBearer 's value is outside the [0, 50] range. : - availableNetworkBearerList 's value is outside the [0, 50] range. : - linkUtilization 's value is outside the [0, 100] range. : - smnc 's value is outside the [0, 999] range. : - smcc 's value is outside the [0, 999] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_connectivity_monitoring.h Notes \u00b6 To specify resources to update, you can use the following flags: IOWA_CONNECTIVITY_MONITORING_RSC_BEARER IOWA_CONNECTIVITY_MONITORING_RSC_AVAILABLE_BEARER IOWA_CONNECTIVITY_MONITORING_RSC_SIGNAL_STRENGTH IOWA_CONNECTIVITY_MONITORING_RSC_LINK_QUALITY IOWA_CONNECTIVITY_MONITORING_RSC_IP_ADDR IOWA_CONNECTIVITY_MONITORING_RSC_ROUTER_IP_ADDR IOWA_CONNECTIVITY_MONITORING_RSC_LINK_USAGE IOWA_CONNECTIVITY_MONITORING_RSC_APN IOWA_CONNECTIVITY_MONITORING_RSC_CELL_ID IOWA_CONNECTIVITY_MONITORING_RSC_SMNC IOWA_CONNECTIVITY_MONITORING_RSC_SMCC \\clearpage Connectivity Statistics Object API \u00b6 This LwM2M Object enables client to collect statistical information and enables the LwM2M Server to retrieve these information, set the collection duration and reset the statistical parameters. To be able to use this object, iowa_connectivity_stats.h must be included. iowa_client_add_connectivity_stats_object \u00b6 Prototype iowa_status_t iowa_client_add_connectivity_stats_object ( iowa_context_t context , uint16_t optFlags , iowa_sensor_t * idP ); Description iowa_client_add_connectivity_stats_object() creates a connectivity statistics object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_409_CONFLICT : a connectivity statistics object already exists. To reconfigure the connectivity statistics object, call first iowa_client_remove_connectivity_stats_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_connectivity_stats.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_CONNECTIVITY_STATS_RSC_SMS_TX_COUNTER IOWA_CONNECTIVITY_STATS_RSC_SMS_RX_COUNTER IOWA_CONNECTIVITY_STATS_RSC_TX_DATA IOWA_CONNECTIVITY_STATS_RSC_RX_DATA IOWA_CONNECTIVITY_STATS_RSC_MAX_MESSAGE_SIZE IOWA_CONNECTIVITY_STATS_RSC_AVERAGE_MESSAGE_SIZE IOWA_CONNECTIVITY_STATS_RSC_COLLECTION_PERIOD Moreover, you can add several optional resources at one time by using the following flags: IOWA_CONNECTIVITY_STATS_SMS IOWA_CONNECTIVITY_STATS_IP_DATA \\clearpage iowa_client_remove_connectivity_stats_object \u00b6 Prototype iowa_status_t iowa_client_remove_connectivity_stats_object ( iowa_context_t contextP , iowa_sensor_t id ); Description iowa_client_remove_connectivity_stats_object() removes a connectivity statistics object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a connectivity statistics object. Valid id are only returned by iowa_client_add_connectivity_stats_object() . IOWA_COAP_404_NOT_FOUND : no connectivity statistics object to remove. iowa_client_add_connectivity_stats_object() was not called before, or failed. Header File objects/iowa_connectivity_stats.h \\clearpage iowa_client_connectivity_stats_update_sms \u00b6 Prototype iowa_status_t iowa_client_connectivity_stats_update_sms ( iowa_context_t context , iowa_sensor_t id , uint8_t direction ); Description iowa_client_connectivity_stats_update_sms() updates the SMS TX or RX statistics. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object direction : Specify if this is a reception or a transmission trigger. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : Bad value for argument direction or id is not a connectivity statistics object. Valid id are only returned by iowa_client_add_connectivity_stats_object() . IOWA_COAP_404_NOT_FOUND : no connectivity statistics object added. Header File objects/iowa_connectivity_stats.h Notes Argument direction of iowa_client_connectivity_stats_update_sms() can be one of the following values: IOWA_CONNECTIVITY_STATS_TX (0) IOWA_CONNECTIVITY_STATS_RX (1) \\clearpage iowa_client_connectivity_stats_update_ip_data \u00b6 Prototype iowa_status_t iowa_client_connectivity_stats_update_ip_data ( iowa_context_t context , iowa_sensor_t id , uint8_t direction , size_t length ); Description iowa_client_connectivity_stats_update_ip_data() updates the IP data statistics. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. direction : Specify if this is a reception or a transmission trigger. length : Length in bytes of the transmitted or received data. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : Bad value for argument direction or id is not a connectivity statistics object. Valid id are only returned by iowa_client_add_connectivity_stats_object() . IOWA_COAP_404_NOT_FOUND : no connectivity statistics object added. Header File objects/iowa_connectivity_stats.h Notes Argument direction of iowa_client_connectivity_stats_update_ip_data() can be one of the following values: IOWA_CONNECTIVITY_STATS_TX (0) IOWA_CONNECTIVITY_STATS_RX (1) \\clearpage Digital Output Object API \u00b6 This IPSO object represents generic digital output for non-specific actuators. To be able to use this object, iowa_digital_output.h must be included. Callbacks \u00b6 iowa_digital_output_state_callback_t \u00b6 This callback is used to update the state of the digital output. Request from a server to a client. typedef iowa_status_t ( * iowa_digital_output_state_callback_t )( iowa_sensor_t id , bool state , bool polarity , void * userDataCallback , iowa_context_t contextP ); id : ID of the object state : New state polarity : New polarity userDataCallback : Application specific data from iowa_client_add_digital_output_object . Can be nil. contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage API \u00b6 iowa_client_add_digital_output_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_digital_output_object ( iowa_context_t context , uint16_t optFlags , iowa_digital_output_state_callback_t updateStateCallback , void * userDataCallback , const char * applicationType , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_digital_output_object() creates a digital output object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. updateStateCallback : Called to update state of the digital output. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. applicationType : The application type idP : Used to store the ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no update state callback provided means updateStateCallback is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_digital_output.h Notes \u00b6 Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_DIGITAL_OUTPUT_STATS_RSC_POLARITY \\clearpage iowa_client_remove_digital_output_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_digital_output_object ( iowa_context_t context , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_digital_output_object() removes a digital output object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a digital output object. Valid id are only returned by iowa_client_add_digital_output_object() . IOWA_COAP_404_NOT_FOUND : digital output referred by id does not exist. Header File \u00b6 objects/iowa_digital_output.h \\clearpage iowa_client_digital_output_update_state \u00b6 Prototype \u00b6 iowa_status_t iowa_client_digital_output_update_state ( iowa_context_t context , iowa_sensor_t id , bool state , bool polarity ); Description \u00b6 iowa_client_digital_output_update_state() updates values of a digital output object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object state : New state polarity : New polarity Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a digital output object. Valid id are only returned by iowa_client_add_digital_output_object() . IOWA_COAP_404_NOT_FOUND : digital output referred by id does not exist. Header File \u00b6 objects/iowa_digital_output.h \\clearpage Dimmer Object API \u00b6 This IPSO object represents a dimmer. To be able to use this object, iowa_dimmer.h must be included. Callbacks \u00b6 iowa_dimmer_state_callback_t \u00b6 This callback is used to update the state of the dimmer. Request from a server to a client. typedef iowa_status_t ( * iowa_dimmer_state_callback_t )( iowa_sensor_t id , float level , void * userDataCallback , iowa_context_t contextP ); id : ID of the object level : New level. userDataCallback : Application specific data from iowa_client_add_dimmer_object . Can be nil. contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage API \u00b6 iowa_client_add_dimmer_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_dimmer_object ( iowa_context_t context , uint16_t optFlags , float level , iowa_dimmer_state_callback_t updateStateCallback , void * userDataCallback , const char * applicationType , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_dimmer_object() creates a dimmer object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. level : The initial value measured by the dimmer, must be inside the range [0.0; 100.0]. updateStateCallback : Called to update state of the dimmer. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. applicationType : The application type idP : Used to store the ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : level is outside the range [0.0; 100.0]. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. Header File \u00b6 objects/iowa_dimmer.h Notes \u00b6 Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_DIMMER_RSC_ON_TIME IOWA_DIMMER_RSC_OFF_TIME \\clearpage iowa_client_remove_dimmer_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_dimmer_object ( iowa_context_t context , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_dimmer_object() removes a dimmer object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a dimmer object. Valid id are only returned by iowa_client_add_dimmer_object() . IOWA_COAP_404_NOT_FOUND : dimmer referred by id does not exist. Header File \u00b6 objects/iowa_dimmer.h \\clearpage iowa_client_dimmer_update_value \u00b6 Prototype \u00b6 iowa_status_t iowa_client_dimmer_update_value ( iowa_context_t contextP , iowa_sensor_t id , float level ); Description \u00b6 iowa_client_dimmer_update_value() updates dimmer's level value. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object level : New level value, must be inside the range [0.0; 100.0]. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a dimmer object. Valid id are only returned by iowa_client_add_dimmer_object() . IOWA_COAP_404_NOT_FOUND : dimmer referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : level is outside the range [0.0; 100.0]. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a call to iowa_system_gettime() failed. Header File \u00b6 objects/iowa_dimmer.h \\clearpage iowa_client_dimmer_update_values \u00b6 Prototype \u00b6 iowa_status_t iowa_client_dimmer_update_values ( iowa_context_t contextP , iowa_sensor_t id , size_t valueCount , iowa_ipso_timed_value_t * valueArray ); Description \u00b6 iowa_client_dimmer_update_values() updates dimmer's level value. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object valueCount : The number of values in valueArray . valueArray : The iowa_ipso_timed_value_t list of new level values. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a dimmer object. Valid id are only returned by iowa_client_add_dimmer_object() . IOWA_COAP_404_NOT_FOUND : dimmer referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : at least one valueArray value is outside the range [0.0; 100.0]. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed when either: : - the new level array's last value is greater than 0 and the previous one is 0. : - the new level array's last value is 0 and the previous one is greater than 0. Header File \u00b6 objects/iowa_dimmer.h \\clearpage Firmware Update Object API \u00b6 This LwM2M Object enables management of firmware which is to be updated. To be able to use this object, iowa_firmware_update.h must be included and IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT must be defined before building the library. The [ Device Update ][Device Update]/[ Firmware Update ][Firmware Update] part of this specification adds more explanation about its mechanism and how to use it with IOWA. Data Structures and Constants \u00b6 iowa_fw_status_t \u00b6 This is an enumeration of the following values: IOWA_FW_STATUS_SUCCESSFUL : success of the new firmware package download or of the firmware update. IOWA_FW_STATUS_OUT_OF_STORAGE : not enough storage for the new firmware package. ( downloadCb only) IOWA_FW_STATUS_OUT_OF_MEMORY : out of memory error during the download of the new firmware package. ( downloadCb only) IOWA_FW_STATUS_CONNECTION_LOST : connection lost during the download of the new firmware package. ( downloadCb only) IOWA_FW_STATUS_INTEGRITY_CHECK_FAILURE : integrity check failure of the new firmware package. IOWA_FW_STATUS_UNSUPPORTED_TYPE : unsupported new firmware package type. IOWA_FW_STATUS_INVALID_URI : invalid URI to download the new firmware package. ( downloadCb only) IOWA_FW_STATUS_UPDATE_FAILED : firmware update failed. ( updateCb only) IOWA_FW_STATUS_UNSUPPORTED_PROTOCOL : unsupported protocol in URI to download the new firmware package. ( downloadCb only) \\clearpage Callbacks \u00b6 iowa_fw_download_callback_t \u00b6 This callback is called when the Server requests the device to download a new Firmware Package. typedef void ( * iowa_fw_download_callback_t ) ( char * uri , void * userData , iowa_context_t contextP ); uri : The URI to download the package from. userData : The parameter to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. uri can be nil. In this case, a current download must be aborted. \\clearpage iowa_fw_write_callback_t \u00b6 This callback is called several times when the Server pushes the new Firmware Package to the device. The expected behavior is the same as writing to a file stream i.e. unless it is reset, written data are appended to the previous ones. typedef iowa_fw_status_t ( * iowa_fw_write_callback_t ) ( iowa_fw_write_cmd_t cmd , size_t dataLength , uint8_t * data , void * userData , iowa_context_t contextP ); At the start of the push of the Firmware Package or if the LwM2M Server cancels it, this callback is called with the following parameters: cmd : IOWA_FW_PACKAGE_RESET dataLength : 0 data : NULL userData : The parameter to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. When the Firmware Package is received, this callback is called several times with the following parameters: cmd : IOWA_FW_PACKAGE_WRITE dataLength : The length of the buffer pointed by data . data : The next chunk of the Firmware Package to write. userData : The parameter to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. At the end of the push of the Firmware package, this callback is called with the following parameters: cmd : IOWA_FW_PACKAGE_WRITE dataLength : 0 data : NULL userDataP : The data passed to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. Return Value \u00b6 IOWA_FW_STATUS_SUCCESSFUL : success. IOWA_FW_STATUS_OUT_OF_STORAGE : not enough storage for the new Firmware Package. IOWA_FW_STATUS_OUT_OF_MEMORY : out of memory error. IOWA_FW_STATUS_INTEGRITY_CHECK_FAILURE : integrity check failure of the new Firmware Package. IOWA_FW_STATUS_UNSUPPORTED_TYPE : unsupported new Firmware Package type. \\clearpage iowa_fw_update_callback_t \u00b6 This callback is called when the Server requests the device to update itself with the new Firmware Package. typedef void ( * iowa_fw_update_callback_t ) ( void * userData , iowa_context_t contextP ); userData : The parameter to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. \\clearpage API \u00b6 iowa_client_firmware_update_configure \u00b6 Prototype \u00b6 iowa_status_t iowa_client_firmware_update_configure ( iowa_context_t contextP , const char * packageName , const char * packageVersion , iowa_fw_download_callback_t downloadCb , iowa_fw_write_callback_t writeCb , iowa_fw_update_callback_t updateCb , void * userData ); Description \u00b6 iowa_client_firmware_update_configure() configures the firmware update feature of the IOWA stack. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. packageName : The user-defined name of the current firmware. This can be nil. packageVersion : The user-defined version of the current firmware. This can be nil. downloadCb : The callback called to download a new firmware. This can be nil. writeCb : The callback called to write chunks of the new firmware to the device storage. This can be nil. updateCb : The callback called to update the device with the new firmware. userData : Passed as argument to the callbacks. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_400_BAD_REQUEST : either: : - updateCb is nil. : - both downloadCb and writeCb are nil. At least one must be defined. IOWA_COAP_409_CONFLICT : the firmware update feature is already configured. Header File \u00b6 objects/iowa_firmware_update.h Notes \u00b6 The LwM2M Server has two methods to provide the Firmware Package: the pull method: the LwM2M Server provides the URI of the Firmware Package and the LwM2M Client downloads it directly. To use this method, downloadCb must be set. the push method: the LwM2M Server writes the Firmware Package in a LwM2M Resource exposed by the Client. To use this method, writeCb must be set. The Client can support both methods at the same time. downloadCb and updateCb do not return any value. The progress and result of their operation are indicated asynchronously by calling iowa_client_firmware_update_set_status() . \\clearpage iowa_client_firmware_update_configure_full \u00b6 Prototype \u00b6 iowa_status_t iowa_client_firmware_update_configure_full ( iowa_context_t contextP , const char * packageName , const char * packageVersion , uint8_t protocolSupport , iowa_fw_download_callback_t downloadCb , iowa_fw_write_callback_t writeCb , iowa_fw_update_callback_t updateCb , void * userData ); Description \u00b6 iowa_client_firmware_update_configure_full() configures the firmware update feature of the IOWA stack with the \"protocol support\" resource. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. packageName : The user-defined name of the current firmware. This can be nil. packageVersion : The user-defined version of the current firmware. This can be nil. protocolSupport : A bit-mask indicating supported protocols in downloadCb . This can be 0. downloadCb : The callback called to download a new firmware. This can be nil. writeCb : The callback called to write chunks of the new firmware to the device storage. This can be nil. updateCb : The callback called to update the device with the new firmware. userData : Passed as argument to the callbacks. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_400_BAD_REQUEST : either: : - updateCb is nil. : - both downloadCb and writeCb are nil. : - downloadCb is nil and protocolSupport is not 0. IOWA_COAP_409_CONFLICT : the firmware update feature is already configured. Header File \u00b6 objects/iowa_firmware_update.h Notes \u00b6 protocolSupport is a combination of the following: IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_COAP : Constrained Application Protocol (CoAP) IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_COAPS : DTLS-Secured CoAP IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_HTTP : HTTP 1.1 IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_HTTPS : TLS-Secured HTTP 1.1 IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_COAP_TCP : CoAP over TCP IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_COAP_TLS : CoAP over TLS \\clearpage iowa_client_firmware_update_set_status \u00b6 Prototype \u00b6 iowa_status_t iowa_client_firmware_update_set_status ( iowa_context_t contextP , iowa_fw_status_t status ); Description \u00b6 iowa_client_firmware_update_set_status() informs the IOWA stack of the result of the callbacks downloadCb and updateCb of iowa_client_firmware_update_configure() . Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. status : The result of the current firmware update operation. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : the firmware update feature is not configured. Call first iowa_client_firmware_update_configure() . IOWA_COAP_412_PRECONDITION_FAILED : the value of status is unexpected. See iowa_fw_status_t for the possible value depending of the context. Header File \u00b6 objects/iowa_firmware_update.h \\clearpage GPS Object API \u00b6 This IPSO object represents GPS coordinates. To be able to use this object, iowa_gps.h must be included. iowa_client_add_gps_object \u00b6 Prototype iowa_status_t iowa_client_add_gps_object ( iowa_context_t context , uint16_t optFlags , const char * applicationType , iowa_sensor_t * idP ); Description iowa_client_add_gps_object() creates a GPS object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. applicationType : The application type idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_gps.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_GPS_RSC_UNCERTAINTY IOWA_GPS_RSC_COMPASS_DIRECTION IOWA_GPS_RSC_VELOCITY IOWA_GPS_RSC_TIMESTAMP \\clearpage iowa_client_remove_gps_object \u00b6 Prototype iowa_status_t iowa_client_remove_gps_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_gps_object() removes a GPS object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a GPS object. Valid id are only returned by iowa_client_add_gps_object() . IOWA_COAP_404_NOT_FOUND : GPS referred by id does not exist. Header File objects/iowa_gps.h \\clearpage iowa_client_gps_update_location \u00b6 Prototype iowa_status_t iowa_client_gps_update_location ( iowa_context_t context , iowa_sensor_t id , const char * latitude , const char * longitude ); Description iowa_client_gps_update_location() updates values of a GPS object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object latitude : New latitude longitude : New longitude Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a GPS object. Valid id are only returned by iowa_client_add_gps_object() . IOWA_COAP_404_NOT_FOUND : GPS referred by id does not exist. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. Header File objects/iowa_gps.h \\clearpage iowa_client_gps_update_location_full \u00b6 Prototype iowa_status_t iowa_client_gps_update_location_full ( iowa_context_t context , iowa_sensor_t id , const char * latitude , const char * longitude , const char * uncertainty , float compassDirection , size_t velocityLength , uint8_t * velocity ); Description iowa_client_gps_update_location_full() updates values of a GPS object. Optionals resources are included. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object latitude : New latitude longitude : New longitude uncertainty : The accuracy of the position in meters. compassDirection : Measured Direction between 0 and 360 deg. velocityLength : Length of the velocity array velocity : The velocity of the device as defined in 3GPP 23.032 GAD specification. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a GPS object. Valid id are only returned by iowa_client_add_gps_object() . IOWA_COAP_404_NOT_FOUND : GPS referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : compassDirection 's value is outside the [0.0, 360.0] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. Header File objects/iowa_gps.h \\clearpage Gyrometer Object API \u00b6 This IPSO Object is used to report the current reading of a gyrometer sensor in 3 axes. To be able to use this object, iowa_gyrometer.h must be included. iowa_client_add_gyrometer_object \u00b6 Prototype iowa_status_t iowa_client_add_gyrometer_object ( iowa_context_t context , uint16_t optFlags , float minRangeValue , float maxRangeValue , const char * sensorUnits , const char * applicationType , iowa_sensor_t * idP ); Description iowa_client_add_gyrometer_object() creates a gyrometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. minRangeValue : Minimal range value for the gyrometer. maxRangeValue : Maximal range value for the gyrometer. sensorUnits : Measurement units definition applicationType : The application type idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : minRangeValue argument is superior to maxRangeValue argument. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_gyrometer.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_GYROMETER_RSC_Y_VALUE IOWA_GYROMETER_RSC_Z_VALUE IOWA_GYROMETER_RSC_MIN_X_VALUE IOWA_GYROMETER_RSC_MAX_X_VALUE IOWA_GYROMETER_RSC_MIN_Y_VALUE IOWA_GYROMETER_RSC_MAX_Y_VALUE IOWA_GYROMETER_RSC_MIN_Z_VALUE IOWA_GYROMETER_RSC_MAX_Z_VALUE IOWA_GYROMETER_RSC_RESET_MIN_MAX_VALUES IOWA_GYROMETER_RSC_MIN_RANGE_VALUE IOWA_GYROMETER_RSC_MAX_RANGE_VALUE Moreover, you can add several optional resources at one time by using the following flags: IOWA_GYROMETER_3_AXIS IOWA_GYROMETER_MIN_MAX_VALUES IOWA_GYROMETER_RANGE_VALUE \\clearpage iowa_client_remove_gyrometer_object \u00b6 Prototype iowa_status_t iowa_client_remove_gyrometer_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_gyrometer_object() removes a gyrometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a gyrometer object. Valid id are only returned by iowa_client_add_gyrometer_object() . IOWA_COAP_404_NOT_FOUND : gyrometer referred by id does not exist. Header File objects/iowa_gyrometer.h \\clearpage iowa_client_gyrometer_update_axis \u00b6 Prototype iowa_status_t iowa_client_gyrometer_update_axis ( iowa_context_t context , iowa_sensor_t id , float xValue , float yValue , float zValue ); Description iowa_client_gyrometer_update_axis() updates values of a gyrometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object xValue : X value axis yValue : Y value axis zValue : Z value axis Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a gyrometer object. Valid id are only returned by iowa_client_add_gyrometer_object() . IOWA_COAP_404_NOT_FOUND : gyrometer referred by id does not exist. Header File objects/iowa_gyrometer.h \\clearpage IPSO Objects \u00b6 This part allows the possibility to manipulate several IPSO Objects. To be able to use these objects, iowa_ipso.h must be included. iowa_client_IPSO_add_sensor \u00b6 Prototype iowa_status_t iowa_client_IPSO_add_sensor ( iowa_context_t contextP , iowa_IPSO_ID_t type , float value , const char * unit , const char * appType , float rangeMin , float rangeMax , iowa_sensor_t * idP ); Description iowa_client_IPSO_add_sensor() adds a new IPSO sensor for the LwM2M Client to handle. The sensor is defined by its type. The unit, the application type and the range are only informative and reported as-is to the LwM2M Server. Note that the LwM2M Server can modify the application type. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The type of sensor. See below. value : The initial value measured by the sensor. unit : The unit of the measured value as a nil-terminated string. This can be nil. appType : The application type of the sensor as a free-form nil-terminated string. This can be nil. rangeMin : The minimum value that can be measured by the sensor. rangeMax : The maximum value that can be measured by the sensor. idP : Used to store the ID of the created sensor. Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : type is unknown. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - the sensor uses a Boolean value and value is neither 0.0 nor 1.0. : - the sensor uses a percentage value and value is outside the [0.0, 100.0] range. : - the sensor uses a compass direction value and value is outside the [0.0, 360.0] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. Header File objects/iowa_ipso.h Notes If both rangeMin and rangeMax are set to zero, the matching resources are ignored in the LwM2M Object. unit is not duplicated nor freed by IOWA. Make sure it is available until iowa_close() or iowa_client_IPSO_remove_sensor() is called. It is advised to use static strings. appType is duplicated internally by IOWA and can be reused or freed by the caller. Only a call to iowa_client_IPSO_remove_sensor() can free the memory allocated by iowa_client_IPSO_add_sensor() . If type equal to IOWA_IPSO_LEVEL_CONTROL this function will call iowa_client_add_dimmer_object() . iowa_IPSO_ID_t \u00b6 This is an enumeration of the LwM2M IDs of the supported sensor types. See below. Float value sensors \u00b6 IOWA_IPSO_ANALOG_INPUT (3202) IOWA_IPSO_GENERIC (3300) IOWA_IPSO_ILLUMINANCE (3301) IOWA_IPSO_TEMPERATURE (3303) IOWA_IPSO_HUMIDITY (3304) IOWA_IPSO_BAROMETER (3315) IOWA_IPSO_VOLTAGE (3316) IOWA_IPSO_CURRENT (3317) IOWA_IPSO_FREQUENCY (3318) IOWA_IPSO_DEPTH (3319) IOWA_IPSO_PERCENTAGE (3320) IOWA_IPSO_ALTITUDE (3321) IOWA_IPSO_LOAD (3322) IOWA_IPSO_PRESSURE (3323) IOWA_IPSO_LOUDNESS (3324) IOWA_IPSO_CONCENTRATION (3325) IOWA_IPSO_ACIDITY (3326) IOWA_IPSO_CONDUCTIVITY (3327) IOWA_IPSO_POWER (3328) IOWA_IPSO_POWER_FACTOR (3329) IOWA_IPSO_RATE (3346) IOWA_IPSO_DISTANCE (3330) IOWA_IPSO_ENERGY (3331) Boolean value sensors \u00b6 For these sensors, the value must be either 0.0 or 1.0: IOWA_IPSO_DIGITAL_INPUT (3200) IOWA_IPSO_PRESENCE (3302) IOWA_IPSO_ON_OFF_SWITCH (3342) IOWA_IPSO_PUSH_BUTTON (3347) Percentage value sensors \u00b6 For these sensors, the value must be between 0.0 and 100.0: IOWA_IPSO_LEVEL_CONTROL (3343) Compass direction value sensors \u00b6 For these sensors, the value must be between 0.0 and 360.0: IOWA_IPSO_DIRECTION (3332) \\clearpage iowa_client_IPSO_update_value \u00b6 Prototype iowa_status_t iowa_client_IPSO_update_value ( iowa_context_t contextP , iowa_sensor_t id , float value ); Description iowa_client_IPSO_update_value() updates the value of an IPSO sensor. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The ID of the sensor as returned by iowa_client_IPSO_add_sensor() . value : The new value measured by the sensor. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known sensor. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - the sensor uses a Boolean value and value is neither 0.0 nor 1.0. : - the sensor uses a percentage value and value is outside the [0.0, 100.0] range. : - the sensor uses a compass direction value and value is outside the [0.0, 360.0] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. Header File objects/iowa_ipso.h Notes If type equal to IOWA_IPSO_LEVEL_CONTROL this function will call iowa_client_dimmer_update_value() . \\clearpage iowa_client_IPSO_update_values \u00b6 Prototype iowa_status_t iowa_client_IPSO_update_values ( iowa_context_t contextP , iowa_sensor_t id , size_t valueCount , iowa_ipso_timed_value_t * valueArray ); Description iowa_client_IPSO_update_values() updates multiple times the value of an IPSO Object sensor. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The ID of the sensor as returned by iowa_client_IPSO_add_sensor() . valueCount : The number of values in valueArray . valueArray : The iowa_ipso_timed_value_t list of new values. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known sensor. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - one of the timestamped value has an negative value. : - the sensor uses a Boolean value and value is neither 0.0 nor 1.0. : - the sensor uses a percentage value and value is outside the [0.0, 100.0] range. : - the sensor uses a compass direction value and value is outside the [0.0, 360.0] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. Header File objects/iowa_ipso.h Notes iowa_client_IPSO_update_values() can only be used when the define [ LWM2M_SUPPORT_TIMESTAMP ][LWM2M_SUPPORT_TIMESTAMP] is set. The timestamp must be absolute and not relative to the current time, meaning negative values are not accepted. If the timestamp is equal to zero, it is ignored. Calling iowa_client_IPSO_update_values() will overwrite the previous values list. This has multiple consequences: If the values have not been sent to the Server, the previous values are lost. Values are only sent if the Server do a Read operation or if the Server has set an Observation. If the values are in the way to be sent to the Server and iowa_client_IPSO_update_values() is called during the process, some old values will be lost. This API is trying to send the values in best effort. Recent timestamped values are processed in priority before the oldest ones. Timestamp information is only present if the used Content Format is: JSON: [ LWM2M_SUPPORT_JSON ][LWM2M_SUPPORT_JSON] SenML JSON: [ LWM2M_SUPPORT_SENML_JSON ][LWM2M_SUPPORT_SENML_JSON] SenML CBOR: [ LWM2M_SUPPORT_SENML_CBOR ][LWM2M_SUPPORT_SENML_CBOR] If type equal to IOWA_IPSO_LEVEL_CONTROL this function will call iowa_client_dimmer_update_values() . \\clearpage iowa_client_IPSO_remove_sensor \u00b6 Prototype iowa_status_t iowa_client_IPSO_remove_sensor ( iowa_context_t contextP , iowa_sensor_t id ); Description iowa_client_IPSO_remove_sensor() removes from the LwM2M Client an IPSO sensor created with iowa_client_IPSO_add_sensor() . Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The ID of the sensor as returned by iowa_client_IPSO_add_sensor() . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an IPSO sensor. Valid id are only returned by iowa_client_IPSO_add_sensor() . IOWA_COAP_404_NOT_FOUND : IPSO referred by id does not exist. Header File objects/iowa_ipso.h Notes If type equal to IOWA_IPSO_LEVEL_CONTROL this function will call iowa_client_remove_dimmer_object() . \\clearpage Ligth Control Object API \u00b6 This IPSO object is used to control a light source, such as a LED or other light. To be able to use this object, iowa_light_control.h must be included. Callbacks \u00b6 iowa_light_control_update_state_callback_t \u00b6 This callback is called when the LwM2M Server request the Client to update the state of the light. typedef iowa_status_t ( * iowa_light_control_update_state_callback_t )( iowa_sensor_t id , bool powerOn , int dimmer , char * colour , void * userDataCallback , iowa_context_t contextP ); id : ID of the object powerOn : Light power dimmer : Dimmer settings colour : A string representing a value in some color space userDataCallback : Application specific data from iowa_client_add_light_control_object . Can be nil. contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage API \u00b6 iowa_client_add_light_control_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_light_control_object ( iowa_context_t context , uint16_t optFlags , const float powerFactor , const char * colorSpace , iowa_light_control_update_state_callback_t updateStateCallback , void * userDataCallback , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_light_control_object() creates a light control object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. powerFactor : The power factor of the light. colorSpace : Color space of the light. updateStateCallback : Called to update state of the light. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. applicationType : The application type idP : Used to store the ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no update state callback provided means updateStateCallback is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_light_control.h Notes \u00b6 Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_LIGHT_CONTROL_RSC_DIMMER IOWA_LIGHT_CONTROL_RSC_ON_TIME IOWA_LIGHT_CONTROL_RSC_CUMULATIVE_ACTIVE_POWER IOWA_LIGHT_CONTROL_RSC_POWER_FACTOR Moreover, you can add several optional resources at one time by using the following flag: IOWA_LIGHT_CONTROL_POWER The argument colorSpace must reflect the color representation of the light. Find below a non-exhaustive list of color spaces: RGB sRGB CMYK ... \\clearpage iowa_client_remove_light_control_object \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_light_control_object ( iowa_context_t context , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_light_control_object() removes a light control object. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a light control object. Valid id are only returned by iowa_client_add_light_control_object() . IOWA_COAP_404_NOT_FOUND : light control referred by id does not exist. Header File \u00b6 objects/iowa_light_control.h \\clearpage iowa_client_light_control_set_state \u00b6 Prototype \u00b6 iowa_status_t iowa_client_light_control_set_state ( iowa_context_t context , iowa_sensor_t id , bool powerOn , int dimmer , const char * colour ); Description \u00b6 iowa_client_light_control_set_state() updates values of a light control object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object powerOn : Light power dimmer : Dimmer settings between 0 and 100 % colour : A string representing a value in some color space Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a light control object. Valid id are only returned by iowa_client_add_light_control_object() . IOWA_COAP_404_NOT_FOUND : light control referred by id does not exist. IOWA_COAP_412_PRECONDITION_FAILED : cannot affect the color. Color space has not been provided. To reconfigure the light control object, delete then readd the object or just add a new one with iowa_client_add_light_control_object() and iowa_client_remove_light_control_object() . IOWA_COAP_406_NOT_ACCEPTABLE : dimmer 's value is outside the [0, 100] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error when powerOn value changes and IOWA_LIGHT_CONTROL_RSC_ON_TIME resource is present. Header File \u00b6 objects/iowa_light_control.h Notes \u00b6 The Light Control Object may contain an \"On Time\" resource and/or a \"Cumulative Active Power\" resource. Calling this API updates their respective values. If colour is nil, the value of the resource Colour is not updated. \\clearpage Location Object API \u00b6 This LwM2M Object contains information on the device position and speed. To be able to use this object, iowa_location.h must be included. iowa_client_add_location_object \u00b6 Prototype iowa_status_t iowa_client_add_location_object ( iowa_context_t context , uint16_t optFlags , iowa_sensor_t * idP ); Description iowa_client_add_location_object() creates a location object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_409_CONFLICT : a location object already exists. To reconfigure the location object, first delete the object with iowa_client_remove_location_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_location.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_LOCATION_RSC_ALTITUDE IOWA_LOCATION_RSC_RADIUS IOWA_LOCATION_RSC_VELOCITY IOWA_LOCATION_RSC_SPEED \\clearpage iowa_client_remove_location_object \u00b6 Prototype iowa_status_t iowa_client_remove_location_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_location_object() removes a location object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a location object. Valid id are only returned by iowa_client_add_location_object() . IOWA_COAP_404_NOT_FOUND : no location object to remove. iowa_client_add_location_object() was not called before, or failed. Header File objects/iowa_location.h \\clearpage iowa_client_location_update \u00b6 Prototype iowa_status_t iowa_client_location_update ( iowa_context_t context , iowa_sensor_t id , float latitude , float longitude ); Description iowa_client_location_update() updates values of a location object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object latitude : New latitude longitude : New longitude Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a location object. Valid id are only returned by iowa_client_add_location_object() . IOWA_COAP_404_NOT_FOUND : object has not been created. First call iowa_client_add_location_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : iowa_system_gettime() returned an error. Header File objects/iowa_location.h \\clearpage iowa_client_location_update_full \u00b6 Prototype iowa_status_t iowa_client_location_update_full ( iowa_context_t context , iowa_sensor_t id , float latitude , float longitude , float altitude , float radius , size_t velocityLength , uint8_t * velocity , float speed ); Description iowa_client_location_update_full() updates values of a location object. Optionals resources are included. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object latitude : New latitude longitude : New longitude altitude : New altitude radius : Indicates the size in meters of a circular area around a point of geometry. velocityLength : Length of the velocity array velocity : The velocity of the device as defined in 3GPP 23.032 GAD specification. speed : Speed is the time rate of change in position of a LwM2M Client without regard for direction: the scalar component of velocity. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a location object. Valid id are only returned by iowa_client_add_location_object() . IOWA_COAP_404_NOT_FOUND : object has not been created. First call iowa_client_add_location_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. Header File objects/iowa_location.h \\clearpage Magnetometer Object API \u00b6 This IPSO object can be used to represent a 1-3 axis magnetometer with optional compass direction. To be able to use this object, iowa_magnetometer.h must be included. iowa_client_add_magnetometer_object \u00b6 Prototype iowa_status_t iowa_client_add_magnetometer_object ( iowa_context_t context , uint16_t optFlags , const char * sensorUnits , iowa_sensor_t * idP ); Description iowa_client_add_magnetometer_object() creates a magnetometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. sensorUnits : Measurement units definition. idP : Used to store the ID of the object. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_magnetometer.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_MAGNETOMETER_RSC_Y_VALUE IOWA_MAGNETOMETER_RSC_Z_VALUE IOWA_MAGNETOMETER_RSC_COMPASS_DIRECTION Moreover, you can add several optional resources at one time by using the following flag: IOWA_MAGNETOMETER_3_AXIS \\clearpage iowa_client_remove_magnetometer_object \u00b6 Prototype iowa_status_t iowa_client_remove_magnetometer_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_magnetometer_object() removes a magnetometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a magnetometer object. Valid id are only returned by iowa_client_add_magnetometer_object() . IOWA_COAP_404_NOT_FOUND : magnetometer referred by id does not exist. Header File objects/iowa_magnetometer.h \\clearpage iowa_client_magnetometer_update_values \u00b6 Prototype iowa_status_t iowa_client_magnetometer_update_values ( iowa_context_t context , iowa_sensor_t id , float xValue , float yValue , float zValue , float compassDirection ); Description iowa_client_magnetometer_update_values() updates values of a magnetometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object xValue : X value axis yValue : Y value axis zValue : Z value axis compassDirection : Measured Direction between 0 and 360 deg. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a magnetometer object. Valid id are only returned by iowa_client_add_magnetometer_object() . IOWA_COAP_404_NOT_FOUND : magnetometer referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : compassDirection 's value is outside the [0.0, 360.0] range. Header File objects/iowa_magnetometer.h \\clearpage Software Component Object API \u00b6 This LwM2M object provides the resources needed to activate/deactivate software components on the device. To be able to use this object, iowa_software_component.h must be included and IOWA_SUPPORT_SOFTWARE_COMPONENT_OBJECT must be defined before building IOWA. Data Structures and Constants \u00b6 iowa_sw_cmp_info_t \u00b6 This structure contains the description of a software component's information which could be set by users. typedef struct { const char * identityP ; const uint8_t * packP ; size_t packLength ; const char * versionP ; } iowa_sw_cmp_info_t ; identityP : Name or identifier of the software component, with size < 255. This can be nil. packP : Link to opaque data describing the software component. This can be nil. packLength : Length in bytes of the opaque data pointed by packP . versionP : Version of the software component, with size < 255. This can be nil. Note This structure will at least provide an identity ( identityP ) or a pack ( packP ) to identify the component. \\clearpage Callbacks \u00b6 iowa_sw_cmp_update_callback_t \u00b6 This is the update callback, called when the Server adds or removes the software components. typedef iowa_status_t ( * iowa_sw_cmp_update_callback_t )( iowa_sensor_t id , iowa_dm_operation_t operation , iowa_sw_cmp_info_t * infoP , bool activationState , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software component. operation : the operation performed by the Server on this software component (either IOWA_DM_CREATE or IOWA_DM_DELETE ). infoP : software component information. activationState : initial activation state. Should be ignored if no iowa_sw_cmp_activation_callback_t() was passed to iowa_client_enable_software_component() . userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. iowa_sw_cmp_activation_callback_t \u00b6 This is the activation callback, called when the Server requests the device to activate or deactivate a software component. typedef iowa_status_t ( * iowa_sw_cmp_activation_callback_t ) ( iowa_sensor_t id , bool activationState , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software component. activationState : activation state requested. userDataP : The data passed to iowa_client_enable_software_component() . contextP : The IOWA context on which iowa_client_enable_software_component() was called. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage API \u00b6 iowa_client_enable_software_component \u00b6 Prototype \u00b6 iowa_status_t iowa_client_enable_software_component ( iowa_context_t contextP , iowa_sw_cmp_update_callback_t updateCb , iowa_sw_cmp_activation_callback_t activationCb , void * userDataP ); Description \u00b6 iowa_client_enable_software_component() enables the software component feature. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. updateCb : The update callback called when the Server adds or removes a software component. This can be nil. activateCb : The activate callback, called when the Server requests the device to activate or deactivate a software component. This can be nil. userDataP : Passed as argument to the callback. This can be nil. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_409_CONFLICT : Software component feature is already configured. To reconfigure the software component, disable it before with iowa_client_disable_software_component() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_software_component.h \\clearpage iowa_client_disable_software_component \u00b6 Prototype \u00b6 iowa_status_t iowa_client_disable_software_component ( iowa_context_t contextP ); Description \u00b6 iowa_client_disable_software_component() disables the software component feature. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : Software component feature was not enabled. iowa_client_enable_software_component() was not called before, or failed. Header File \u00b6 objects/iowa_software_component.h \\clearpage iowa_client_add_software_component \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_software_component ( iowa_context_t contextP , iowa_sw_cmp_info_t * infoP , bool activationState , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_software_component() adds a software component. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. infoP : software component information. activationState : current activation state of the software component. Ignored if no iowa_sw_cmp_activation_callback_t() was passed to iowa_client_enable_software_component() . idP : Used to store the ID of the created software component. Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - infoP is nil. : - both infoP::identityP and infoP::packP are nil. : - a string in infoP is longer than 255 characters. IOWA_COAP_406_NOT_ACCEPTABLE : Software component feature was not enabled. Call first iowa_client_enable_software_component() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_software_component.h Notes \u00b6 infoP must provide at least an identity ( infoP::identityP ) or a pack ( infoP::packP ) to identify the component. The \"const\" elements pointed by the fields of infoP are not duplicated nor freed by IOWA. Make sure they are available until corresponding iowa_client_remove_software_component() , iowa_client_disable_software_component() , or iowa_close() is called. \\clearpage iowa_client_remove_software_component \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_software_component ( iowa_context_t contextP , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_software_component() removes a software component. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software component. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a software component. Valid id are only returned by iowa_client_add_software_component() . IOWA_COAP_404_NOT_FOUND : software component referred by id does not exist. IOWA_COAP_412_PRECONDITION_FAILED : Software component feature was not enabled. Call first iowa_client_enable_software_component() . Header File \u00b6 objects/iowa_software_component.h \\clearpage iowa_client_software_component_update_state \u00b6 Prototype \u00b6 iowa_status_t iowa_client_software_component_update_state ( iowa_context_t contextP , iowa_sensor_t id , bool activationState ); Description \u00b6 iowa_client_software_component_update_state() updates a software component's activation state. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software component. activationState : New activation state of the software component. Note This API has no effect if no iowa_sw_cmp_activation_callback_t() was passed to iowa_client_enable_software_component() since the Activation State resource is not presented to the LwM2M Server. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known software component. IOWA_COAP_406_NOT_ACCEPTABLE : Software component feature was not enabled. Call first iowa_client_enable_software_component() . Header File \u00b6 objects/iowa_software_component.h \\clearpage Software Management Object API \u00b6 In LightweightM2M, the Software Management mechanism is used to install and activate software components to a LwM2M Client. To be able to use this object, iowa_software_management.h must be included and IOWA_SUPPORT_SOFTWARE_MANAGEMENT_OBJECT must be defined before building the library. The [Device Update][Device Update]/[Software Management][Software Management] part of this specification adds more explanation about its mechanism and how to use it with IOWA. Note: As there is currently some confusion on the layout of of the Software Management Object, IOWA uses the definition provided in [LwM2M Overview][LwM2M Overview]/[Software Management Object][Software Management Object]. Data Structures and Constants \u00b6 iowa_sw_pkg_result_t \u00b6 This enumeration is used to update the operation result from iowa_sw_pkg_download_callback_t() , iowa_sw_pkg_write_callback_t() and iowa_sw_pkg_install_callback_t() callbacks. It has the following values: IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL : success of any operation made on the software package (verification, installation, uninstallation, activation, deactivation) IOWA_SW_PKG_UPDATE_RESULT_DOWNLOADING_SUCCESSFUL : success of the new software package download. ( downloadCb only) IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_STORAGE : not enough storage for the new software package. ( downloadCb or writeCb only) IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_MEMORY : out of memory error during the download of the new software package. ( downloadCb or writeCb only) IOWA_SW_PKG_UPDATE_RESULT_CONNECTION_LOST : connection lost during the download of the new software package. ( downloadCb or writeCb only) IOWA_SW_PKG_UPDATE_RESULT_INTEGRITY_CHECK_FAILURE : integrity check failure of the new software package. ( downloadCb or writeCb only) IOWA_SW_PKG_UPDATE_RESULT_UNSUPPORTED_TYPE : unsupported new software package type. IOWA_SW_PKG_UPDATE_RESULT_INVALID_URI : invalid URI to download the new software package. ( downloadCb only) IOWA_SW_PKG_UPDATE_RESULT_UPDATE_FAILED : device defined update error. IOWA_SW_PKG_UPDATE_RESULT_INSTALLED_FAILURE : new software installation failure. ( installCb only) IOWA_SW_PKG_UPDATE_RESULT_UNINSTALLED_FAILURE : software uninstallation failure. ( installCb only) iowa_sw_pkg_state_t \u00b6 This enumeration is used to control current state in iowa_client_add_software_package() and iowa_client_software_package_update_state() . It has the following values: IOWA_SW_PKG_STATE_UNINSTALLED : software is uninstalled. (default value) IOWA_SW_PKG_STATE_INSTALLED : software is installed. IOWA_SW_PKG_STATE_ACTIVATED : software is activate. Useful only if Software components are linked, otherwise same behavior than installed. iowa_sw_pkg_write_cmd_t \u00b6 This enumeration is used in iowa_sw_pkg_write_callback_t() callback. It has the following values: IOWA_SW_PKG_COMMAND_RESET : To start software package packet writing. IOWA_SW_PKG_COMMAND_WRITE : To indicate other software package piece of the complete packet. iowa_sw_pkg_install_cmd_t \u00b6 This enumeration is used in iowa_sw_pkg_install_callback_t() callback. It has the following values: IOWA_SW_PKG_COMMAND_INSTALL : software installation is requested. IOWA_SW_PKG_COMMAND_UNINSTALL : software uninstallation is requested. IOWA_SW_PKG_COMMAND_PREPARE_FOR_UPDATE : software uninstallation is requested to prepare an update. iowa_sw_pkg_optional_info_t \u00b6 This structure contains the description of a optional software package's information which could be set by users. typedef struct { iowa_sensor_t * swComponentLinkP ; uint16_t swComponentLinkCount ; } iowa_sw_pkg_optional_info_t ; swComponentLinkP : Software Components downloaded and installed in scope of the present SW Update Package. This can be nil. : Each swComponentLinkP sensor id must have been provided by [ Software Component Object APIs ][Software Component Object API]. swComponentLinkCount : Software Components Link count. \\clearpage Callbacks \u00b6 iowa_sw_pkg_update_callback_t \u00b6 This is the update callback, called when the Server adds or removes the software packages. typedef iowa_status_t ( * iowa_sw_pkg_update_callback_t ) ( iowa_sensor_t id , iowa_dm_operation_t operation , const char * pkgNameP , const char * pkgVersionP , iowa_sw_pkg_optional_info_t * optP , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software package. operation : the operation performed by the Server on this software package (either IOWA_DM_CREATE or IOWA_DM_DELETE). pkgNameP : Name of the software package. pkgVersionP : Version of the software package. optP : Optional information. This can be nil. userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. Return Value \u00b6 IOWA_COAP_NO_ERROR in case of success or an error status. iowa_sw_pkg_download_callback_t \u00b6 This is the download callback, called when the Server requests the device to download a new software Package (new value in \"Package URI\"). When the packet is downloaded, users should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_DOWNLOADING_SUCCESSFUL result if successful or an error result otherwise. When the packet is verified, users should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL result if successful or an error result otherwise. typedef void ( * iowa_sw_pkg_download_callback_t ) ( iowa_sensor_t id , const char * uriP , const char * userNameP , const char * passwordP , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software package instance. uriP : URI to download the package from. userNameP : User Name for access to SW Update Package in pull mode, with size < 255. Key based mechanism can alternatively use for talking to the component server instead of user name and password combination. This can be nil. passwordP : Password for access to SW Update Package in pull mode, with size < 255. This can be nil. userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. iowa_sw_pkg_write_callback_t \u00b6 This is the write callback, called several times when the Server pushes the new software package to the device (new value in \"Package\"). The expected behavior is the same as writing to a file stream i.e. unless it is reset, written data are appended to the previous ones. typedef iowa_sw_pkg_result_t ( * iowa_sw_pkg_write_callback_t ) ( iowa_sensor_t id , iowa_sw_pkg_write_cmd_t cmd , size_t dataLength , uint8_t * dataP , void * userDataP , iowa_context_t contextP ); At the start of the push of the software package or if the LwM2M Server cancels it, this callback is called with the following parameters: id : ID of the corresponding software package instance. cmd : IOWA_SW_PKG_COMMAND_RESET dataLength : 0 dataP : NULL userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. When the software package is received, this callback is called several times with the following parameters: id : ID of the corresponding software package instance. cmd : IOWA_SW_PKG_COMMAND_WRITE dataLength : The length of the buffer pointed by dataP . data : The next chunk of the software package to write. userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. At the end of the push of the software package, this callback is called with the following parameters: id : ID of the corresponding software package instance. cmd : IOWA_SW_MGMT_PACKAGE_WRITE dataLength : 0 data : NULL userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. Return Value \u00b6 IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL in case of success or an error status. iowa_sw_pkg_install_callback_t \u00b6 This is the install callback, called when the Server requests the device to install or uninstall the software Package. When the installation finishes, users should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL result if successful or an error result otherwise. typedef void ( * iowa_sw_pkg_install_callback_t ) ( iowa_sensor_t id , iowa_sw_pkg_install_cmd_t cmd , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software package instance. cmd : installed state requested. See iowa_sw_pkg_install_cmd_t . userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. \\clearpage API \u00b6 iowa_client_enable_software_package_management \u00b6 Prototype \u00b6 iowa_status_t iowa_client_enable_software_package_management ( iowa_context_t contextP , iowa_sw_pkg_update_callback_t updateCb , iowa_sw_pkg_download_callback_t downloadCb , iowa_sw_pkg_write_callback_t writeCb , iowa_sw_pkg_install_callback_t installCb , void * userDataP ); Description \u00b6 iowa_client_enable_software_package_management() enables the software package management feature. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. updateCb : The update callback called when the Server adds or removes the software packages. This can be nil. downloadCb : The download callback, called when the Server requests the device to download a new software Package (new value in \"Package URI\"). This can be nil. writeCb : The write callback, called several times when the Server pushes the new software Package to the device (new value in \"Package\"). This can be nil. installCb : The install callback, called when the Server requests the device to install or uninstall the software Package. userDataP : Passed as argument to the callbacks. This can be nil. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. COAP_400_BAD_REQUEST : either: : - installCb is nil. : - both downloadCb and writeCb are nil. At least one must be defined. IOWA_COAP_409_CONFLICT : Software package feature is already configured. To reconfigure the software package, disable it before with iowa_client_disable_software_package_management() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_software_management.h Notes \u00b6 The LwM2M Server has two methods to provide the software package: the \"pull\" method: the LwM2M Server provides the URI of the software package and the LwM2M Client downloads it directly. To use this method, downloadCb must be set. the \"push\" method: the LwM2M Server writes the software package in a LwM2M Resource exposed by the Client. To use this method, writeCb must be set. The Client can support both methods at the same time and must at least provide one of them. downloadCb and updateCb do not return any value. The progress and result of their operation are indicated asynchronously by calling iowa_client_set_software_package_command_result() . \\clearpage iowa_client_disable_software_package_management \u00b6 Prototype \u00b6 iowa_status_t iowa_client_disable_software_package_management ( iowa_context_t contextP ); Description \u00b6 iowa_client_disable_software_package_management() disables the software package management feature. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : Software package feature was not enabled. iowa_client_enable_software_package_management() was not called before, or failed. Header File \u00b6 objects/iowa_software_management.h \\clearpage iowa_client_add_software_package \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_software_package ( iowa_context_t contextP , const char * pkgNameP , const char * pkgVersionP , iowa_sw_pkg_state_t state , iowa_sw_pkg_optional_info_t * optP , iowa_sensor_t * idP ); Description \u00b6 iowa_client_add_software_package() adds a software package instance. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. pkgNameP : Name of the software package. pkgVersionP : Version of the software package. state : State of the software package. (default value: IOWA_SW_PKG_STATE_UNINSTALLED) optP : Optional information. This can be nil. idP : Used to store the ID of the created software package instance. Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - pkgNameP is nil. : - pkgVersionP is nil. : - optP has invalid format. : - Any string is larger than 255 characters. IOWA_COAP_406_NOT_ACCEPTABLE : Software package feature was not enabled. Call first iowa_client_enable_software_package_management() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_software_management.h \\clearpage iowa_client_remove_software_package \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_software_package ( iowa_context_t contextP , iowa_sensor_t id ); Description \u00b6 iowa_client_remove_software_package() removes a software package instance. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software package instance. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a software package. Valid id are only returned by iowa_client_add_software_package() . IOWA_COAP_404_NOT_FOUND : software package referred by id does not exist. IOWA_COAP_412_PRECONDITION_FAILED : Software package feature was not enabled. Call first iowa_client_enable_software_package_management() . Header File \u00b6 objects/iowa_software_management.h \\clearpage iowa_client_software_package_update_state \u00b6 Prototype \u00b6 iowa_status_t iowa_client_software_package_update_state ( iowa_context_t contextP , iowa_sensor_t id , iowa_sw_pkg_state_t state ); Description \u00b6 iowa_client_software_package_update_state() updates a software package instance's state. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software package instance. state : state of the software package. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known software package. IOWA_COAP_406_NOT_ACCEPTABLE : Software package feature was not enabled. Call first iowa_client_enable_software_package_management() . Header File \u00b6 objects/iowa_software_management.h \\clearpage iowa_client_set_software_package_command_result \u00b6 Prototype \u00b6 iowa_status_t iowa_client_set_software_package_command_result ( iowa_context_t contextP , iowa_sensor_t id , iowa_sw_pkg_result_t result ); Description \u00b6 iowa_client_set_software_package_command_result() informs the IOWA stack of the result of the callbacks downloadCb and installCb of iowa_client_enable_software_package_management() . Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software package instance. result : The result of the software package callbacks. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known software package. IOWA_COAP_406_NOT_ACCEPTABLE : Software package feature was not enabled. Call first iowa_client_enable_software_package_management() . Header File \u00b6 objects/iowa_software_management.h \\clearpage MQTT Object API \u00b6 This part allows the possibility to connect with an MQTT Broker. To be able to use these objects, iowa_mqtt_objects.h must be included. Data Structures and Constants \u00b6 iowa_mqtt_broker_t \u00b6 typedef struct { char * uri ; char * clientId ; bool cleanSession ; uint16_t keepAlive ; char * userName ; uint8_t * password ; size_t passwordLength ; iowa_security_mode_t securityMode ; iowa_cert_usage_mode_t certificateUsage ; uint8_t * identity ; size_t identityLength ; uint8_t * brokerIdentity ; size_t brokerIdentityLength ; uint8_t * privateKey ; size_t privateKeyLength ; } iowa_mqtt_broker_t ; uri : The URI to reach the MQTT Broker as a nil-terminated string e.g. \"tcp://[::1]:1883\". clientId : MQTT Client Identifier to use when connecting to this MQTT broker. cleanSession : A boolean that's indicate to the MQTT broker to create a persistent session. keepAlive : The maximum time in seconds that's the client take to send or receive a message. userName : The User Name to declare in the MQTT CONNECT message. password : The Password value to declare in the MQTT CONNECT message. passwordLength : The length of the broker's password. securityMode : The security mode to use when connecting to this LwM2M Server. See iowa_security_mode_t . certificateUsage : The Certificate Usage Resource specifies the semantic of the certificate or raw public key stored in the \"MQTT Broker Public Key\" Resource, which is used to match the certificate presented in the TLS/DTLS handshake. See iowa_cert_usage_mode_t . : When this Resource is absent, value IOWA_CERTIFICATE_USAGE_DOMAIN_ISSUED_CERTIFICATE for domain issued certificate mode is assumed. identity : Stores the Device's certificate, public key (RPK mode) or PSK Identity (PSK mode). identityLength : The identity length. brokerIdentity : Stores the MQTT Broker's certificate, public key (RPK mode) or trust anchor. The Certificate Usage Resource determines the content of this resource. brokerIdentityLength : The length of the broker's Identity. privateKey : Stores the secret key (PSK mode) or private key (RPK or certificate mode). privateKeyLength : The private key's length iowa_mqtt_publication_t \u00b6 typedef struct { iowa_sensor_t brokerId ; char * source ; char * topic ; uint8_t qos ; bool retain ; bool active ; iowa_content_format_t encoding ; } iowa_mqtt_publication_t ; brokerId : The ID of the broker to be used. source : The source of the data to publish (e.g. \"\", or \";\"). If this Resource is empty, the published data are implementation dependent. topic : The MQTT topic to publish to. qos : The Quality of Service value to use when publishing. retain : The RETAIN flag value to use when publishing. active : A boolean to indicate if the Resource is not present, the Device publishes the data pointed by the Source Resource to the MQTT Broker pointed by the Broker Resource using the MQTT topic indicated in the Topic Resource. If false, the Device does nothing. encoding : A CoAP Content-Format value used to encode the data in the MQTT Publish message. If this Resource is not present or equal to 65535, the encoding of the data is implementation dependent. \\clearpage Callbacks \u00b6 iowa_mqtt_broker_update_callback_t \u00b6 The callback called when a LwM2M Server modifies the MQTT Broker Object. typedef void ( * iowa_mqtt_broker_update_callback_t ) ( iowa_dm_operation_t operation , iowa_sensor_t brokerId , iowa_mqtt_broker_t * brokerDetailsP , void * userData , iowa_context_t contextP ); operation : the type of the operation among IOWA_DM_READ, IOWA_DM_WRITE and IOWA_DM_DELETE. brokerId : the ID of the modified MQTT broker. brokerDetailsP : the details of the modified MQTT broker. userData : Passed as argument to the callbacks. This can be nil. contextP : the IOWA context on which iowa_client_enable_mqtt_broker() was called. iowa_mqtt_publication_update_callback_t \u00b6 The callback called when a LwM2M Server modifies the MQTT Publication Object. typedef void ( * iowa_mqtt_publication_update_callback_t ) ( iowa_dm_operation_t operation , iowa_sensor_t publicationId , iowa_mqtt_publication_t * publicationDetailsP , void * userData , iowa_context_t contextP ); operation : the type of the operation among IOWA_DM_READ and IOWA_DM_WRITE. publicationId : the ID of the modified MQTT Publication. publicationDetailsP : the details of the modified MQTT Publication. userData : Passed as argument to the callbacks. This can be nil. contextP : the IOWA context on which iowa_client_enable_mqtt_publication() was called. \\clearpage API \u00b6 iowa_client_enable_mqtt_broker \u00b6 Prototype \u00b6 iowa_status_t iowa_client_enable_mqtt_broker ( iowa_context_t contextP , iowa_mqtt_broker_update_callback_t brokerCb , void * userData ); Description \u00b6 iowa_client_enable_mqtt_broker() enables the MQTT brokers management. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. brokerCb : The broker callback called when a LwM2M Server modify the MQTT brokers. userDataP : Passed as argument to the callbacks. This can be nil. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : brokerCb is nil. IOWA_COAP_409_CONFLICT : MQTT brokers management is already enabled. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_mqtt_objects.h \\clearpage iowa_client_disable_mqtt_broker \u00b6 Prototype \u00b6 iowa_status_t iowa_client_disable_mqtt_broker ( iowa_context_t contextP ); Description \u00b6 iowa_client_disable_mqtt_broker() disables the MQTT brokers management. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : MQTT brokers management is not enabled. Header File \u00b6 objects/iowa_mqtt_objects.h \\clearpage iowa_client_add_mqtt_broker \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_mqtt_broker ( iowa_context_t contextP , uint16_t optFlags , const iowa_mqtt_broker_t * brokerDetailsP , iowa_sensor_t * brokerIdP ); Description \u00b6 iowa_client_add_mqtt_broker() adds an MQTT broker instance. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. brokerDetailsP : The details of the MQTT Broker. Copied internally by IOWA. brokerIdP : Used to store the ID of the created MQTT Broker instance. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - Invalid brokerDetailsP . : - brokerIdP is nil. IOWA_COAP_412_PRECONDITION_FAILED MQTT brokers management is not enabled. Call iowa_client_enable_mqtt_broker() first. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. Header File \u00b6 objects/iowa_mqtt_objects.h Notes \u00b6 The invalid broker's details are : either: : - The client identity is nil. : - The password length is 0 and the password is not nil. : - The identity length is 0 and the identity is not nil. : - The private key length is 0 and the private key is not nil. : - The broker's identity length is 0 and the broker's identity is not nil. : - The security mode is IOWA_SEC_NONE and the identity length and/or private key length and/or broker's identity length are greater than 0. : - The security mode is different than IOWA_SEC_NONE and the identity length and/or private key length equal to 0. : - The security mode is IOWA_SEC_RAW_PUBLIC_KEY or IOWA_SEC_CERTIFICATE and the broker identity length equal to 0. : - The security mode value is unknown. : - The certificate usage value is unknown. To add optional resource, you can use the following flag: IOWA_MQTT_BROKER_CERTIFICATE_USAGE : a flag to set the broker certificate usage resource, if this resource is not set by the user, domain issued certificate mode is assumed. \\clearpage iowa_client_remove_mqtt_broker \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_mqtt_broker ( iowa_context_t contextP , iowa_sensor_t brokerId ); Description \u00b6 iowa_client_remove_mqtt_broker() removes an MQTT broker instance. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. brokerId : The ID assigned to the MQTT Broker by IOWA. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : brokerId is not valid. Valid brokerId are only returned by iowa_client_add_mqtt_broker() . IOWA_COAP_404_NOT_FOUND : brokerId does not match a known MQTT broker. IOWA_COAP_412_PRECONDITION_FAILED MQTT brokers management is not enabled. Call iowa_client_enable_mqtt_broker() first. Header File \u00b6 objects/iowa_mqtt_objects.h \\clearpage iowa_client_get_mqtt_broker \u00b6 Prototype \u00b6 iowa_mqtt_broker_t * iowa_client_get_mqtt_broker ( iowa_context_t contextP , iowa_sensor_t brokerId ); Description \u00b6 iowa_client_get_mqtt_broker() retrieves the details of an MQTT broker. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. brokerId : The ID assigned to the MQTT Broker by IOWA. Return Value \u00b6 The MQTT broker's details, or NULL if the MQTT brokers management is not enabledor if brokerId does not match a known MQTT broker. Notes \u00b6 The returned pointer points to the internal data of IOWA and not to duplicated information. It is advised to not modify it. Header File \u00b6 objects/iowa_mqtt_objects.h \\clearpage iowa_client_enable_mqtt_publication \u00b6 Prototype \u00b6 iowa_status_t iowa_client_enable_mqtt_publication ( iowa_context_t contextP , iowa_mqtt_publication_update_callback_t publicationCB , void * userData ); Description \u00b6 iowa_client_enable_mqtt_publication() enables the MQTT Publication management. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. publicationCB : The broker callback called when a LwM2M Server modify the MQTT brokers. userDataP : Passed as argument to the callbacks. This can be nil. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : publicationCB is nil. IOWA_COAP_409_CONFLICT : MQTT Publication Object already exists. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 objects/iowa_mqtt_objects.h \\clearpage iowa_client_disable_mqtt_publication \u00b6 Prototype \u00b6 iowa_status_t iowa_client_disable_mqtt_publication ( iowa_context_t contextP ); Description \u00b6 iowa_client_disable_mqtt_publication() disables the MQTT Publication management. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : MQTT publication Object not found. Header File \u00b6 objects/iowa_mqtt_objects.h \\clearpage iowa_client_add_mqtt_publication \u00b6 Prototype \u00b6 iowa_status_t iowa_client_add_mqtt_publication ( iowa_context_t contextP , uint16_t optFlags , const iowa_mqtt_publication_t * publicationDetailsP , iowa_sensor_t * publicationIdP ); Description \u00b6 iowa_client_add_mqtt_publication() adds an MQTT publication instance. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to indicate optional resources. publicationDetailsP : publicationDetailsP: details of the MQTT Publication. Copied internally by IOWA. publicationIdP : Used to store the ID of the created MQTT Publication instance. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - Invalid publicationDetailsP . : - publicationIdP is nil. IOWA_COAP_412_PRECONDITION_FAILED : MQTT publication management was not enabled. Call iowa_client_enable_mqtt_publication() first. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. : Invalid publication source format. Header File \u00b6 objects/iowa_mqtt_objects.h Notes \u00b6 The invalid publication's details are either: : - The publication's topic is nil. : - The publication's source is nil. : - The publication's QOS is greater than 2. To add optional resources, you can use the following flag: IOWA_MQTT_PUBLICATION_RSC_ENCODING : a flag to set the publication encoding resource, if this resource is not set by the user, the encoding of the data is implementation dependent. IOWA_MQTT_PUBLICATION_RSC_ACTIVE : a flag to set the publication active resource. if this resource is not set by the user, it will be assumed to be true. \\clearpage iowa_client_remove_mqtt_publication \u00b6 Prototype \u00b6 iowa_status_t iowa_client_remove_mqtt_publication ( iowa_context_t contextP , iowa_sensor_t publicationId ); Description \u00b6 iowa_client_remove_mqtt_publication() removes an MQTT Publication instance. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. publicationId : The ID assigned to the MQTT Publication by IOWA. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : publicationId is not an MQTT object. Valid publicationId are only returned by iowa_client_add_mqtt_publication() . IOWA_COAP_404_NOT_FOUND : MQTT object referred by publicationId does not exist. IOWA_COAP_412_PRECONDITION_FAILED : MQTT publication management was not enabled. Call iowa_client_enable_mqtt_publication() first. Header File \u00b6 objects/iowa_mqtt_objects.h","title":"Client APIs"},{"location":"ClientAPI/#client-mode-api-reference","text":"The functions explained below are defined inside the file include/iowa_client.h and the Objects folder include/objects .","title":"Client Mode API Reference"},{"location":"ClientAPI/#client-pseudo-code","text":"#include \"iowa_client.h\" #include \"iowa_ipso.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; iowa_device_info_t devInfo ; iowa_sensor_t sensorId ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); devInfo . manufacturer = \"IOTEROP\" ; devInfo . deviceType = \"Example device\" ; devInfo . modelNumber = \"1\" ; devInfo . serialNumber = NULL ; devInfo . hardwareVersion = NULL ; devInfo . softwareVersion = NULL ; devInfo . optFlags = 0 ; result = iowa_client_configure ( iowaH , \"IOWA_Sample_Client\" , devInfo , NULL ); result = iowa_client_IPSO_add_sensor ( iowaH , IOWA_IPSO_VOLTAGE , 12.0 , \"V\" , \"Test DC\" , 0.0 , 0.0 , & sensorId ); result = iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ while ( result == IOWA_COAP_NO_ERROR ) { float sensorValue ; result = iowa_step ( iowaH , 5 ); sensorValue = read_battery_voltage (); result = iowa_client_IPSO_update_value ( iowaH , sensorId , sensorValue ); } iowa_client_IPSO_remove_sensor ( iowaH , sensorId ); iowa_close ( iowaH ); return 0 ; } \\clearpage","title":"Client pseudo code"},{"location":"ClientAPI/#data-types","text":"","title":"Data types"},{"location":"ClientAPI/#iowa_server_setting_id_t","text":"typedef uint8_t iowa_server_setting_id_t ;","title":"iowa_server_setting_id_t"},{"location":"ClientAPI/#possible-values","text":"IOWA_SERVER_SETTING_QUEUE_MODE : A flag to set the queue mode of a server. IOWA_SERVER_SETTING_LIFETIME : A flag to set the lifetime of a server.","title":"Possible Values"},{"location":"ClientAPI/#iowa_lwm2m_binding_t","text":"typedef uint8_t iowa_lwm2m_binding_t ; IOWA_LWM2M_BINDING_UNKNOWN : The flag to define Unknown binding. IOWA_LWM2M_BINDING_UDP : The flag to define UDP binding. IOWA_LWM2M_BINDING_TCP : The flag to define TCP binding. IOWA_LWM2M_BINDING_SMS : The flag to define SMS binding. IOWA_LWM2M_BINDING_NON_IP : The flag to define Non-IP binding.","title":"iowa_lwm2m_binding_t"},{"location":"ClientAPI/#iowa_server_info_t","text":"typedef struct { uint16_t shortId ; const char * uriP ; int32_t lifetime ; iowa_lwm2m_binding_t binding ; bool queueMode ; } iowa_server_info_t ; The iowa_server_info_t structure is used to get the shortID and the parameters of the configured servers. shortId : the Short ID assigned to the server. uriP : The uri to connect with the server. lifetime : The lifetime in seconds of the registration to the server. binding : The binding used to connect to the server. queueMode : The state of the Queue mode of the server.","title":"iowa_server_info_t"},{"location":"ClientAPI/#iowa_device_info_t","text":"typedef struct { const char * manufacturer ; const char * deviceType ; const char * modelNumber ; const char * serialNumber ; const char * hardwareVersion ; const char * firmwareVersion ; const char * softwareVersion ; const char * msisdn ; uint16_t optFlags ; const char * utcOffsetP ; const char * timezoneP ; iowa_client_time_update_callback_t dataTimeUpdateCallback ; iowa_client_factory_reset_callback_t factoryResetCallback ; void * callbackUserDataP ; } iowa_device_info_t ; The iowa_device_info_t structure exists only for the sake of the readability of iowa_client_configure() . It contains pointers to nil-terminated strings described below. As all these information are optional in a LwM2M Client, these pointers can be nil. The LwM2M standard does not mandate any format for these strings. They are manufacturer specific. manufacturer : A human readable manufacturer name. deviceType : The type of the device. modelNumber : The number of the model. serialNumber : The serial number of the device. hardwareVersion : The current version of the device hardware. firmwareVersion : The current version of the device firmware. softwareVersion : The current version of the device software. msisdn : The phone number of the device. optFlags : Flags used to enable optional features. This value is a combination of: IOWA_DEVICE_RSC_BATTERY : enables the battery level and status exposed in the [ Device Object ][Device Object]. To update battery level you need to call iowa_client_device_update_battery() . IOWA_DEVICE_RSC_POWER_SOURCE : enables the power sources information in the [ Device Object ][Device Object]. To add any new power source you need to call iowa_client_add_device_power_source() . IOWA_DEVICE_RSC_CURRENT_TIME : enables the use of current time in the [ Device Object ][Device Object] (default value: 0). IOWA_DEVICE_RSC_UTC_OFFSET : enables the use of UTC offset in the [ Device Object ][Device Object] (default value: utcOffsetP). IOWA_DEVICE_RSC_TIMEZONE : enables the use of timezone in the [ Device Object ][Device Object] (default value: 0). utcOffsetP : Indicates the UTC offset currently in effect for this LwM2M Device. It should be in the ISO 8601 format (UTC+X). timezoneP : Indicates in which time zone the LwM2M Device is located, in IANA Timezone (TZ) database format. dataTimeUpdateCallback : The callback called when the time information is updated by the LwM2M Server. factoryResetCallback : The callback called on a Factory Reset. callbackUserDataP : Passed as argument to the callbacks dataTimeUpdateCallback and factoryResetCallback . Notes To update time information (current time, UTC offset, timezone) you need to call iowa_client_update_device_time_information() To update device related information (manufacturer, model number, serial number, firmware version, device type, hardware version, software version.) you need to call iowa_client_update_device_information() .","title":"iowa_device_info_t"},{"location":"ClientAPI/#iowa_event_type_t","text":"typedef enum { IOWA_EVENT_UNDEFINED = 0 , IOWA_EVENT_REG_UNREGISTERED , IOWA_EVENT_REG_REGISTERING , IOWA_EVENT_REG_REGISTERED , IOWA_EVENT_REG_UPDATING , IOWA_EVENT_REG_FAILED , IOWA_EVENT_REG_UPDATE_FAILED , IOWA_EVENT_BS_PENDING , IOWA_EVENT_BS_FINISHED , IOWA_EVENT_BS_FAILED , IOWA_EVENT_OBSERVATION_STARTED , IOWA_EVENT_OBSERVATION_NOTIFICATION , IOWA_EVENT_OBSERVATION_CANCELED , IOWA_EVENT_OBJECT_INSTANCE_CREATED , IOWA_EVENT_OBJECT_INSTANCE_DELETED , IOWA_EVENT_EVALUATION_PERIOD , IOWA_EVENT_READ } iowa_event_type_t ; The iowa_event_type_t contains the possible events that can be reported by the IOWA stack.","title":"iowa_event_type_t"},{"location":"ClientAPI/#iowa_event_t","text":"typedef struct { iowa_event_type_t eventType ; uint16_t serverShortId ; union { struct { uint32_t lifetime ; } registration ; struct { iowa_sensor_t sensorId ; uint16_t resourceId ; uint32_t minPeriod ; uint32_t maxPeriod ; uint32_t minEvalPeriod ; uint32_t maxEvalPeriod ; } observation ; struct { iowa_lwm2m_uri_t * uriP ; } objectInstance ; struct { iowa_lwm2m_uri_t * uriP ; uint32_t minEvalPeriod ; uint32_t maxEvalPeriod ; } evalPeriod ; struct { iowa_sensor_t sensorId ; } sensor ; } details ; } iowa_event_t ; eventType : the event type. serverShortId : the short server ID of the LwM2M Server generating this event. details : the details of the event. details::registration : filled when the event is of type IOWA_EVENT_REG_UNREGISTERED , IOWA_EVENT_REG_REGISTERING , IOWA_EVENT_REG_REGISTERED , IOWA_EVENT_REG_UPDATING , IOWA_EVENT_REG_FAILED or IOWA_EVENT_REG_UPDATE_FAILED . details::registration::lifetime : the lifetime of the registration to the LwM2M Server generating this event. details::observation : filled when the event is of type IOWA_EVENT_OBSERVATION_STARTED , IOWA_EVENT_OBSERVATION_NOTIFICATION , or IOWA_EVENT_OBSERVATION_CANCELED details::observation::sensorId : the ID of the sensor under observation. details::observation::resourceId : the ID of the specific resource under observation of the sensor. This may be IOWA_LWM2M_ID_ALL . details::observation::minPeriod : the minimum time in seconds to wait between notifications for the observation. If not set the minPeriod is to 0. details::observation::maxPeriod : the maximum time in seconds to wait between notifications for the observation. If not set the maxPeriod is to UINT32_MAX. details::observation::minEvalPeriod : the minimum sample time in seconds for the observed sensor in LwM2M 1.1 or later. If not set the minEvalPeriod is to 0. details::observation::maxEvalPeriod : the maximum sample time in seconds for the observed sensor in LwM2M 1.1 or later. If not set the maxEvalPeriod is to UINT32_MAX. details::instance : filled when the event is of type IOWA_EVENT_OBJECT_INSTANCE_CREATED or IOWA_EVENT_OBJECT_INSTANCE_DELETED . details::instance::uri : a pointer to the iowa_lwm2m_uri_t of the instance that has been created or deleted. details::evalPeriod : filled when the event is of type IOWA_EVENT_EVALUATION_PERIOD . Available when the flag IOWA_LWM2M_VERSION_1_1 is set. details::evalPeriod::uriP : a pointer to the iowa_lwm2m_uri_t of the uri where evaluation period has been set. details::evalPeriod::minEvalPeriod : the minimum sample time in seconds for the concerned uri. If the LwM2M Server unsets it or does not set it, the value is 0. details::evalPeriod::maxEvalPeriod : the maximum sample time in seconds for the concerned uri. If the LwM2M Server unsets it or does not set it, the value is UINT32_MAX. details::sensor : filled when the event is of type IOWA_EVENT_READ . details::sensor::sensorId : the ID of the sensor targeted by a Read operation from the LwM2M Server. The iowa_event_t is used by iowa_event_callback_t when an event occurred on a client. These events are described by iowa_event_type_t . The IOWA stack handles the minimum and maximum observation periods. They are provided in iowa_event_t as an information for the application. Embedded devices may use this information to tune their measurement or sleeping schedule. The IOWA stack does not handle the minimum and maximum evaluation observation periods. They are provided in iowa_event_t as sample times for the application. Embedded devices may use those sample times to tune their measurement or sleeping schedule.","title":"iowa_event_t"},{"location":"ClientAPI/#iowa_device_time_info_t","text":"typedef struct { uint16_t flags ; int32_t currentTime ; const char * utcOffsetP ; const char * timezoneP ; } iowa_device_time_info_t ; flags : Flags used to enable optional time information. This value is a combination of: IOWA_DEVICE_RSC_CURRENT_TIME : current time has a new current time value from server IOWA_DEVICE_RSC_UTC_OFFSET : current time has a new UTC offset value from server IOWA_DEVICE_RSC_TIMEZONE : current time has a new timezone value from server currentTime : Current UNIX time of the LwM2M Client in seconds. utcOffsetP : Indicates the UTC offset currently in effect for this LwM2M Device. It should be in the ISO 8601 format (UTC+X). Could be nil, if not UTC offset is enable. timezoneP : Indicates in which time zone the LwM2M Device is located, in IANA Timezone (TZ) database format. Could be nil, if not Timezone is enable.","title":"iowa_device_time_info_t"},{"location":"ClientAPI/#iowa_ipso_timed_value_t","text":"typedef struct { float value ; int32_t timestamp ; } iowa_ipso_timed_value_t ; value : The timestamped value. timestamp : The timestamp associated to the value in seconds. This can not be negative.","title":"iowa_ipso_timed_value_t"},{"location":"ClientAPI/#iowa_sensor_t","text":"This must be treated as an opaque type. It is internally mapped to a 32-bit unsigned integer.","title":"iowa_sensor_t"},{"location":"ClientAPI/#special-values","text":"IOWA_INVALID_SENSOR_ID : Used to indicate an error by APIs returning an iowa_sensor_t . IOWA_DEVICE_TIME_SENSOR_ID : The sensor ID of the Current Time of the device. This is internally mapped to the resource 13 in the [Device Object][Device Object].","title":"Special Values"},{"location":"ClientAPI/#iowa_lwm2m_resource_desc_t","text":"This structure contains the description of a LwM2M resource. typedef struct { uint16_t id ; iowa_lwm2m_data_type_t type ; uint8_t operations ; uint8_t flags ; } iowa_lwm2m_resource_desc_t ; id : ID of the resource. type : The datatype of the resource. operations : The operations allowed on the resource. : This is a mask of values IOWA_OPERATION_READ , IOWA_OPERATION_WRITE and IOWA_OPERATION_EXECUTE . flags : The flags of the resource. : This is a mask of values IOWA_RESOURCE_FLAG_NONE , IOWA_RESOURCE_FLAG_OPTIONAL , IOWA_RESOURCE_FLAG_MANDATORY , IOWA_RESOURCE_FLAG_MULTIPLE , and IOWA_RESOURCE_FLAG_ASYNCHRONOUS .","title":"iowa_lwm2m_resource_desc_t"},{"location":"ClientAPI/#iowa_sensor_uri_t","text":"This structure describes a sensor URI. typedef struct { iowa_sensor_t id ; uint16_t resourceId ; } iowa_sensor_uri_t ; id : ID of the object. resourceId : The ID of the resource. This can be IOWA_LWM2M_ID_ALL . \\clearpage","title":"iowa_sensor_uri_t"},{"location":"ClientAPI/#callbacks","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_event_callback_t","text":"This is the event callback, called when an event such as registration update or unregister occurred. typedef void ( * iowa_event_callback_t ) ( iowa_event_t * eventP , void * userData , iowa_context_t contextP ); eventP : The event stored in a structure. userData : A pointer to application specific data. This is a parameter of iowa_init() . contextP : The IOWA context on which iowa_client_configure() was called.","title":"iowa_event_callback_t"},{"location":"ClientAPI/#iowa_client_time_update_callback_t","text":"This callback is called when time information are updated by server. typedef void ( * iowa_client_time_update_callback_t ) ( iowa_device_time_info_t * timeInfoP , void * userDataP , iowa_context_t contextP ); timeInfoP : Current device time information. userDataP : A pointer to application specific data. This is the parameter of iowa_client_configure() . contextP : The IOWA context on which iowa_client_configure() was called.","title":"iowa_client_time_update_callback_t"},{"location":"ClientAPI/#iowa_client_factory_reset_callback_t","text":"This callback is called when a factory reset is requested. typedef void ( * iowa_client_factory_reset_callback_t ) ( void * userDataP , iowa_context_t contextP ); userDataP : A pointer to application specific data. This is the parameter of iowa_client_configure() . contextP : The IOWA context on which iowa_client_configure() was called.","title":"iowa_client_factory_reset_callback_t"},{"location":"ClientAPI/#iowa_rwe_callback_t","text":"This callback is called when a Read, Write or Execute operation is performed on a resource of a custom LwM2M Object. typedef iowa_status_t ( * iowa_RWE_callback_t ) ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t contextP ); operation : The operation to perform on the resource among IOWA_DM_READ , IOWA_DM_WRITE and IOWA_DM_EXECUTE . dataP : An array of the URIs of the targeted resources. : For a Write operation, it also contains the value to write. : For a Read operation, the result is to be stored in this. numData : Number of resources in dataP. userData : A pointer to application specific data. This is the parameter of iowa_client_add_custom_object() . contextP : The IOWA context on which iowa_client_add_custom_object() was called.","title":"iowa_RWE_callback_t"},{"location":"ClientAPI/#notes","text":"Before calling this callback, the IOWA stack performs checks on the resource existence and its allowed operations. In case of a Write operation, the data type is also checked for conformance. The LwM2M Execute operation may have parameters. If so, they are provided as a string in dataP . After IOWA_DM_READ operation, the callback is called with IOWA_DM_FREE operation to permit the deallocation of memory that may have been allocated by the callback previously.","title":"Notes"},{"location":"ClientAPI/#iowa_cd_callback_t","text":"This callback is called when a Create or Delete operation is performed on an instance of a custom LwM2M Object. typedef iowa_status_t ( * iowa_CD_callback_t ) ( iowa_dm_operation_t operation , uint16_t objectID , uint16_t instanceID , void * userData , iowa_context_t contextP ); operation : The operation to perform on the resource among IOWA_DM_CREATE and IOWA_DM_DELETE . objectID : The ID of the targeted Object. instanceID : The ID of the targeted instance. userData : A pointer to application specific data. This is the parameter of iowa_client_add_custom_object() . contextP : The IOWA context on which iowa_client_add_custom_object() was called.","title":"iowa_CD_callback_t"},{"location":"ClientAPI/#iowa_ri_callback_t","text":"This callback is called to retrieve the list of current resource instance IDs for a multiple resource. typedef iowa_status_t ( * iowa_RI_callback_t ) ( uint16_t objectID , uint16_t instanceID , uint16_t resourceID , uint16_t * nbResInstanceP , uint16_t ** resInstanceArrayP , void * userData , iowa_context_t contextP ); objectID : The ID of the Object the resource belongs to. instanceID : The ID of the Object Instance the resource belongs to. resourceID : The ID of the targeted resource. nbResInstanceP : Used to store the number of elements in resInstanceArrayP. resInstanceArrayP : Used to store an array containing the resource instances IDs. This array will be freed by the caller by calling iowa_system_free() . userData : A pointer to application specific data. This is the parameter of iowa_client_add_custom_object() . contextP : The IOWA context on which iowa_client_add_custom_object() was called. \\clearpage","title":"iowa_RI_callback_t"},{"location":"ClientAPI/#api","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_configure","text":"Prototype iowa_status_t iowa_client_configure ( iowa_context_t contextP , const char * identity , iowa_device_info_t * infoP , iowa_event_callback_t eventCb ); Description iowa_client_configure() sets the information of the LwM2M Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. identity : The unique identity of the LwM2M Client as a nil-terminated string. infoP : The optional information of the LwM2M Client. This can be nil. eventCb : The callback called when an event occurred. This can be nil. Return Value IOWA_COAP_NO_ERROR : success. COAP_400_BAD_REQUEST : either: : - identity is nil or empty and LWM2M_VERSION_1_1_SUPPORT is not set. : - the maximum length of infoP->msisdn is 15 digits. : - infoP->msisdn is not nil, but IOWA_SMS_SUPPORT is not defined. IOWA_COAP_412_PRECONDITION_FAILED : the client was already configured in this context. To reconfigure the client, close than reopen a fresh IOWA context with iowa_close() and iowa_init() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes The nil-terminated strings pointed by the fields of infoP are not duplicated nor freed by IOWA. Make sure they are available until iowa_close() is called. It is advised to use static strings. The LwM2M Client information are exposed to the LwM2M Server through the Resources of the [ Device Object ][Device Object] (ID: 3). The following table explained the mapping: Resource ID Resource Name API 0 Manufacturer manufacturer field of the iowa_device_info_t structure. 1 Model Number modelNumber field of the iowa_device_info_t structure. 2 Serial Number serialNumber field of the iowa_device_info_t structure. 3 Firmware Version firmwareVersion field of the iowa_device_info_t structure. 4 Reboot 5 Factory Reset 6 Available Power Sources Set the flag IOWA_DEVICE_RSC_POWER_SOURCE in optFlags field of the structure iowa_device_info_t . Then use iowa_client_..._device_power_source to control it. 7 Power Source Voltage Set the flag IOWA_DEVICE_RSC_POWER_SOURCE in optFlags field of the structure iowa_device_info_t . Then use iowa_client_..._device_power_source to control it. 8 Power Source Current Set the flag IOWA_DEVICE_RSC_POWER_SOURCE in optFlags field of the structure iowa_device_info_t . Then use iowa_client_..._device_power_source to control it. 9 Battery Level Set the flag IOWA_DEVICE_RSC_BATTERY in optFlags field of the structure iowa_device_info_t . Then use iowa_client_device_update_battery to control it. 10 Memory Free Not exposed by IOWA. 11 Error Code Use iowa_client_..._device_error_code to control it. 12 Reset Error Code Set the flag IOWA_DEVICE_RSC_RESET_ERROR in optFlags field of the structure iowa_device_info_t . 13 Current Time Set the flag IOWA_DEVICE_RSC_CURRENT_TIME in optFlags field of the structure iowa_device_info_t . Then use iowa_client_update_device_time_information to control it. 14 UTC Offset utcOffsetP field and set the flag IOWA_DEVICE_RSC_UTC_OFFSET in optFlags field of the structure iowa_device_info_t . Then use iowa_client_update_device_time_information to control it. 15 Timezone timezoneP field and set the flag IOWA_DEVICE_RSC_TIMEZONE in optFlags field of the structure iowa_device_info_t . Then use iowa_client_update_device_time_information to control it. 16 Supported Binding and Modes Cannot be updated directly but depends on the Server URI schema. 17 Device Type deviceType field of the iowa_device_info_t structure. 18 Hardware Version hardwareVersion field of the iowa_device_info_t structure. 19 Software Version softwareVersion field of the iowa_device_info_t structure. 20 Battery Status Set the flag IOWA_DEVICE_RSC_BATTERY in optFlags field of the structure iowa_device_info_t . Then use iowa_client_device_update_battery to control it. 21 Memory Total Not exposed by IOWA. 22 ExtDevInfo Not exposed by IOWA. \\clearpage","title":"iowa_client_configure"},{"location":"ClientAPI/#iowa_client_new_incoming_connection","text":"Prototype iowa_status_t iowa_client_new_incoming_connection ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); Description iowa_client_new_incoming_connection() informs the stack of a new incoming connection. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The type of the new connection. See iowa_connection_type_t . connP : The new connection of the same user-defined type as the one returned by iowa_system_connection_open() . isSecure : Set to true if the security must be enabled on this connection. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - the connection type is not supported. Make sure to verify the corresponding IOWA_..._SUPPORT flag has been enabled during IOWA build. : - isSecure is true, but no security layer has been built. Make sure to verify the corresponding IOWA_SECURITY_LAYER_... flag has been enabled during IOWA build. Header File iowa_client.h Notes iowa_client_new_incoming_connection() can only be called when IOWA is built with the flag LWM2M_CLIENT_INCOMING_CONNECTION_SUPPORT . \\clearpage","title":"iowa_client_new_incoming_connection"},{"location":"ClientAPI/#iowa_client_add_bootstrap_server","text":"Prototype iowa_status_t iowa_client_add_bootstrap_server ( iowa_context_t contextP , const char * uri , iowa_security_mode_t securityMode ); Description iowa_client_add_bootstrap_server() declares a new LwM2M Bootstrap Server for the LwM2M Client to connect to. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. The context MUST be configured with iowa_client_configure() to add a bootstrap server. uri : The URI to reach this bootstrap server as a nil-terminated string e.g. \"coaps://[::1]:5684\", \"coap://lwm2m.example.org:5683\" or \"sms://+331020304050\". securityMode : The security mode to use when connecting to this LwM2M Bootstrap Server. See iowa_security_mode_t . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : uri is nil. IOWA_COAP_403_FORBIDDEN : a bootstrap server is already configured. To reconfigure the LwM2M Bootstrap Server, call first iowa_client_remove_bootstrap_server . IOWA_COAP_404_NOT_FOUND : client is not configured. Call first iowa_client_configure() . IOWA_COAP_406_NOT_ACCEPTABLE : uri is invalid. For example, if the transport is not supported or if uri does not match securityMode . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes iowa_client_add_bootstrap_server() can only be called when IOWA is built with the flag LWM2M_BOOTSTRAP . uri is duplicated internally by IOWA and can be freed by the caller. Only one bootstrap server can be configured. \\clearpage","title":"iowa_client_add_bootstrap_server"},{"location":"ClientAPI/#iowa_client_remove_bootstrap_server","text":"Prototype iowa_status_t iowa_client_remove_bootstrap_server ( iowa_context_t contextP ); Description iowa_client_remove_bootstrap_server() removes a LwM2M Bootstrap Server added by iowa_client_add_bootstrap_server() from the LwM2M Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : no bootstrap server is configured. iowa_client_add_bootstrap_server() was not called before, or failed. Header File iowa_client.h Notes iowa_client_remove_bootstrap_server() can only be called when IOWA is built with the flag LWM2M_BOOTSTRAP . \\clearpage","title":"iowa_client_remove_bootstrap_server"},{"location":"ClientAPI/#iowa_client_set_bootstrap_server_hold_off","text":"Prototype iowa_status_t iowa_client_set_bootstrap_server_hold_off ( iowa_context_t contextP , int32_t holdOff ); Description iowa_client_set_bootstrap_server_hold_off() sets the Bootstrap Hold Off time. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. holdOff : The Hold Off time. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : holdOff is negative. IOWA_COAP_404_NOT_FOUND : no bootstrap server is configured. iowa_client_add_bootstrap_server() was not called before, or failed. Header File iowa_client.h Notes iowa_client_set_bootstrap_server_hold_off() can only be called when IOWA is built with the flag LWM2M_BOOTSTRAP . \\clearpage","title":"iowa_client_set_bootstrap_server_hold_off"},{"location":"ClientAPI/#iowa_client_get_bootstrap_server_coap_peer","text":"Prototype iowa_coap_peer_t * iowa_client_get_bootstrap_server_coap_peer ( iowa_context_t contextP ); Description iowa_client_get_bootstrap_server_coap_peer() returns the CoAP peer associated to a LwM2M Bootstrap Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value A pointer to the iowa_coap_peer_t associated to the LwM2M Bootstrap Server. This pointer may be nil if IOWA did not yet initiate, or has finished, the Bootstrap process. Header File iowa_client.h Notes iowa_client_get_bootstrap_server_coap_peer() can only be called when IOWA is built with the flag LWM2M_BOOTSTRAP . \\clearpage","title":"iowa_client_get_bootstrap_server_coap_peer"},{"location":"ClientAPI/#iowa_client_add_server","text":"Prototype iowa_status_t iowa_client_add_server ( iowa_context_t contextP , uint16_t shortID , const char * uri , uint32_t lifetime , uint16_t configFlags , iowa_security_mode_t securityMode ); Description iowa_client_add_server() declares a new LwM2M Server for the LwM2M Client to connect to. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. The context MUST be configured with iowa_client_configure() to add a server. shortID : The ID assigned to this server. This cannot be zero nor IOWA_LWM2M_ID_ALL nor an existing one. uri : The URI to reach this server as a nil-terminated string e.g. \"coaps://[::1]:5684\", \"coap://lwm2m.example.org:5683\" or \"sms://+331020304050\". lifetime : The lifetime in seconds of the registration to this server. configFlags : A bit-mask of configuration flags for this LwM2M Server. securityMode : The security mode to use when connecting to this LwM2M Server. See iowa_security_mode_t . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : uri is nil. IOWA_COAP_403_FORBIDDEN : shortID is either zero, IOWA_LWM2M_ID_ALL or already in use. IOWA_COAP_404_NOT_FOUND : client is not configured. Call first iowa_client_configure() . IOWA_COAP_406_NOT_ACCEPTABLE : uri is invalid. For example, if the transport is not supported or if uri does not match securityMode . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes If lifetime is set to zero, the registration lifetime is set to a default value of: 30 days (2,592,000 seconds) for LoRaWAN transport 24 hours (86,400 seconds) for other transports (UDP, TCP, SMS ...) uri is duplicated internally by IOWA and can be freed by the caller. configFlags is a combination of the following: IOWA_LWM2M_QUEUE_MODE : Enable LwM2M Queue Mode for this LwM2M Server. \\clearpage","title":"iowa_client_add_server"},{"location":"ClientAPI/#iowa_client_remove_server","text":"Prototype iowa_status_t iowa_client_remove_server ( iowa_context_t contextP , uint16_t shortID ); Description iowa_client_remove_server() removes a LwM2M Server added by iowa_client_add_server() from the LwM2M Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to this server or IOWA_LWM2M_ID_ALL . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortID is zero. IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h \\clearpage","title":"iowa_client_remove_server"},{"location":"ClientAPI/#iowa_client_set_server_configuration","text":"Prototype iowa_status_t iowa_client_set_server_configuration ( iowa_context_t contextP , uint16_t shortId , iowa_server_setting_id_t settingId , void * argP ); Description iowa_client_set_server_configuration() configures the settings of a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The short ID of a LwM2M Server. settingId : The setting to set. See iowa_server_setting_id_t . argP : A pointer to the setting value. Dependent on settingId . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortId does not match any known server. IOWA_COAP_405_METHOD_NOT_ALLOWED : settingId is nil. IOWA_COAP_501_NOT_IMPLEMENTED : invalid settingId value. Header File iowa_client.h \\clearpage","title":"iowa_client_set_server_configuration"},{"location":"ClientAPI/#iowa_client_set_server_msisdn","text":"Prototype iowa_status_t iowa_client_set_server_msisdn ( iowa_context_t contextP , uint16_t shortID , const char * msisdn ); Description iowa_client_set_server_msisdn() sets the MSISDN of a previously added LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : the Short ID assigned to a LwM2M Server. msisdn : the MSISDN to reach this Server e.g. \"0102030405\" or \"+33102030405\". This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : the maximum length of msisdn is 15 digits. IOWA_COAP_403_FORBIDDEN : shortID is either zero or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes iowa_client_set_server_msisdn() can only be called when IOWA is built with the flag IOWA_SMS_SUPPORT . To unset the MSISDN, the parameter msisdn can take the value NULL. An MSISDN can not be set for the Bootstrap Server. \\clearpage","title":"iowa_client_set_server_msisdn"},{"location":"ClientAPI/#iowa_client_set_server_registration_behaviour","text":"Prototype iowa_status_t iowa_client_set_server_registration_behaviour ( iowa_context_t contextP , uint16_t shortId , uint16_t priorityOrder , int32_t initialDelayTimer , bool blockOnFailure , bool bootstrapOnFailure ); Description iowa_client_set_server_registration_behaviour() set the registration behaviour of a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to the server. priorityOrder : The Server priority order for the registration sequence. initialDelayTimer : The initial delay to wait before to send the registration. blockOnFailure : If registration fails and true is set, the registration sequence is interrupted. bootstrapOnFailure : If registration fails and true is set, a bootstrap sequence is initiated. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - initialDelayTimer is negative. : - bootstrapOnFailure is equals to true but [ LWM2M_BOOTSTRAP ][LWM2M_BOOTSTRAP] is not set. IOWA_COAP_403_FORBIDDEN : shortID is either zero or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h Notes This API requires LWM2M_VERSION_1_1_SUPPORT to be set. If IOWA_SERVER_RSC_REGISTRATION_BEHAVIOUR_REMOVE is set, this API cannot be called. \\clearpage","title":"iowa_client_set_server_registration_behaviour"},{"location":"ClientAPI/#iowa_client_set_server_communication_attempts","text":"Prototype iowa_status_t iowa_client_set_server_communication_attempts ( iowa_context_t contextP , uint16_t shortId , uint8_t retryCount , int32_t retryDelayTimer , uint8_t sequenceRetryCount , int32_t sequenceDelayTimer ); Description iowa_client_set_server_communication_attempts() set the communication attempts of a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to the server. retryCount : The number of successive registration attempts before which a registration sequence is considered as failed. retryDelayTimer : The number to wait between each registration sequence. The value is multiplied by two to the power of the registration retry attempt minus one (2**(retry attempt-1)) to create an exponential back-off. sequenceRetryCount : The number of successive registration sequences before which a registration attempt is considered as failed. sequenceDelayTimer : The number to wait between each successive registration sequences. The value is multiplied by two to the power of the registration retry attempt minus one (2**(retry attempt-1)) to create an exponential back-off. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - retryCount is superior to 32. : - retryDelayTimer is negative. : - sequenceRetryCount is superior to 32. : - sequenceDelayTimer is negative. IOWA_COAP_403_FORBIDDEN : shortID is either zero or IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h Notes This API requires LWM2M_VERSION_1_1_SUPPORT to be set. If IOWA_SERVER_RSC_COMMUNICATION_ATTEMPTS_REMOVE is set, this API cannot be called. \\clearpage","title":"iowa_client_set_server_communication_attempts"},{"location":"ClientAPI/#iowa_client_get_server_count","text":"Prototype iowa_status_t iowa_client_get_server_count ( iowa_context_t contextP , size_t * serversCountP ); Description iowa_client_get_server_count() get the count of all configured LwM2M Servers. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. serversCountP : A pointer to the count of all configured LwM2M Servers. Return Value IOWA_COAP_NO_ERROR : success. Header File iowa_client.h \\clearpage","title":"iowa_client_get_server_count"},{"location":"ClientAPI/#iowa_client_get_server_array","text":"Prototype iowa_status_t iowa_client_get_server_array ( iowa_context_t contextP , size_t serversCount , iowa_server_info_t * serverArrayP ); Description iowa_client_get_server_array() retrieves the configured LwM2M Servers with theirs associated information. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. serversCount : A pointer to the count of LwM2M Servers. serverArrayP : An Array of iowa_server_info_t with a size equal to the count of the current configured LwM2M Servers. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : serverListP is nil. IOWA_COAP_408_REQUEST_ENTITY_INCOMPLETE : The count of configured LwM2M servers has been changed since the call of iowa_client_get_server_count() . Header File iowa_client.h Notes To get the count of the current configured LwM2M Servers you need to call iowa_client_get_server_count() . \\clearpage","title":"iowa_client_get_server_array"},{"location":"ClientAPI/#iowa_client_get_server_coap_peer","text":"Prototype iowa_coap_peer_t * iowa_client_get_server_coap_peer ( iowa_context_t contextP , uint16_t shortId ); Description iowa_client_get_server_coap_peer() returns the CoAP peer associated to a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to the server. Return Value A pointer to the iowa_coap_peer_t associated to the LwM2M Server. This pointer may be nil if shortId is invalid or if IOWA did not yet initiate the registration to the LwM2M Server. Header File iowa_client.h \\clearpage","title":"iowa_client_get_server_coap_peer"},{"location":"ClientAPI/#iowa_client_set_notification_default_periods","text":"Prototype iowa_status_t iowa_client_set_notification_default_periods ( iowa_context_t contextP , uint16_t shortID , uint32_t minPeriod , uint32_t maxPeriod ); Description iowa_client_set_notification_default_periods() configures the default periods for notifications sent to a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The ID assigned to the server or IOWA_LWM2M_ID_ALL . minPeriod : The default minimum time in seconds between two notifications sent to the LwM2M Server for the same observation. maxPeriod : The default maximum time in seconds between two notifications sent to the LwM2M Server for the same observation. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortID is zero. IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h Notes When IOWA_LWM2M_ID_ALL is used as shortID , only already known LwM2M Servers will have the default periods configured. If a LwM2M Server is added after the call to this API, by default it will not have default periods. Setting the default periods does not affect already running observations. A minimum period set to zero is equivalent to having no minimum period defined. Same for maximum period. If maxPeriod is inferior to minPeriod , it is cleared (i.e. set to zero). \\clearpage","title":"iowa_client_set_notification_default_periods"},{"location":"ClientAPI/#iowa_client_use_reliable_notifications","text":"Prototype iowa_status_t iowa_client_use_reliable_notifications ( iowa_context_t contextP , uint16_t shortId , bool enable ); Description iowa_client_use_reliable_notifications() configures the LwM2M Client to ensure that notifications are received by the LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The ID assigned to the server or IOWA_LWM2M_ID_ALL . enable : If true, notifications will be reliable. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortID is zero. IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. Header File iowa_client.h Notes When IOWA_LWM2M_ID_ALL is used as shortID , only already known LwM2M Servers will have reliable notifications. If a LwM2M Server is added after the call to this API, by default it will not use reliable notifications. If enable is true: on unreliable transports like UDP, the notifications are sent as Confirmable messages. if a notification does not reach the LwM2M Server, IOWA stores it until the LwM2M Server is reachable again. See [ LWM2M_STORAGE_QUEUE_SUPPORT ][LWM2M_STORAGE_QUEUE_SUPPORT] and [ LWM2M_STORAGE_QUEUE_PEEK_SUPPORT ][LWM2M_STORAGE_QUEUE_PEEK_SUPPORT]. \\clearpage","title":"iowa_client_use_reliable_notifications"},{"location":"ClientAPI/#iowa_client_object_set_mode","text":"Prototype iowa_status_t iowa_client_object_set_mode ( iowa_context_t contextP , iowa_sensor_t id , uint8_t mode ); Description iowa_client_object_set_mode() sets the sensor mode. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The ID of the sensor. mode : Flags used to enable modes. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known sensor. Header File iowa_client.h Notes To use this API, the compilation flag [ LWM2M_CLIENT_ASYNCHRONOUS_OPERATION_SUPPORT ][LWM2M_CLIENT_ASYNCHRONOUS_OPERATION_SUPPORT] must be set. To set the sensor mode, you can use the following flag: IOWA_OBJECT_MODE_DEFAULT IOWA_OBJECT_MODE_ASYNCHRONOUS By default, sensors are synchronous. A call to iowa_client_object_set_mode() affects all the sensors of the same type. \\clearpage","title":"iowa_client_object_set_mode"},{"location":"ClientAPI/#iowa_client_device_update_battery","text":"Prototype iowa_status_t iowa_client_device_update_battery ( iowa_context_t contextP , uint8_t batteryLevel , iowa_device_battery_status_t batteryStatus ); Description iowa_client_device_update_battery() updates the battery level and status exposed in the [ Device Object ][Device Object]. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. batteryLevel : The battery level in percent. batteryStatus : The battery status. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_405_METHOD_NOT_ALLOWED : client has been configured without the flag IOWA_DEVICE_RSC_BATTERY in the iowa_device_info_t structure. To reconfigure the client, close than reopen a fresh IOWA Client context with iowa_close() , iowa_init() and iowa_client_configure() . IOWA_COAP_406_NOT_ACCEPTABLE : batteryLevel is outside the range [0; 100]. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . Header File iowa_client.h Notes For the device to expose its battery level and status, iowa_client_configure() must have been to called with the IOWA_DEVICE_RSC_BATTERY flag. Before the first call to iowa_client_device_update_battery() , default value of batteryStatus is IOWA_DEVICE_BATTERY_STATUS_UNKNOWN . iowa_client_device_update_battery() can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_BATTERY_REMOVE .","title":"iowa_client_device_update_battery"},{"location":"ClientAPI/#iowa_device_battery_status_t","text":"This is an enumeration of the following values: IOWA_DEVICE_BATTERY_STATUS_NORMAL : The battery is operating normally and not on power. IOWA_DEVICE_BATTERY_STATUS_CHARGING : The battery is currently charging. IOWA_DEVICE_BATTERY_STATUS_CHARGE_COMPLETE : The battery is fully charged and still on power. IOWA_DEVICE_BATTERY_STATUS_DAMAGED : The battery has some problem. IOWA_DEVICE_BATTERY_STATUS_LOW_BATTERY : The battery is low on charge. IOWA_DEVICE_BATTERY_STATUS_NOT_INSTALLED : The battery is not installed. IOWA_DEVICE_BATTERY_STATUS_UNKNOWN : The battery information is not available. \\clearpage","title":"iowa_device_battery_status_t"},{"location":"ClientAPI/#iowa_client_add_device_power_source","text":"Prototype iowa_status_t iowa_client_add_device_power_source ( iowa_context_t context , iowa_power_source_type_t type , int voltageValue , int currentValue , iowa_sensor_t * idP ); Description iowa_client_add_device_power_source() adds a power source to Device object with initial value of voltage and current. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : power source type. voltageValue : initial voltage value (mV). currentValue : initial current value (mA). idP : Used to store the ID of the created power source. Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_405_METHOD_NOT_ALLOWED : client has been configured without the flag IOWA_DEVICE_RSC_POWER_SOURCE in the iowa_device_info_t structure. To reconfigure the client, close than reopen a fresh IOWA Client context with iowa_close() , iowa_init() and iowa_client_configure() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes For the device to expose its power source information, iowa_client_configure() must have been to called with the IOWA_DEVICE_RSC_POWER_SOURCE flag. To update a power source values, you need to call iowa_client_update_device_power_source() . To remove a power source, you need to call iowa_client_remove_device_power_source() . iowa_client_add_device_power_source() can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE .","title":"iowa_client_add_device_power_source"},{"location":"ClientAPI/#iowa_power_source_type_t","text":"This is an enumeration of the following values: IOWA_POWER_SOURCE_DC_POWER : DC power supply. IOWA_POWER_SOURCE_INTERNAL_BATTERY : Internal battery. IOWA_POWER_SOURCE_EXTERNAL_BATTERY : External battery. IOWA_POWER_SOURCE_FUEL_CELL : Fuel Cell IOWA_POWER_SOURCE_POWER_OVER_ETHERNET : Power Over Ethernet. IOWA_POWER_SOURCE_USB : USB. IOWA_POWER_SOURCE_AC_MAIN_POWER : AC power supply. IOWA_POWER_SOURCE_SOLAR : Solar energy. \\clearpage","title":"iowa_power_source_type_t"},{"location":"ClientAPI/#iowa_client_remove_device_power_source","text":"Prototype iowa_status_t iowa_client_remove_device_power_source ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_device_power_source() removes a power source from the Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the power source to remove. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_404_NOT_FOUND : id is not a device's power source. Valid id are only returned by iowa_client_add_device_power_source() . IOWA_COAP_405_METHOD_NOT_ALLOWED : client has been configured without the flag IOWA_DEVICE_RSC_POWER_SOURCE in the iowa_device_info_t structure. To reconfigure the client, close than reopen a fresh IOWA Client context with iowa_close() , iowa_init() and iowa_client_configure() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa_client.h Notes For the device to expose its power source information, iowa_client_configure() must have been to called with the IOWA_DEVICE_RSC_POWER_SOURCE flag. iowa_client_remove_device_power_source() can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE . \\clearpage","title":"iowa_client_remove_device_power_source"},{"location":"ClientAPI/#iowa_client_update_device_power_source","text":"Prototype iowa_status_t iowa_client_update_device_power_source ( iowa_context_t context , iowa_sensor_t id , int voltageValue , int currentValue ); Description iowa_client_update_device_power_source() updates a power source values to Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the power source. voltageValue : new voltage value (mV). currentValue : new current value (mA). Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_404_NOT_FOUND : id is not a device's power source. Valid id are only returned by iowa_client_add_device_power_source() . IOWA_COAP_405_METHOD_NOT_ALLOWED : client has been configured without the flag IOWA_DEVICE_RSC_POWER_SOURCE in the iowa_device_info_t structure. To reconfigure the client, close than reopen a fresh IOWA Client context with iowa_close() , iowa_init() and iowa_client_configure() . Header File iowa_client.h Notes For the device to expose its power source information, iowa_client_configure() must have been to called with the IOWA_DEVICE_RSC_POWER_SOURCE flag. iowa_client_update_device_power_source() can only be called when IOWA is built WITHOUT the flag IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE . \\clearpage","title":"iowa_client_update_device_power_source"},{"location":"ClientAPI/#iowa_client_update_device_information","text":"Prototype iowa_status_t iowa_client_update_device_information ( iowa_context_t contextP , iowa_device_info_t * deviceInfoP ); Description iowa_client_update_device_information() updates the device information. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. infoP : pointer to the new device's information. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : deviceInfoP is nil. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . Header File iowa_client.h Notes This function update only the supported device resources that has been set previously in iowa_client_configure() . The parameters that can be updated are : Manufacturer. Model number. Serial number. Firmware version. Device type. Hardware version. Software version. Nil values in deviceInfoP will be ignored and won't make any changes. \\clearpage","title":"iowa_client_update_device_information"},{"location":"ClientAPI/#iowa_client_set_device_error_code","text":"Prototype iowa_status_t iowa_client_set_device_error_code ( iowa_context_t context , uint8_t errorCode ); Description iowa_client_set_device_error_code() sets an error code on Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. errorCode : The error code value to set between 1 and 32. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_402_BAD_OPTION : errorCode is not a valid parameter. IOWA_COAP_404_NOT_FOUND : errorCode is IOWA_ERROR_CODE_NO_ERROR but there is no error to clear. IOWA_COAP_409_CONFLICT : errorCode has already been set. Header File iowa_client.h Notes To clear one error code, you need to call iowa_client_clear_device_error_code() . To clear all error codes, you can call iowa_client_set_device_error_code() with errorCode argument set to IOWA_ERROR_CODE_NO_ERROR. The error code is an integer between 1 and 32. The LwM2M protocol defines eight values between 1 and 8 detailed below. Values between 9 and 15 are reserved for future use. The device maker or the application can use the values between 16 and 32 as proprietary error codes. LwM2M defined error code values are: IOWA_ERROR_CODE_NO_ERROR : No error. IOWA_ERROR_CODE_LOW_BATTERY_POWER (1) : Low battery power. IOWA_ERROR_CODE_EXTERNAL_POWER_SUPPLY_OFF (2) : External power supply off. IOWA_ERROR_CODE_GPS_MODULE_FAILURE (3) : GPS module failure. IOWA_ERROR_CODE_LOW_RECEIVED_SIGNAL_STRENGTH (4) : Low received signal strength. IOWA_ERROR_CODE_OUT_OF_MEMORY (5) : Out of memory. IOWA_ERROR_CODE_SMS_FAILURE (6) : SMS failure. IOWA_ERROR_CODE_IP_CONNECTIVITY_FAILURE (7) : IP connectivity failure. IOWA_ERROR_CODE_PERIPHERAL_MALFUNCTION (8) : Peripheral malfunction. \\clearpage","title":"iowa_client_set_device_error_code"},{"location":"ClientAPI/#iowa_client_clear_device_error_code","text":"Prototype iowa_status_t iowa_client_clear_device_error_code ( iowa_context_t context , uint8_t errorCode ); Description iowa_client_clear_device_error_code() clears an error code from the Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. errorCode : The error code to clear between 1 and 32. It can't be IOWA_ERROR_CODE_NO_ERROR . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . IOWA_COAP_402_BAD_OPTION : The error code IOWA_ERROR_CODE_NO_ERROR can't be cleared. IOWA_COAP_404_NOT_FOUND : The error code is not set. Header File iowa_client.h Notes LwM2M defined error code values are enumerated in iowa_client_set_device_error_code() . \\clearpage","title":"iowa_client_clear_device_error_code"},{"location":"ClientAPI/#iowa_client_update_device_time_information","text":"Prototype iowa_status_t iowa_client_update_device_time_information ( iowa_context_t contextP , iowa_device_time_info_t * timeInfoP ); Description iowa_client_update_device_time_information() updates time information to Device object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. timeInfoP : Current device time information: iowa_device_time_info_t . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : timeInfoP is nil. : currentTime in timeInfoP is set with a negative value. IOWA_COAP_412_PRECONDITION_FAILED : client is not configured. Call first iowa_client_configure() . Header File iowa_client.h Notes For the device to expose its time information, iowa_client_configure() must have been to called with time information used. \\clearpage","title":"iowa_client_update_device_time_information"},{"location":"ClientAPI/#iowa_client_add_custom_object","text":"Prototype iowa_status_t iowa_client_add_custom_object ( iowa_context_t contextP , uint16_t objectID , size_t instanceCount , uint16_t * instanceIDs , size_t resourceCount , iowa_lwm2m_resource_desc_t * resourceArray , iowa_RWE_callback_t dataCallback , iowa_CD_callback_t instanceCallback , iowa_RI_callback_t resInstanceCallback , void * userData ); Description iowa_client_add_custom_object() adds a new custom Object for the LwM2M Client to handle. The object is defined by its ID and a the list of the resources it contains. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectID : The ID of the Object. instanceCount : The number of elements in instanceIDs . This can be 0. instanceIDs : The IDs of the instances of the Object. This can be nil. resourceCount : The number of elements in resourceArray . resourceArray : An array of iowa_lwm2m_resource_desc_t composing the Object. dataCallback : The callback to perform Read, Write and Execute operations on the resources. instanceCallback : The callback to perform Create and Delete operations on Object instances. This can be nil. resInstanceCallback : The callback to retrieve the list of instances of resources declared as multiple. This can be nil. userData : Passed as argument to the callbacks. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_403_FORBIDDEN : objectID is 0, 1 or 3 which are reserved Object IDs. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - objectID is IOWA_LWM2M_ID_ALL (65535). : - resourceCount is zero. : - resourceArray is nil. : - dataCallback is nil. : - instanceIDs is nil and instanceCount is not zero. : - resInstanceCallback is nil and one of the resources in resourceArray has the IOWA_RESOURCE_FLAG_MULTIPLE flag set. IOWA_COAP_409_CONFLICT : this object already exists. Call first iowa_client_remove_custom_object() . Header File iowa_client.h Notes Object IDs 0, 1 and 3 are reserved and cannot be used. Per Lightweight M2M specification, the ID of the instance of a single-instance Object is 0. When creating a single-instance Object, you can set instanceCount to zero and instanceCallback to nil. IOWA will automatically create an instance with ID 0. When the LwM2M Server creates a new instance of the custom object, instanceCallback is first called with the new instance ID then dataCallback is called with operation set to IOWA_DM_WRITE to initialize the instance. Thus if instanceCallback is defined, dataCallback must handle the Write operation even on resources declared as read-only. \\clearpage","title":"iowa_client_add_custom_object"},{"location":"ClientAPI/#iowa_client_remove_custom_object","text":"Prototype iowa_status_t iowa_client_remove_custom_object ( iowa_context_t contextP , uint16_t objectID ); Description iowa_client_remove_custom_object() removes a custom Object created with iowa_client_add_custom_object() . Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectID : The ID of the Object. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : objectID is 0, 1 or 3 which are reserved Object IDs. IOWA_COAP_404_NOT_FOUND : objectID does not match any known object. IOWA_COAP_406_NOT_ACCEPTABLE : objectID is IOWA_LWM2M_ID_ALL (65535). Header File iowa_client.h \\clearpage","title":"iowa_client_remove_custom_object"},{"location":"ClientAPI/#iowa_client_object_resource_changed","text":"Prototype iowa_status_t iowa_client_object_resource_changed ( iowa_context_t contextP , uint16_t objectID , uint16_t instanceID , uint16_t resourceID ); Description iowa_client_object_resource_changed() informs the IOWA stack that the value of a LwM2M Object resource changed. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectID : The ID of the Object containing the resource. instanceID : The ID of the Instance containing the resource. This can be IOWA_LWM2M_ID_ALL . resourceID : The ID of the resource. This can be IOWA_LWM2M_ID_ALL . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : objectID is 0, 1 or 3 which are reserved Object IDs. IOWA_COAP_406_NOT_ACCEPTABLE : objectID is IOWA_LWM2M_ID_ALL (65535). Header File iowa_client.h Notes This API does not check if the LwM2M Object resource exists. That's why this API does not return IOWA_COAP_404_NOT_FOUND. Actually, iowa_client_object_resource_changed() is only searching a match between the running observation and the URI provided. If a match is found a notification is sent, else nothing happens. \\clearpage","title":"iowa_client_object_resource_changed"},{"location":"ClientAPI/#iowa_client_object_instance_changed","text":"Prototype iowa_status_t iowa_client_object_instance_changed ( iowa_context_t contextP , uint16_t objectID , uint16_t instanceID , iowa_dm_operation_t operation ); Description iowa_client_object_instance_changed() informs the IOWA stack that an instance of a LwM2M Object was created or deleted. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectID : The ID of the Object containing the instance. instanceID : The ID of the created or deleted Instance. operation : IOWA_DM_CREATE if it is a new instance. IOWA_DM_DELETE if the instance was removed. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_403_FORBIDDEN : objectID is 0, 1 or 3 which are reserved Object IDs. IOWA_COAP_404_NOT_FOUND : either: : - objectID does not match any known object. : - operation is IOWA_DM_DELETE and instanceID does not match any known instance. IOWA_COAP_405_METHOD_NOT_ALLOWED : operation is neither IOWA_DM_CREATE nor IOWA_DM_DELETE . IOWA_COAP_406_NOT_ACCEPTABLE : either: : - objectID is IOWA_LWM2M_ID_ALL (65535). : - operation is IOWA_DM_CREATE and instanceID was already present. Header File iowa_client.h \\clearpage","title":"iowa_client_object_instance_changed"},{"location":"ClientAPI/#iowa_client_notification_lock","text":"Prototype void iowa_client_notification_lock ( iowa_context_t contextP , bool enter ); Description iowa_client_notification_lock() prevents or allows the IOWA stack to send notifications and registration updates. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. enter : true to stop the notification, false to resume the notification. Return Value None. Header File iowa_client.h Notes The main use is to perform several calls to iowa_client_object_resource_changed() on an Object without generating a notification each time if the Object is under observation. Registration updates are also blocked, allowing to add or remove several Objects or Object Instances. This function is useful only if IOWA is built with the IOWA_MULTITHREAD_SUPPORT flag. Inside a custom object callback, notifications are already disabled. \\clearpage","title":"iowa_client_notification_lock"},{"location":"ClientAPI/#iowa_client_send_heartbeat","text":"Prototype iowa_status_t iowa_client_send_heartbeat ( iowa_context_t contextP , uint16_t shortID ); Description iowa_client_send_heartbeat() sends an heartbeat message to a server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortID : The Short ID assigned to this Server. Can be equal to IOWA_LWM2M_ID_ALL . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortID is zero. IOWA_COAP_404_NOT_FOUND : shortID does not match any known server. IOWA_COAP_412_PRECONDITION_FAILED : client is not connected to the server with shortID . This can happen when: : - The Server is a Bootstrap Server and the Client is already connect to a Server. : - The Client is configured with more than one Server and has established the connection with only one. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : heartbeat message has not been sent by the platform. Header File iowa_client.h Notes If shortID is equal to IOWA_LWM2M_ID_ALL , the heartbeat message will be sent to all servers. For non LoRaWAN Servers, a registration update message is sent to the Server. The iowa_event_callback_t will be called with a IOWA_EVENT_REG_UPDATING event. Then, if a reply is received from the Server, the iowa_event_callback_t will be called with either a IOWA_EVENT_REG_REGISTERED or IOWA_EVENT_REG_FAILED event. Nothing is done when no reply is received from the Server. In the IOWA_EVENT_REG_REGISTERED case, the registration lifetime timer for the LwM2M Server is resetted. \\clearpage","title":"iowa_client_send_heartbeat"},{"location":"ClientAPI/#iowa_client_send_sensor_data","text":"Prototype iowa_status_t iowa_client_send_sensor_data ( iowa_context_t contextP , uint16_t shortId , iowa_sensor_uri_t * sensorUriP , size_t sensorUriCount , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_client_send_sensor_data() sends data from iowa_sensor_t to server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The ID of the server. It can be IOWA_LWM2M_ID_ALL to send to all registered servers. sensorUriP , sensorUriCount : The sensor uri to send. responseCb : The callback called when the reply to this operation is known. This can be nil. userDataP : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : sensorUriCount is zero or sensorUriP is nil. IOWA_COAP_401_UNAUTHORIZED : The destination LwM2M Server does not have the Read Access Right to the sent data. Refer to the [Access Control List Object][Access Control List Object] for details. IOWA_COAP_403_FORBIDDEN : shortId is not an acceptable value. IOWA_COAP_404_NOT_FOUND : either: : - shortId does not match a known server. : - at least one sensorUriP[x] does not match a known resource. IOWA_COAP_405_METHOD_NOT_ALLOWED : at least one sensorUriP[x] 's resource is not readable. IOWA_COAP_412_PRECONDITION_FAILED : the receiving LwM2M Server has muted the Send feature. See the Mute Send resource of the [Server Object][Server Object]. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : the client is not registered to the requested LwM2M Server or the communication with the requested LwM2M Server failed. Header File iowa_client.h Notes This API requires the compilation flag [ LWM2M_DATA_PUSH_SUPPORT ][LWM2M_DATA_PUSH_SUPPORT]. The responseCb will be called with the operation set to IOWA_DM_DATA_PUSH . If shortId is IOWA_LWM2M_ID_ALL , the responseCb will be called for each registered LwM2M Server which has not muted the Client. \\clearpage","title":"iowa_client_send_sensor_data"},{"location":"ClientAPI/#iowa_client_send_data","text":"Prototype iowa_status_t iowa_client_send_data ( iowa_context_t contextP , uint16_t shortId , iowa_lwm2m_data_t * dataArrayP , size_t dataCount , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_client_send_data() sends data to server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The ID of the server. It can be IOWA_LWM2M_ID_ALL to send to all registered servers. dataArrayP , dataCount : The data to send. responseCb : The callback called when the reply to this operation is known. This can be nil. resultUserDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - at least one dataArrayP[x].resourceID is IOWA_LWM2M_ID_ALL . : - dataCount is zero or dataArrayP is nil. IOWA_COAP_401_UNAUTHORIZED : The destination LwM2M Server does not have the Read Access Right to the sent data. Refer to the [Access Control List Object][Access Control List Object] for details. IOWA_COAP_403_FORBIDDEN : shortId is not an acceptable value. IOWA_COAP_404_NOT_FOUND : either: : - shortId does not match a known server. : - at least one dataArrayP[x] does not match a known resource. IOWA_COAP_405_METHOD_NOT_ALLOWED : at least one dataArrayP[x] 's resource is not readable. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - one of the timestamped value has an negative timestamp. : - at least one dataArrayP[x] has negative value with unsigned integer type IOWA_COAP_412_PRECONDITION_FAILED : the receiving LwM2M Server has muted the Send feature. See the Mute Send resource of the [Server Object][Server Object]. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : the client is not registered to the requested LwM2M Server or the communication with the requested LwM2M Server failed. Header File iowa_client.h Notes This API requires the compilation flag [ LWM2M_DATA_PUSH_SUPPORT ][LWM2M_DATA_PUSH_SUPPORT]. The responseCb will be called with the operation set to IOWA_DM_DATA_PUSH . If shortId is IOWA_LWM2M_ID_ALL , the responseCb will be called for each registered LwM2M Server which has not muted the Client. \\clearpage","title":"iowa_client_send_data"},{"location":"ClientAPI/#accelerometer-object-api","text":"This IPSO object can be used to represent a 1-3 axis accelerometer. To be able to use this object, iowa_accelerometer.h must be included.","title":"Accelerometer Object API"},{"location":"ClientAPI/#iowa_client_add_accelerometer_object","text":"Prototype iowa_status_t iowa_client_add_accelerometer_object ( iowa_context_t context , uint16_t optFlags , float minRangeValue , float maxRangeValue , const char * sensorUnits , iowa_sensor_t * idP ); Description iowa_client_add_accelerometer_object() creates an accelerometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. minRangeValue : Minimal range value for the accelerometer. maxRangeValue : Maximal range value for the accelerometer. sensorUnits : Measurement units definition idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : minRangeValue argument is superior to maxRangeValue argument. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_accelerometer.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_ACCELEROMETER_RSC_Y_VALUE IOWA_ACCELEROMETER_RSC_Z_VALUE IOWA_ACCELEROMETER_RSC_MIN_RANGE_VALUE IOWA_ACCELEROMETER_RSC_MAX_RANGE_VALUE Moreover, you can add several optional resources at one time by using the following flags: IOWA_ACCELEROMETER_3_AXIS IOWA_ACCELEROMETER_RANGE_VALUE \\clearpage","title":"iowa_client_add_accelerometer_object"},{"location":"ClientAPI/#iowa_client_remove_accelerometer_object","text":"Prototype iowa_status_t iowa_client_remove_accelerometer_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_accelerometer_object() removes an accelerometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an accelerometer object. Valid id are only returned by iowa_client_add_accelerometer_object() . IOWA_COAP_404_NOT_FOUND : accelerometer referred by id does not exist. Header File objects/iowa_accelerometer.h \\clearpage","title":"iowa_client_remove_accelerometer_object"},{"location":"ClientAPI/#iowa_client_accelerometer_update_axis","text":"Prototype iowa_status_t iowa_client_accelerometer_update_axis ( iowa_context_t context , iowa_sensor_t id , float xValue , float yValue , float zValue ); Description iowa_client_accelerometer_update_axis() updates values of an accelerometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object xValue : X value axis yValue : Y value axis zValue : Z value axis Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an accelerometer object. Valid id are only returned by iowa_client_add_accelerometer_object() . IOWA_COAP_404_NOT_FOUND : accelerometer referred by id does not exist. Header File objects/iowa_accelerometer.h \\clearpage","title":"iowa_client_accelerometer_update_axis"},{"location":"ClientAPI/#access-control-list-object-api","text":"This LwM2M Object is used to check whether the LwM2M Server has access right for performing an operation. To be able to use this object, iowa_access_control_list.h must be included and the define [ IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT ][IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT] must bet set.","title":"Access Control List Object API"},{"location":"ClientAPI/#iowa_client_acl_rights_server_set","text":"Prototype iowa_status_t iowa_client_acl_rights_server_set ( iowa_context_t contextP , uint16_t objectId , uint16_t instanceId , uint16_t serverId , uint8_t accessRights ); Description iowa_client_acl_rights_server_set() set the access rights for a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectId : ID of the Object. instanceId : ID of the Object Instance. serverId : Short Server ID of a LwM2M Server or IOWA_ACL_DEFAULT_ID . accessRights : new access rights to set. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : either: : if instanceId is IOWA_LWM2M_ID_ALL , accessRights must be IOWA_ACL_CREATE_RIGHT . : if instanceId is not IOWA_LWM2M_ID_ALL , accessRights cannot included IOWA_ACL_CREATE_RIGHT . IOWA_COAP_403_FORBIDDEN : either: : objectId is IOWA_LWM2M_ID_ALL . : serverId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : either: : objectId does not refer to a supported Object. : if instanceId is not IOWA_LWM2M_ID_ALL , instanceId does not refer to an instanciated Object Instance. : serverId does not refer to a known Server Short ID nor IOWA_ACL_DEFAULT_ID . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_access_control_list.h Notes accessRights is a bit field which can contain the following values: IOWA_ACL_NONE_RIGHT : No access IOWA_ACL_READ_RIGHT : Read access IOWA_ACL_WRITE_RIGHT : Write access IOWA_ACL_EXECUTE_RIGHT : Execute access IOWA_ACL_DELETE_RIGHT : Delete access IOWA_ACL_CREATE_RIGHT : Create access If access rights are already set for the targeted objectId , instanceId and serverId , they will be overwritten. Access rights set through iowa_client_acl_rights_server_set() cannot be modified by any Server, since the Server Owner ID will be IOWA_LWM2M_ID_ALL (means Bootstrap Server). To set the default access rights, serverId can be IOWA_ACL_DEFAULT_ID . \\clearpage","title":"iowa_client_acl_rights_server_set"},{"location":"ClientAPI/#iowa_client_acl_rights_server_clear","text":"Prototype iowa_status_t iowa_client_acl_rights_server_clear ( iowa_context_t contextP , uint16_t objectId , uint16_t instanceId , uint16_t serverId ); Description iowa_client_acl_rights_server_clear() unset the access rights for a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectId : ID of the Object. instanceId : ID of the Object Instance. serverId : Short Server ID of a LwM2M Server or IOWA_ACL_DEFAULT_ID . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : objectId or serverId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : objectId , instanceId or serverId do not have access rights set. Header File objects/iowa_access_control_list.h \\clearpage","title":"iowa_client_acl_rights_server_clear"},{"location":"ClientAPI/#iowa_client_acl_rights_object_clear","text":"Prototype iowa_status_t iowa_client_acl_rights_object_clear ( iowa_context_t contextP , uint16_t objectId , uint16_t instanceId ); Description iowa_client_acl_rights_object_clear() clears the access rights for an Object/Object Instance. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. objectId : ID of the Object. instanceId : ID of the Object Instance. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : objectId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : objectId or instanceId do not have access rights set. Header File objects/iowa_access_control_list.h \\clearpage","title":"iowa_client_acl_rights_object_clear"},{"location":"ClientAPI/#apn-connection-profile-object-api","text":"This LwM2M object specifies resources to enable a device to connect to an APN. To be able to use this object, iowa_apn_connection_profile.h must be included.","title":"APN Connection Profile Object API"},{"location":"ClientAPI/#data-structures-and-constants","text":"","title":"Data Structures and Constants"},{"location":"ClientAPI/#iowa_apn_connection_profile_details_t","text":"typedef struct { char * apn ; bool autoSelect ; bool enableStatus ; uint8_t authenticationType ; char * userName ; char * secret ; char * reconnectSchedule ; char ** validityList ; uint16_t validityNumber ; uint32_t * connectionEstablishmentTimeList ; uint16_t connectionEstablishmentTimeNumber ; uint8_t * connectionEstablishmentResultList ; uint16_t connectionEstablishmentResultNumber ; uint8_t * connectionEstablishmentRejectCauseList ; uint16_t connectionEstablishmentRejectCauseNumber ; uint32_t * connectionEndTimeList ; uint16_t connectionEndTimeNumber ; uint32_t totalBytesSent ; uint32_t totalBytesReceived ; char ** ipAddressList ; uint16_t ipAddressNumber ; char ** prefixLengthList ; uint16_t prefixLengthNumber ; char ** subnetMaskList ; uint16_t subnetMaskNumber ; char ** gatewayList ; uint16_t gatewayNumber ; char ** primaryDnsAddressList ; uint16_t primaryDnsAddressNumber ; char ** secondaryDnsAddressList ; uint16_t secondaryDnsAddressNumber ; uint8_t qci ; uint32_t totalPacketsSent ; uint8_t pdnType ; uint32_t apnRateControl ; } iowa_apn_connection_profile_details_t ; apn : APN of the APN connection profile. autoSelect : It enables the device to choose an APN according to a device specific algorithm. enableStatus : Allows the profile to be remotely activated or deactivated. authenticationType : 0: PAP, 1: CHAP, 2: PAP or CHAP, 3: None. userName : Used with e.g. PAP. secret : Used with e.g. PAP. reconnectSchedule : List of retry delay values in seconds to be used in case of unsuccessful connection establishment attempts. validity : Coma separated mobile country code, then mobile network code. connectionEstablishmentTime : UTC time of connection request. connectionEstablishmentResult : 0 = accepted, 1 = rejected. connectionEstablishmentRejectCause : Reject cause. connectionEndTime : UTC time of connection end. totalBytesSent : Rolling counter for total number of bytes sent via this interface since last device reset. totalBytesReceived : Rolling counter for total number of bytes sent via this interface since last device reset. ipAddress : May be IPv4 or IPv6 address. prefixLength : Associated with IPv6 address. subnetMask : Subnet mask. gateway : Gateway. primaryDnsAddress : Primary DNS address. secondaryDnsAddress : Secondary DNS address. qci : Quality of service Class Identifier. For LTE and NB-IoT only. totalPacketsSent : Rolling counter for total number of packets sent via this interface since last device reset. pdnType : 0=Non-IP, 1=IPv4, 2=IPv6, 3=IPv4v6. apnRateControl : Number of allowed uplink PDU transmissions per time interval per APN. \\clearpage","title":"iowa_apn_connection_profile_details_t"},{"location":"ClientAPI/#callbacks_1","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_apn_connection_profile_update_callback_t","text":"This callback is called when the Server writes new information on the APN connection profile object. typedef iowa_status_t ( * iowa_apn_connection_profile_update_callback_t )( char * profileName , iowa_dm_operation_t operation , uint32_t flags , iowa_apn_connection_profile_details_t * detailsP , void * userDataCallback , iowa_context_t contextP ); profileName : Unique name of the APN connection profile. This may be new. operation : The operation performed by the Server on this APN connection profile (creation, deletion, or write). flags : Specify values set in detailsP. detailsP : APN connection profile details. This may be nil. userDataCallback : User data callback. contextP : The IOWA context.","title":"iowa_apn_connection_profile_update_callback_t"},{"location":"ClientAPI/#return-value","text":"IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"Return Value"},{"location":"ClientAPI/#api_1","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_enable_apn_connection_profile_object","text":"","title":"iowa_client_enable_apn_connection_profile_object"},{"location":"ClientAPI/#prototype","text":"iowa_status_t iowa_client_enable_apn_connection_profile_object ( iowa_context_t contextP , iowa_apn_connection_profile_update_callback_t updateCallback , void * userDataCallback );","title":"Prototype"},{"location":"ClientAPI/#description","text":"iowa_client_enable_apn_connection_profile_object() enables APN connection profiles management.","title":"Description"},{"location":"ClientAPI/#arguments","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. updateCallback : Called to update state of the APN connection profile. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil.","title":"Arguments"},{"location":"ClientAPI/#return-value_1","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no update state callback provided means updateCallback is nil. IOWA_COAP_409_CONFLICT : APN connection profiles management was already enabled. Call first iowa_client_disable_apn_connection_profile_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file","text":"objects/iowa_apn_connection_profile.h","title":"Header File"},{"location":"ClientAPI/#notes_1","text":"Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_disable_apn_connection_profile_object","text":"","title":"iowa_client_disable_apn_connection_profile_object"},{"location":"ClientAPI/#prototype_1","text":"iowa_status_t iowa_client_disable_apn_connection_profile_object ( iowa_context_t contextP );","title":"Prototype"},{"location":"ClientAPI/#description_1","text":"iowa_client_disable_apn_connection_profile_object() disables APN connection profiles management.","title":"Description"},{"location":"ClientAPI/#arguments_1","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"Arguments"},{"location":"ClientAPI/#return-value_2","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : APN connection profiles management was not enabled. iowa_client_enable_apn_connection_profile_object() was not called before, or failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_1","text":"objects/iowa_apn_connection_profile.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_add_apn_connection_profile","text":"","title":"iowa_client_add_apn_connection_profile"},{"location":"ClientAPI/#prototype_2","text":"iowa_status_t iowa_client_add_apn_connection_profile ( iowa_context_t contextP , const char * profileName , uint32_t optFlags , iowa_apn_connection_profile_details_t * detailsP );","title":"Prototype"},{"location":"ClientAPI/#description_2","text":"iowa_client_add_apn_connection_profile() add an APN connection profile.","title":"Description"},{"location":"ClientAPI/#arguments_2","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. profileName : Unique name of the APN connection profile. optFlags : Optional flags to add optional resources. detailsP : Apn connection profile details.","title":"Arguments"},{"location":"ClientAPI/#return-value_3","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : inconsistent data inside detailsP . IOWA_COAP_406_NOT_ACCEPTABLE : either: : - no profile name provided means profileName is nil. : - no details provided means detailsP is nil. : - authenticationType 's value is outside the [0, 3] range. : - connectionEstablishmentResult 's value is different of 0 or 1. : - connectionEstablishmentRejectCause 's value is outside the [0, 111] range. : - qci 's value is outside the [0, 9] range. : - pdnType 's value is outside the [0, 3] range. IOWA_COAP_409_CONFLICT : APN connection profile with profileName already exists. IOWA_COAP_412_PRECONDITION_FAILED : APN connection profile management was not enabled. Call first iowa_client_enable_apn_connection_profile_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_2","text":"objects/iowa_apn_connection_profile.h","title":"Header File"},{"location":"ClientAPI/#notes_2","text":"When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_APN_CONNECTION_PROFILE_RSC_APN IOWA_APN_CONNECTION_PROFILE_RSC_AUTO_SELECT_APN_DEVICE IOWA_APN_CONNECTION_PROFILE_RSC_ENABLE_STATUS IOWA_APN_CONNECTION_PROFILE_RSC_USER_NAME IOWA_APN_CONNECTION_PROFILE_RSC_SECRET IOWA_APN_CONNECTION_PROFILE_RSC_RECONNECT_SCHEDULE IOWA_APN_CONNECTION_PROFILE_RSC_VALIDITY IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_TIME IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_RESULT IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_REJECT_CAUSE IOWA_APN_CONNECTION_PROFILE_RSC_CONNECTION_END_TIME IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_SENT IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_RECEIVED IOWA_APN_CONNECTION_PROFILE_RSC_IP_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_PREFIX_LENGTH IOWA_APN_CONNECTION_PROFILE_RSC_SUBNET_MASK IOWA_APN_CONNECTION_PROFILE_RSC_GATEWAY IOWA_APN_CONNECTION_PROFILE_RSC_PRIMARY_DNS_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_SECONDARY_DNS_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_QCI IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_PACKETS_SENT IOWA_APN_CONNECTION_PROFILE_RSC_PDN_TYPE IOWA_APN_CONNECTION_PROFILE_RSC_APN_RATE_CONTROL \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_apn_connection_profile","text":"","title":"iowa_client_remove_apn_connection_profile"},{"location":"ClientAPI/#prototype_3","text":"iowa_status_t iowa_client_remove_apn_connection_profile ( iowa_context_t contextP , const char * profileName );","title":"Prototype"},{"location":"ClientAPI/#description_3","text":"iowa_client_remove_apn_connection_profile() removes an APN connection profile created with iowa_client_add_apn_connection_profile() .","title":"Description"},{"location":"ClientAPI/#arguments_3","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. profileName : Unique name of the APN connection profile.","title":"Arguments"},{"location":"ClientAPI/#return-value_4","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : profileName does not match any known APN connection profile. IOWA_COAP_406_NOT_ACCEPTABLE : no profile name provided meaning profileName is nil. IOWA_COAP_412_PRECONDITION_FAILED : APN connection profile management was not enabled. Call first iowa_client_enable_apn_connection_profile_object() .","title":"Return Value"},{"location":"ClientAPI/#header-file_3","text":"objects/iowa_apn_connection_profile.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_update_apn_connection_profile","text":"","title":"iowa_client_update_apn_connection_profile"},{"location":"ClientAPI/#prototype_4","text":"iowa_status_t iowa_client_update_apn_connection_profile ( iowa_context_t contextP , const char * profileName , uint32_t flags , iowa_apn_connection_profile_details_t * detailsP );","title":"Prototype"},{"location":"ClientAPI/#description_4","text":"iowa_client_update_apn_connection_profile() updates an APN connection profile.","title":"Description"},{"location":"ClientAPI/#arguments_4","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. profileName : Unique name of the APN connection profile. flags : Specify resources to update. detailsP : The APN connection profile details.","title":"Arguments"},{"location":"ClientAPI/#return-value_5","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : inconsistent data inside detailsP . IOWA_COAP_404_NOT_FOUND : APN connection profile does not exist. Add first the profile with iowa_client_add_apn_connection_profile() . IOWA_COAP_406_NOT_ACCEPTABLE : either: : - no profile name provided means profileName is nil. : - no details provided means detailsP is nil. : - authenticationType 's value is outside the [0, 3] range. : - connectionEstablishmentResult 's value is different of 0 or 1. : - connectionEstablishmentRejectCause 's value is outside the [0, 111] range. : - qci 's value is outside the [0, 9] range. : - pdnType 's value is outside the [0, 3] range. IOWA_COAP_412_PRECONDITION_FAILED : APN connection profile management was not enabled. Call first iowa_client_enable_apn_connection_profile_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_4","text":"objects/iowa_apn_connection_profile.h","title":"Header File"},{"location":"ClientAPI/#notes_3","text":"To specify resources to update, you can use the following flags: IOWA_APN_CONNECTION_PROFILE_RSC_APN IOWA_APN_CONNECTION_PROFILE_RSC_AUTO_SELECT_APN_DEVICE IOWA_APN_CONNECTION_PROFILE_RSC_ENABLE_STATUS IOWA_APN_CONNECTION_PROFILE_RSC_AUTHENTICATION_TYPE IOWA_APN_CONNECTION_PROFILE_RSC_USER_NAME IOWA_APN_CONNECTION_PROFILE_RSC_SECRET IOWA_APN_CONNECTION_PROFILE_RSC_RECONNECT_SCHEDULE IOWA_APN_CONNECTION_PROFILE_RSC_VALIDITY IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_TIME IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_RESULT IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_REJECT_CAUSE IOWA_APN_CONNECTION_PROFILE_RSC_CONNECTION_END_TIME IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_SENT IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_RECEIVED IOWA_APN_CONNECTION_PROFILE_RSC_IP_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_PREFIX_LENGTH IOWA_APN_CONNECTION_PROFILE_RSC_SUBNET_MASK IOWA_APN_CONNECTION_PROFILE_RSC_GATEWAY IOWA_APN_CONNECTION_PROFILE_RSC_PRIMARY_DNS_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_SECONDARY_DNS_ADDRESS IOWA_APN_CONNECTION_PROFILE_RSC_QCI IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_PACKETS_SENT IOWA_APN_CONNECTION_PROFILE_RSC_PDN_TYPE IOWA_APN_CONNECTION_PROFILE_RSC_APN_RATE_CONTROL \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_get_apn_connection_profile_object_link","text":"","title":"iowa_client_get_apn_connection_profile_object_link"},{"location":"ClientAPI/#prototype_5","text":"iowa_status_t iowa_client_get_apn_connection_profile_object_link ( iowa_context_t contextP , const char * profileName , iowa_lwm2m_object_link_t * objectLinkP );","title":"Prototype"},{"location":"ClientAPI/#description_5","text":"iowa_client_get_apn_connection_profile_object_link() retrieves the LwM2M Object Link to an APN connection profile.","title":"Description"},{"location":"ClientAPI/#arguments_5","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. profileName : Unique name of the APN connection profile. objectLinkP : Pointer to an iowa_lwm2m_object_link_t where to store the LwM2M Object Link to the APN connection profile.","title":"Arguments"},{"location":"ClientAPI/#return-value_6","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : APN connection profile does not exist. Add first the profile with iowa_client_add_apn_connection_profile() . IOWA_COAP_406_NOT_ACCEPTABLE : profileName or objectLinkP is nil. IOWA_COAP_412_PRECONDITION_FAILED : APN connection profile management was not enabled. Call first iowa_client_enable_apn_connection_profile_object() .","title":"Return Value"},{"location":"ClientAPI/#header-file_5","text":"objects/iowa_apn_connection_profile.h","title":"Header File"},{"location":"ClientAPI/#notes_4","text":"This function is useful to fill the activatedProfileNamesList field of the iowa_cellular_connectivity_info_t structure. \\clearpage","title":"Notes"},{"location":"ClientAPI/#at-command-object-api","text":"This LwM2M object can be used to execute an AT command on a cellular modem. To be able to use this object, iowa_at_command.h must be included.","title":"AT Command Object API"},{"location":"ClientAPI/#callbacks_2","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_at_command_run_t","text":"This callback is used to execute an AT command. typedef iowa_status_t ( * iowa_at_command_run_t )( iowa_sensor_t id , char * command , int timeout , void * userDataCallback , iowa_context_t contextP ); id : ID of the object. command : The AT command to run. timeout : Amount of time in seconds allowed for the modem to respond to the command. userDataCallback : Application specific data from iowa_client_add_at_command_object . Can be nil. contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"iowa_at_command_run_t"},{"location":"ClientAPI/#return-value_7","text":"IOWA_COAP_NO_ERROR in case of success or an error status.","title":"Return Value"},{"location":"ClientAPI/#header-file_6","text":"objects/iowa_at_command.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#api_2","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_add_at_command_object","text":"","title":"iowa_client_add_at_command_object"},{"location":"ClientAPI/#prototype_6","text":"iowa_status_t iowa_client_add_at_command_object ( iowa_context_t contextP , uint16_t optFlags , iowa_at_command_run_t run , void * userDataCallback , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_6","text":"iowa_client_add_at_command_object() creates an AT Command object.","title":"Description"},{"location":"ClientAPI/#arguments_6","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. run : Called to send an AT command to the modem. userDataCallback : Application specific data pass to the callback. Can be nil. idP : Used to store the ID of the object.","title":"Arguments"},{"location":"ClientAPI/#return-value_8","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no run callback provided means run is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_7","text":"objects/iowa_at_command.h","title":"Header File"},{"location":"ClientAPI/#notes_5","text":"Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_AT_COMMAND_RSC_TIMEOUT \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_at_command_object","text":"","title":"iowa_client_remove_at_command_object"},{"location":"ClientAPI/#prototype_7","text":"iowa_status_t iowa_client_remove_at_command_object ( iowa_context_t contextP , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_7","text":"iowa_client_remove_at_command_object() removes an AT Command object.","title":"Description"},{"location":"ClientAPI/#arguments_7","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_9","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an AT Command object. Valid id are only returned by iowa_client_add_at_command_object() . IOWA_COAP_404_NOT_FOUND : AT Command referred by id does not exist.","title":"Return Value"},{"location":"ClientAPI/#header-file_8","text":"objects/iowa_at_command.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_at_command_set_response","text":"","title":"iowa_client_at_command_set_response"},{"location":"ClientAPI/#prototype_8","text":"iowa_status_t iowa_client_at_command_set_response ( iowa_context_t contextP , iowa_sensor_t id , const char * command , const char * response , const char * status );","title":"Prototype"},{"location":"ClientAPI/#description_8","text":"iowa_client_at_command_set_response() updates result values after having executed an AT command.","title":"Description"},{"location":"ClientAPI/#arguments_8","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. command : The executed AT command. response : Response to the command. status : Status of the command execution as returned by the modem.","title":"Arguments"},{"location":"ClientAPI/#return-value_10","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an AT Command object. Valid id are only returned by iowa_client_add_at_command_object() . IOWA_COAP_404_NOT_FOUND : AT Command referred by id does not exist. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_9","text":"objects/iowa_at_command.h","title":"Header File"},{"location":"ClientAPI/#notes_6","text":"response and status can spread on multiple lines. To reset response and status update their values with empty string : - iowa_client_at_command_set_response(contextP, Id, NULL, NULL, \"\"); to reset the AT command's status. - iowa_client_at_command_set_response(contextP, Id, NULL, \"\", NULL); to reset the AT command's response. \\clearpage","title":"Notes"},{"location":"ClientAPI/#bearer-selection-object-api","text":"This LwM2M object allows via remote bearer and network configuration to overwrite automatic network and bearer selection e.g. as supported by the UICC. To be able to use this object, iowa_bearer_selection.h must be included.","title":"Bearer Selection Object API"},{"location":"ClientAPI/#data-structures-and-constants_1","text":"","title":"Data Structures and Constants"},{"location":"ClientAPI/#iowa_bearer_selection_info_t","text":"typedef struct { uint8_t * preferredCommBearerList ; uint16_t preferredCommBearerNumber ; int8_t acceptableGsm ; int8_t acceptableUmts ; int16_t acceptableLte ; int16_t acceptableEvDo ; char * cellLockList ; char * operatorList ; bool operatorListMode ; char * availablePlmns ; int16_t acceptableRsrpNbIot ; int32_t plmnSearchTimer ; bool attachWoPdnConnection ; } iowa_bearer_selection_info_t ; preferredCommBearer : Preferred communications bearer. acceptableGsm : Provides guide to the application when performing manual network selection. acceptableUmts : Provides guide to the application when performing manual network selection. acceptableLte : Provides guide to the application when performing manual network selection. acceptableEvDo : Provides guide to the application when performing manual network selection. cellLockList : List of allowed Global Cell Identities. operatorList : List of MCC+MNC of operators, in priority order. operatorListMode : Indicates whether resource operator list represents the allowed operator list (white list), or, the preferred operator list. availablePlmns : Allows server to see results of network scan. acceptableRsrpNbIot : Provides guide to the application when performing manual network selection. plmnSearchTimer : Interval between periodic searches for higher priority PLMNs. attachWoPdnConnection : 0=attach with PDN connection, 1=attach without PDN connection \\clearpage","title":"iowa_bearer_selection_info_t"},{"location":"ClientAPI/#callbacks_3","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_bearer_selection_update_state_callback_t","text":"This callback is called when the Server writes new information on the Bearer selection object. typedef iowa_status_t ( * iowa_bearer_selection_update_state_callback_t ) ( iowa_sensor_t id , iowa_bearer_selection_info_t * infoP , void * userDataCallback , iowa_context_t contextP ); id : The instance of the Bearer selection. infoP : The bearer selection info. userDataCallback : The user data callback. contextP : The IOWA context.","title":"iowa_bearer_selection_update_state_callback_t"},{"location":"ClientAPI/#return-value_11","text":"IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"Return Value"},{"location":"ClientAPI/#api_3","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_add_bearer_selection_object","text":"","title":"iowa_client_add_bearer_selection_object"},{"location":"ClientAPI/#prototype_9","text":"iowa_status_t iowa_client_add_bearer_selection_object ( iowa_context_t contextP , uint16_t optFlags , iowa_bearer_selection_update_state_callback_t updateStateCallback , void * userDataCallback , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_9","text":"iowa_client_add_bearer_selection_object() creates a Bearer selection object.","title":"Description"},{"location":"ClientAPI/#arguments_9","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. updateStateCallback : Called to update state of the bearer selection. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. idP : Used to store the ID of the object.","title":"Arguments"},{"location":"ClientAPI/#return-value_12","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - optFlags is equals to zero. : - no update state callback provided means updateStateCallback is nil. IOWA_COAP_409_CONFLICT : a bearer selection object already exists. To reconfigure the bearer selection object, call first iowa_client_remove_bearer_selection_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_10","text":"objects/iowa_bearer_selection.h","title":"Header File"},{"location":"ClientAPI/#notes_7","text":"Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... Since this object has no mandatory resource, at least one optional resource must be used. To add optional resources, you can use the following flags: IOWA_BEARER_SELECTION_RSC_PREFERRED_COMM_BEARER IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_GSM IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSCP_UMTS IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_LTE IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_EV_DO IOWA_BEARER_SELECTION_RSC_CELL_LOCK_LIST IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST_MODE IOWA_BEARER_SELECTION_RSC_AVAILABLE_PLMNS IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_NB_IOT IOWA_BEARER_SELECTION_RSC_PLMN_SEARCH_TIMER IOWA_BEARER_SELECTION_RSC_ATTACH_WO_PDN_CONNECTION \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_bearer_selection_object","text":"","title":"iowa_client_remove_bearer_selection_object"},{"location":"ClientAPI/#prototype_10","text":"iowa_status_t iowa_client_remove_bearer_selection_object ( iowa_context_t contextP , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_10","text":"iowa_client_remove_bearer_selection_object() removes a Bearer selection object.","title":"Description"},{"location":"ClientAPI/#arguments_10","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_13","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a bearer selection object. Valid id are only returned by iowa_client_add_bearer_selection_object() . IOWA_COAP_404_NOT_FOUND : bearer selection referred by id does not exist.","title":"Return Value"},{"location":"ClientAPI/#header-file_11","text":"objects/iowa_bearer_selection.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_bearer_selection_update","text":"","title":"iowa_client_bearer_selection_update"},{"location":"ClientAPI/#prototype_11","text":"iowa_status_t iowa_client_bearer_selection_update ( iowa_context_t contextP , iowa_sensor_t id , uint16_t flags , iowa_bearer_selection_info_t * infoP );","title":"Prototype"},{"location":"ClientAPI/#description_11","text":"iowa_client_bearer_selection_update() updates the Bearer selection information.","title":"Description"},{"location":"ClientAPI/#arguments_11","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. flags : Optional flags to update resources. info : The Bearer selection information to update.","title":"Arguments"},{"location":"ClientAPI/#return-value_14","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a bearer selection object. Valid id are only returned by iowa_client_add_bearer_selection_object() . IOWA_COAP_404_NOT_FOUND : bearer selection referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - acceptableGsm 's value is outside the [-48, -110] range. : - acceptableUmts 's value is outside the [-25, -120] range. : - acceptableLte 's value is outside the [-44, -140] range. : - acceptableRsrpNbIot 's value is outside the [-44, -158] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_12","text":"objects/iowa_bearer_selection.h","title":"Header File"},{"location":"ClientAPI/#notes_8","text":"To specify resources to update, you can use the following flags: IOWA_BEARER_SELECTION_RSC_PREFERRED_COMM_BEARER IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_GSM IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSCP_UMTS IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_LTE IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_EV_DO IOWA_BEARER_SELECTION_RSC_CELL_LOCK_LIST IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST_MODE IOWA_BEARER_SELECTION_RSC_AVAILABLE_PLMNS IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_NB_IOT IOWA_BEARER_SELECTION_RSC_PLMN_SEARCH_TIMER IOWA_BEARER_SELECTION_RSC_ATTACH_WO_PDN_CONNECTION \\clearpage","title":"Notes"},{"location":"ClientAPI/#cellular-connectivity-object-api","text":"This LwM2M object specifies resources to enable a device to connect to a 3GPP or 3GPP2 bearer, including GPRS/EDGE, UMTS, LTE, NB-IoT, SMS. To be able to use this object, iowa_cellular_connectivity.h must be included.","title":"Cellular Connectivity Object API"},{"location":"ClientAPI/#data-structures-and-constants_2","text":"","title":"Data Structures and Constants"},{"location":"ClientAPI/#iowa_cellular_connectivity_info_t","text":"typedef struct { iowa_lwm2m_object_link_t * activatedProfileNamesList ; uint16_t activatedProfileNamesNumber ; char * smsc ; int32_t disableRadioPeriod ; char * moduleActivationCode ; int32_t psmTimer ; int32_t activeTimer ; uint32_t servingPlmnRateControl ; char * edrxParamIuMode ; char * edrxParamWbS1Mode ; char * edrxParamNbS1Mode ; char * edrxParamAGbmMode ; } iowa_cellular_connectivity_info_t ; activatedProfileNamesList : list of links to instances of the APN connection profile object representing every APN connection profile that has an activated connection to a PDN. activatedProfileNamesNumber : number of links to instances of the APN connection profile object representing every APN connection profile that has an activated connection to a PDN. smsc : address of the sms center. disableRadioPeriod : time period for which the device shall disconnect from cellular radio. moduleActivationCode : configurable in case the application needs to issue a code. psmTimer : Power Saving Mode timer. activeTimer : active timer. servingPlmnRateControl : maximum number of allowed uplink PDU transmissions. edrxParamIuMode : Extended DRX parameters for lu mode. edrxParamWbS1Mode : Extended DRX parameters for WB-S1 mode. edrxParamNbS1Mode : Extended DRX parameters for NB-S1 mode. edrxParamAGbmMode : Extended DRX parameters for A/Gb mode. \\clearpage","title":"iowa_cellular_connectivity_info_t"},{"location":"ClientAPI/#callbacks_4","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_cellular_connectivity_update_state_callback_t","text":"This callback is called when the Server writes new information on the Cellular connectivity object. typedef iowa_status_t ( * iowa_cellular_connectivity_update_state_callback_t )( iowa_sensor_t id , iowa_cellular_connectivity_info_t * infoP , void * userDataCallback , iowa_context_t contextP ); id : The instance of the Cellular connectivity. infoP : The Cellular connectivity info. userDataCallback : The user data callback. contextP : The IOWA context.","title":"iowa_cellular_connectivity_update_state_callback_t"},{"location":"ClientAPI/#return-value_15","text":"IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"Return Value"},{"location":"ClientAPI/#api_4","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_add_cellular_connectivity_object","text":"","title":"iowa_client_add_cellular_connectivity_object"},{"location":"ClientAPI/#prototype_12","text":"iowa_status_t iowa_client_add_cellular_connectivity_object ( iowa_context_t contextP , uint16_t optFlags , iowa_cellular_connectivity_update_state_callback_t updateStateCallback , void * userDataCallback , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_12","text":"iowa_client_add_cellular_connectivity_object() creates a Cellular connectivity object.","title":"Description"},{"location":"ClientAPI/#arguments_12","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. updateStateCallback : Called to update state of the cellular connectivity. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. idP : Used to store the ID of the object.","title":"Arguments"},{"location":"ClientAPI/#return-value_16","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no update state callback provided means updateStateCallback is nil. IOWA_COAP_409_CONFLICT : a cellular connectivity object already exists. Call first iowa_client_remove_cellular_connectivity_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_13","text":"objects/iowa_cellular_connectivity.h","title":"Header File"},{"location":"ClientAPI/#notes_9","text":"Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_CELLULAR_CONNECTIVITY_RSC_SMSC_ADDRESS IOWA_CELLULAR_CONNECTIVITY_RSC_DISABLE_RADIO_PERIOD IOWA_CELLULAR_CONNECTIVITY_RSC_MODULE_ACTIVATION_CODE IOWA_CELLULAR_CONNECTIVITY_RSC_PSM_TIMER IOWA_CELLULAR_CONNECTIVITY_RSC_ACTIVE_TIMER IOWA_CELLULAR_CONNECTIVITY_RSC_PLMN_RATE_CONTROL IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_IU_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_WB_S1_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_NB_S1_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_A_GB_MODE \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_cellular_connectivity_object","text":"","title":"iowa_client_remove_cellular_connectivity_object"},{"location":"ClientAPI/#prototype_13","text":"iowa_status_t iowa_client_remove_cellular_connectivity_object ( iowa_context_t contextP , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_13","text":"iowa_client_remove_cellular_connectivity_object() removes a Cellular connectivity object.","title":"Description"},{"location":"ClientAPI/#arguments_13","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_17","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a cellular connectivity object. Valid id are only returned by iowa_client_add_cellular_connectivity_object() . IOWA_COAP_404_NOT_FOUND : cellular connectivity referred by id does not exist.","title":"Return Value"},{"location":"ClientAPI/#header-file_14","text":"objects/iowa_cellular_connectivity.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_cellular_connectivity_update","text":"","title":"iowa_client_cellular_connectivity_update"},{"location":"ClientAPI/#prototype_14","text":"iowa_status_t iowa_client_cellular_connectivity_update ( iowa_context_t contextP , iowa_sensor_t id , uint16_t flags , iowa_cellular_connectivity_info_t * infoP );","title":"Prototype"},{"location":"ClientAPI/#description_14","text":"iowa_client_cellular_connectivity_update() updates the Cellular connectivity information.","title":"Description"},{"location":"ClientAPI/#arguments_14","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. flags : Optional flags to update resources. infoP : The Cellular connectivity information to update.","title":"Arguments"},{"location":"ClientAPI/#return-value_18","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a cellular connectivity object. Valid id are only returned by iowa_client_add_cellular_connectivity_object() . IOWA_COAP_404_NOT_FOUND : cellular connectivity referred by id does not exist. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_15","text":"objects/iowa_cellular_connectivity.h","title":"Header File"},{"location":"ClientAPI/#notes_10","text":"To specify resources to update, you can use the following flags: IOWA_CELLULAR_CONNECTIVITY_RSC_SMSC_ADDRESS IOWA_CELLULAR_CONNECTIVITY_RSC_DISABLE_RADIO_PERIOD IOWA_CELLULAR_CONNECTIVITY_RSC_MODULE_ACTIVATION_CODE IOWA_CELLULAR_CONNECTIVITY_RSC_PSM_TIMER IOWA_CELLULAR_CONNECTIVITY_RSC_ACTIVE_TIMER IOWA_CELLULAR_CONNECTIVITY_RSC_PLMN_RATE_CONTROL IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_IU_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_WB_S1_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_NB_S1_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_A_GB_MODE IOWA_CELLULAR_CONNECTIVITY_RSC_ACTIVATED_PROFILE_NAMES \\clearpage","title":"Notes"},{"location":"ClientAPI/#connectivity-monitoring-object-api","text":"This LwM2M Object enables monitoring of parameters related to network connectivity. To be able to use this object, iowa_connectivity_monitoring.h must be included.","title":"Connectivity Monitoring Object API"},{"location":"ClientAPI/#data-structures-and-constants_3","text":"","title":"Data Structures and Constants"},{"location":"ClientAPI/#iowa_connectivity_monitoring_info_t","text":"typedef struct { uint8_t networkBearer ; uint8_t * availableNetworkBearerList ; uint8_t availableNetworkBearerNumber ; int16_t radioSignalStrength ; int16_t linkQuality ; char ** ipAddressList ; uint16_t ipAddressNumber ; char ** routerIpAddressesList ; uint16_t routerIpAddressesNumber ; uint8_t linkUtilization ; char ** apnList ; uint16_t apnNumber ; uint64_t cellId ; uint16_t smnc ; uint16_t smcc ; } iowa_connectivity_monitoring_info_t ; networkBearer : Network bearer used for the current session. availableNetworkBearerList : List of current available network bearers. availableNetworkBearerNumber : Number of current available network bearers. radioSignalStrength : Average value of the received signal strength indication. linkQuality : Received link quality. ipAddressList : List of IP addresses assigned to the connectivity interface. ipAddressNumber : Number of IP addresses assigned to the connectivity interface. routerIpAddressesList : List of IP addresses of the next-hop IP router. routerIpAddressesNumber : Number of IP addresses of the next-hop IP router. linkUtilization : The percentage indicating the average utilization of the link to the next-hop IP router. apnList : List of Access Point Names. apnNumber : Number of Access Point Names. cellId : Serving Cell ID. smnc : Serving Mobile Network Code. smcc : Serving Mobile Country Code. \\clearpage","title":"iowa_connectivity_monitoring_info_t"},{"location":"ClientAPI/#api_5","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_add_connectivity_monitoring_object","text":"","title":"iowa_client_add_connectivity_monitoring_object"},{"location":"ClientAPI/#prototype_15","text":"iowa_status_t iowa_client_add_connectivity_monitoring_object ( iowa_context_t contextP , uint16_t optFlags , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_15","text":"iowa_client_add_connectivity_monitoring_object() creates a Connectivity monitoring object.","title":"Description"},{"location":"ClientAPI/#arguments_15","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. idP : Used to store the ID of the object.","title":"Arguments"},{"location":"ClientAPI/#return-value_19","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_409_CONFLICT : a connectivity monitoring object already exists. Call first iowa_client_remove_connectivity_monitoring_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_16","text":"objects/iowa_connectivity_monitoring.h","title":"Header File"},{"location":"ClientAPI/#notes_11","text":"Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_CONNECTIVITY_MONITORING_RSC_LINK_QUALITY IOWA_CONNECTIVITY_MONITORING_RSC_ROUTER_IP_ADDR IOWA_CONNECTIVITY_MONITORING_RSC_LINK_USAGE IOWA_CONNECTIVITY_MONITORING_RSC_APN IOWA_CONNECTIVITY_MONITORING_RSC_CELL_ID IOWA_CONNECTIVITY_MONITORING_RSC_SMNC IOWA_CONNECTIVITY_MONITORING_RSC_SMCC \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_connectivity_monitoring_object","text":"","title":"iowa_client_remove_connectivity_monitoring_object"},{"location":"ClientAPI/#prototype_16","text":"iowa_status_t iowa_client_remove_connectivity_monitoring_object ( iowa_context_t contextP , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_16","text":"iowa_client_remove_connectivity_monitoring_object() removes a Connectivity monitoring object.","title":"Description"},{"location":"ClientAPI/#arguments_16","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_20","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a connectivity monitoring object. Valid id are only returned by iowa_client_add_connectivity_monitoring_object() . IOWA_COAP_404_NOT_FOUND : connectivity monitoring referred by id does not exist.","title":"Return Value"},{"location":"ClientAPI/#header-file_17","text":"objects/iowa_connectivity_monitoring.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_connectivity_monitoring_update","text":"","title":"iowa_client_connectivity_monitoring_update"},{"location":"ClientAPI/#prototype_17","text":"iowa_status_t iowa_client_connectivity_monitoring_update ( iowa_context_t contextP , iowa_sensor_t id , uint16_t flags , iowa_connectivity_monitoring_info_t * infoP );","title":"Prototype"},{"location":"ClientAPI/#description_17","text":"iowa_client_connectivity_monitoring_update() updates the Connectivity monitoring information.","title":"Description"},{"location":"ClientAPI/#arguments_17","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. flags : Optional flags to update resources. infoP : The Connectivity monitoring information to update.","title":"Arguments"},{"location":"ClientAPI/#return-value_21","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a connectivity monitoring object. Valid id are only returned by iowa_client_add_connectivity_monitoring_object() . IOWA_COAP_404_NOT_FOUND : connectivity monitoring referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - networkBearer 's value is outside the [0, 50] range. : - availableNetworkBearerList 's value is outside the [0, 50] range. : - linkUtilization 's value is outside the [0, 100] range. : - smnc 's value is outside the [0, 999] range. : - smcc 's value is outside the [0, 999] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_18","text":"objects/iowa_connectivity_monitoring.h","title":"Header File"},{"location":"ClientAPI/#notes_12","text":"To specify resources to update, you can use the following flags: IOWA_CONNECTIVITY_MONITORING_RSC_BEARER IOWA_CONNECTIVITY_MONITORING_RSC_AVAILABLE_BEARER IOWA_CONNECTIVITY_MONITORING_RSC_SIGNAL_STRENGTH IOWA_CONNECTIVITY_MONITORING_RSC_LINK_QUALITY IOWA_CONNECTIVITY_MONITORING_RSC_IP_ADDR IOWA_CONNECTIVITY_MONITORING_RSC_ROUTER_IP_ADDR IOWA_CONNECTIVITY_MONITORING_RSC_LINK_USAGE IOWA_CONNECTIVITY_MONITORING_RSC_APN IOWA_CONNECTIVITY_MONITORING_RSC_CELL_ID IOWA_CONNECTIVITY_MONITORING_RSC_SMNC IOWA_CONNECTIVITY_MONITORING_RSC_SMCC \\clearpage","title":"Notes"},{"location":"ClientAPI/#connectivity-statistics-object-api","text":"This LwM2M Object enables client to collect statistical information and enables the LwM2M Server to retrieve these information, set the collection duration and reset the statistical parameters. To be able to use this object, iowa_connectivity_stats.h must be included.","title":"Connectivity Statistics Object API"},{"location":"ClientAPI/#iowa_client_add_connectivity_stats_object","text":"Prototype iowa_status_t iowa_client_add_connectivity_stats_object ( iowa_context_t context , uint16_t optFlags , iowa_sensor_t * idP ); Description iowa_client_add_connectivity_stats_object() creates a connectivity statistics object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_409_CONFLICT : a connectivity statistics object already exists. To reconfigure the connectivity statistics object, call first iowa_client_remove_connectivity_stats_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_connectivity_stats.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_CONNECTIVITY_STATS_RSC_SMS_TX_COUNTER IOWA_CONNECTIVITY_STATS_RSC_SMS_RX_COUNTER IOWA_CONNECTIVITY_STATS_RSC_TX_DATA IOWA_CONNECTIVITY_STATS_RSC_RX_DATA IOWA_CONNECTIVITY_STATS_RSC_MAX_MESSAGE_SIZE IOWA_CONNECTIVITY_STATS_RSC_AVERAGE_MESSAGE_SIZE IOWA_CONNECTIVITY_STATS_RSC_COLLECTION_PERIOD Moreover, you can add several optional resources at one time by using the following flags: IOWA_CONNECTIVITY_STATS_SMS IOWA_CONNECTIVITY_STATS_IP_DATA \\clearpage","title":"iowa_client_add_connectivity_stats_object"},{"location":"ClientAPI/#iowa_client_remove_connectivity_stats_object","text":"Prototype iowa_status_t iowa_client_remove_connectivity_stats_object ( iowa_context_t contextP , iowa_sensor_t id ); Description iowa_client_remove_connectivity_stats_object() removes a connectivity statistics object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a connectivity statistics object. Valid id are only returned by iowa_client_add_connectivity_stats_object() . IOWA_COAP_404_NOT_FOUND : no connectivity statistics object to remove. iowa_client_add_connectivity_stats_object() was not called before, or failed. Header File objects/iowa_connectivity_stats.h \\clearpage","title":"iowa_client_remove_connectivity_stats_object"},{"location":"ClientAPI/#iowa_client_connectivity_stats_update_sms","text":"Prototype iowa_status_t iowa_client_connectivity_stats_update_sms ( iowa_context_t context , iowa_sensor_t id , uint8_t direction ); Description iowa_client_connectivity_stats_update_sms() updates the SMS TX or RX statistics. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object direction : Specify if this is a reception or a transmission trigger. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : Bad value for argument direction or id is not a connectivity statistics object. Valid id are only returned by iowa_client_add_connectivity_stats_object() . IOWA_COAP_404_NOT_FOUND : no connectivity statistics object added. Header File objects/iowa_connectivity_stats.h Notes Argument direction of iowa_client_connectivity_stats_update_sms() can be one of the following values: IOWA_CONNECTIVITY_STATS_TX (0) IOWA_CONNECTIVITY_STATS_RX (1) \\clearpage","title":"iowa_client_connectivity_stats_update_sms"},{"location":"ClientAPI/#iowa_client_connectivity_stats_update_ip_data","text":"Prototype iowa_status_t iowa_client_connectivity_stats_update_ip_data ( iowa_context_t context , iowa_sensor_t id , uint8_t direction , size_t length ); Description iowa_client_connectivity_stats_update_ip_data() updates the IP data statistics. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object. direction : Specify if this is a reception or a transmission trigger. length : Length in bytes of the transmitted or received data. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : Bad value for argument direction or id is not a connectivity statistics object. Valid id are only returned by iowa_client_add_connectivity_stats_object() . IOWA_COAP_404_NOT_FOUND : no connectivity statistics object added. Header File objects/iowa_connectivity_stats.h Notes Argument direction of iowa_client_connectivity_stats_update_ip_data() can be one of the following values: IOWA_CONNECTIVITY_STATS_TX (0) IOWA_CONNECTIVITY_STATS_RX (1) \\clearpage","title":"iowa_client_connectivity_stats_update_ip_data"},{"location":"ClientAPI/#digital-output-object-api","text":"This IPSO object represents generic digital output for non-specific actuators. To be able to use this object, iowa_digital_output.h must be included.","title":"Digital Output Object API"},{"location":"ClientAPI/#callbacks_5","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_digital_output_state_callback_t","text":"This callback is used to update the state of the digital output. Request from a server to a client. typedef iowa_status_t ( * iowa_digital_output_state_callback_t )( iowa_sensor_t id , bool state , bool polarity , void * userDataCallback , iowa_context_t contextP ); id : ID of the object state : New state polarity : New polarity userDataCallback : Application specific data from iowa_client_add_digital_output_object . Can be nil. contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"iowa_digital_output_state_callback_t"},{"location":"ClientAPI/#return-value_22","text":"IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"Return Value"},{"location":"ClientAPI/#api_6","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_add_digital_output_object","text":"","title":"iowa_client_add_digital_output_object"},{"location":"ClientAPI/#prototype_18","text":"iowa_status_t iowa_client_add_digital_output_object ( iowa_context_t context , uint16_t optFlags , iowa_digital_output_state_callback_t updateStateCallback , void * userDataCallback , const char * applicationType , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_18","text":"iowa_client_add_digital_output_object() creates a digital output object.","title":"Description"},{"location":"ClientAPI/#arguments_18","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. updateStateCallback : Called to update state of the digital output. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. applicationType : The application type idP : Used to store the ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_23","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no update state callback provided means updateStateCallback is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_19","text":"objects/iowa_digital_output.h","title":"Header File"},{"location":"ClientAPI/#notes_13","text":"Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_DIGITAL_OUTPUT_STATS_RSC_POLARITY \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_digital_output_object","text":"","title":"iowa_client_remove_digital_output_object"},{"location":"ClientAPI/#prototype_19","text":"iowa_status_t iowa_client_remove_digital_output_object ( iowa_context_t context , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_19","text":"iowa_client_remove_digital_output_object() removes a digital output object.","title":"Description"},{"location":"ClientAPI/#arguments_19","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_24","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a digital output object. Valid id are only returned by iowa_client_add_digital_output_object() . IOWA_COAP_404_NOT_FOUND : digital output referred by id does not exist.","title":"Return Value"},{"location":"ClientAPI/#header-file_20","text":"objects/iowa_digital_output.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_digital_output_update_state","text":"","title":"iowa_client_digital_output_update_state"},{"location":"ClientAPI/#prototype_20","text":"iowa_status_t iowa_client_digital_output_update_state ( iowa_context_t context , iowa_sensor_t id , bool state , bool polarity );","title":"Prototype"},{"location":"ClientAPI/#description_20","text":"iowa_client_digital_output_update_state() updates values of a digital output object.","title":"Description"},{"location":"ClientAPI/#arguments_20","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object state : New state polarity : New polarity","title":"Arguments"},{"location":"ClientAPI/#return-value_25","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a digital output object. Valid id are only returned by iowa_client_add_digital_output_object() . IOWA_COAP_404_NOT_FOUND : digital output referred by id does not exist.","title":"Return Value"},{"location":"ClientAPI/#header-file_21","text":"objects/iowa_digital_output.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#dimmer-object-api","text":"This IPSO object represents a dimmer. To be able to use this object, iowa_dimmer.h must be included.","title":"Dimmer Object API"},{"location":"ClientAPI/#callbacks_6","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_dimmer_state_callback_t","text":"This callback is used to update the state of the dimmer. Request from a server to a client. typedef iowa_status_t ( * iowa_dimmer_state_callback_t )( iowa_sensor_t id , float level , void * userDataCallback , iowa_context_t contextP ); id : ID of the object level : New level. userDataCallback : Application specific data from iowa_client_add_dimmer_object . Can be nil. contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"iowa_dimmer_state_callback_t"},{"location":"ClientAPI/#return-value_26","text":"IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"Return Value"},{"location":"ClientAPI/#api_7","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_add_dimmer_object","text":"","title":"iowa_client_add_dimmer_object"},{"location":"ClientAPI/#prototype_21","text":"iowa_status_t iowa_client_add_dimmer_object ( iowa_context_t context , uint16_t optFlags , float level , iowa_dimmer_state_callback_t updateStateCallback , void * userDataCallback , const char * applicationType , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_21","text":"iowa_client_add_dimmer_object() creates a dimmer object.","title":"Description"},{"location":"ClientAPI/#arguments_21","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. level : The initial value measured by the dimmer, must be inside the range [0.0; 100.0]. updateStateCallback : Called to update state of the dimmer. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. applicationType : The application type idP : Used to store the ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_27","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : level is outside the range [0.0; 100.0]. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_22","text":"objects/iowa_dimmer.h","title":"Header File"},{"location":"ClientAPI/#notes_14","text":"Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_DIMMER_RSC_ON_TIME IOWA_DIMMER_RSC_OFF_TIME \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_dimmer_object","text":"","title":"iowa_client_remove_dimmer_object"},{"location":"ClientAPI/#prototype_22","text":"iowa_status_t iowa_client_remove_dimmer_object ( iowa_context_t context , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_22","text":"iowa_client_remove_dimmer_object() removes a dimmer object.","title":"Description"},{"location":"ClientAPI/#arguments_22","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_28","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a dimmer object. Valid id are only returned by iowa_client_add_dimmer_object() . IOWA_COAP_404_NOT_FOUND : dimmer referred by id does not exist.","title":"Return Value"},{"location":"ClientAPI/#header-file_23","text":"objects/iowa_dimmer.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_dimmer_update_value","text":"","title":"iowa_client_dimmer_update_value"},{"location":"ClientAPI/#prototype_23","text":"iowa_status_t iowa_client_dimmer_update_value ( iowa_context_t contextP , iowa_sensor_t id , float level );","title":"Prototype"},{"location":"ClientAPI/#description_23","text":"iowa_client_dimmer_update_value() updates dimmer's level value.","title":"Description"},{"location":"ClientAPI/#arguments_23","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object level : New level value, must be inside the range [0.0; 100.0].","title":"Arguments"},{"location":"ClientAPI/#return-value_29","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a dimmer object. Valid id are only returned by iowa_client_add_dimmer_object() . IOWA_COAP_404_NOT_FOUND : dimmer referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : level is outside the range [0.0; 100.0]. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a call to iowa_system_gettime() failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_24","text":"objects/iowa_dimmer.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_dimmer_update_values","text":"","title":"iowa_client_dimmer_update_values"},{"location":"ClientAPI/#prototype_24","text":"iowa_status_t iowa_client_dimmer_update_values ( iowa_context_t contextP , iowa_sensor_t id , size_t valueCount , iowa_ipso_timed_value_t * valueArray );","title":"Prototype"},{"location":"ClientAPI/#description_24","text":"iowa_client_dimmer_update_values() updates dimmer's level value.","title":"Description"},{"location":"ClientAPI/#arguments_24","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object valueCount : The number of values in valueArray . valueArray : The iowa_ipso_timed_value_t list of new level values.","title":"Arguments"},{"location":"ClientAPI/#return-value_30","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a dimmer object. Valid id are only returned by iowa_client_add_dimmer_object() . IOWA_COAP_404_NOT_FOUND : dimmer referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : at least one valueArray value is outside the range [0.0; 100.0]. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed when either: : - the new level array's last value is greater than 0 and the previous one is 0. : - the new level array's last value is 0 and the previous one is greater than 0.","title":"Return Value"},{"location":"ClientAPI/#header-file_25","text":"objects/iowa_dimmer.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#firmware-update-object-api","text":"This LwM2M Object enables management of firmware which is to be updated. To be able to use this object, iowa_firmware_update.h must be included and IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT must be defined before building the library. The [ Device Update ][Device Update]/[ Firmware Update ][Firmware Update] part of this specification adds more explanation about its mechanism and how to use it with IOWA.","title":"Firmware Update Object API"},{"location":"ClientAPI/#data-structures-and-constants_4","text":"","title":"Data Structures and Constants"},{"location":"ClientAPI/#iowa_fw_status_t","text":"This is an enumeration of the following values: IOWA_FW_STATUS_SUCCESSFUL : success of the new firmware package download or of the firmware update. IOWA_FW_STATUS_OUT_OF_STORAGE : not enough storage for the new firmware package. ( downloadCb only) IOWA_FW_STATUS_OUT_OF_MEMORY : out of memory error during the download of the new firmware package. ( downloadCb only) IOWA_FW_STATUS_CONNECTION_LOST : connection lost during the download of the new firmware package. ( downloadCb only) IOWA_FW_STATUS_INTEGRITY_CHECK_FAILURE : integrity check failure of the new firmware package. IOWA_FW_STATUS_UNSUPPORTED_TYPE : unsupported new firmware package type. IOWA_FW_STATUS_INVALID_URI : invalid URI to download the new firmware package. ( downloadCb only) IOWA_FW_STATUS_UPDATE_FAILED : firmware update failed. ( updateCb only) IOWA_FW_STATUS_UNSUPPORTED_PROTOCOL : unsupported protocol in URI to download the new firmware package. ( downloadCb only) \\clearpage","title":"iowa_fw_status_t"},{"location":"ClientAPI/#callbacks_7","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_fw_download_callback_t","text":"This callback is called when the Server requests the device to download a new Firmware Package. typedef void ( * iowa_fw_download_callback_t ) ( char * uri , void * userData , iowa_context_t contextP ); uri : The URI to download the package from. userData : The parameter to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. uri can be nil. In this case, a current download must be aborted. \\clearpage","title":"iowa_fw_download_callback_t"},{"location":"ClientAPI/#iowa_fw_write_callback_t","text":"This callback is called several times when the Server pushes the new Firmware Package to the device. The expected behavior is the same as writing to a file stream i.e. unless it is reset, written data are appended to the previous ones. typedef iowa_fw_status_t ( * iowa_fw_write_callback_t ) ( iowa_fw_write_cmd_t cmd , size_t dataLength , uint8_t * data , void * userData , iowa_context_t contextP ); At the start of the push of the Firmware Package or if the LwM2M Server cancels it, this callback is called with the following parameters: cmd : IOWA_FW_PACKAGE_RESET dataLength : 0 data : NULL userData : The parameter to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. When the Firmware Package is received, this callback is called several times with the following parameters: cmd : IOWA_FW_PACKAGE_WRITE dataLength : The length of the buffer pointed by data . data : The next chunk of the Firmware Package to write. userData : The parameter to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. At the end of the push of the Firmware package, this callback is called with the following parameters: cmd : IOWA_FW_PACKAGE_WRITE dataLength : 0 data : NULL userDataP : The data passed to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called.","title":"iowa_fw_write_callback_t"},{"location":"ClientAPI/#return-value_31","text":"IOWA_FW_STATUS_SUCCESSFUL : success. IOWA_FW_STATUS_OUT_OF_STORAGE : not enough storage for the new Firmware Package. IOWA_FW_STATUS_OUT_OF_MEMORY : out of memory error. IOWA_FW_STATUS_INTEGRITY_CHECK_FAILURE : integrity check failure of the new Firmware Package. IOWA_FW_STATUS_UNSUPPORTED_TYPE : unsupported new Firmware Package type. \\clearpage","title":"Return Value"},{"location":"ClientAPI/#iowa_fw_update_callback_t","text":"This callback is called when the Server requests the device to update itself with the new Firmware Package. typedef void ( * iowa_fw_update_callback_t ) ( void * userData , iowa_context_t contextP ); userData : The parameter to iowa_client_firmware_update_configure() . contextP : The IOWA context on which iowa_client_firmware_update_configure() was called. \\clearpage","title":"iowa_fw_update_callback_t"},{"location":"ClientAPI/#api_8","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_firmware_update_configure","text":"","title":"iowa_client_firmware_update_configure"},{"location":"ClientAPI/#prototype_25","text":"iowa_status_t iowa_client_firmware_update_configure ( iowa_context_t contextP , const char * packageName , const char * packageVersion , iowa_fw_download_callback_t downloadCb , iowa_fw_write_callback_t writeCb , iowa_fw_update_callback_t updateCb , void * userData );","title":"Prototype"},{"location":"ClientAPI/#description_25","text":"iowa_client_firmware_update_configure() configures the firmware update feature of the IOWA stack.","title":"Description"},{"location":"ClientAPI/#arguments_25","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. packageName : The user-defined name of the current firmware. This can be nil. packageVersion : The user-defined version of the current firmware. This can be nil. downloadCb : The callback called to download a new firmware. This can be nil. writeCb : The callback called to write chunks of the new firmware to the device storage. This can be nil. updateCb : The callback called to update the device with the new firmware. userData : Passed as argument to the callbacks.","title":"Arguments"},{"location":"ClientAPI/#return-value_32","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_400_BAD_REQUEST : either: : - updateCb is nil. : - both downloadCb and writeCb are nil. At least one must be defined. IOWA_COAP_409_CONFLICT : the firmware update feature is already configured.","title":"Return Value"},{"location":"ClientAPI/#header-file_26","text":"objects/iowa_firmware_update.h","title":"Header File"},{"location":"ClientAPI/#notes_15","text":"The LwM2M Server has two methods to provide the Firmware Package: the pull method: the LwM2M Server provides the URI of the Firmware Package and the LwM2M Client downloads it directly. To use this method, downloadCb must be set. the push method: the LwM2M Server writes the Firmware Package in a LwM2M Resource exposed by the Client. To use this method, writeCb must be set. The Client can support both methods at the same time. downloadCb and updateCb do not return any value. The progress and result of their operation are indicated asynchronously by calling iowa_client_firmware_update_set_status() . \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_firmware_update_configure_full","text":"","title":"iowa_client_firmware_update_configure_full"},{"location":"ClientAPI/#prototype_26","text":"iowa_status_t iowa_client_firmware_update_configure_full ( iowa_context_t contextP , const char * packageName , const char * packageVersion , uint8_t protocolSupport , iowa_fw_download_callback_t downloadCb , iowa_fw_write_callback_t writeCb , iowa_fw_update_callback_t updateCb , void * userData );","title":"Prototype"},{"location":"ClientAPI/#description_26","text":"iowa_client_firmware_update_configure_full() configures the firmware update feature of the IOWA stack with the \"protocol support\" resource.","title":"Description"},{"location":"ClientAPI/#arguments_26","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. packageName : The user-defined name of the current firmware. This can be nil. packageVersion : The user-defined version of the current firmware. This can be nil. protocolSupport : A bit-mask indicating supported protocols in downloadCb . This can be 0. downloadCb : The callback called to download a new firmware. This can be nil. writeCb : The callback called to write chunks of the new firmware to the device storage. This can be nil. updateCb : The callback called to update the device with the new firmware. userData : Passed as argument to the callbacks.","title":"Arguments"},{"location":"ClientAPI/#return-value_33","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_400_BAD_REQUEST : either: : - updateCb is nil. : - both downloadCb and writeCb are nil. : - downloadCb is nil and protocolSupport is not 0. IOWA_COAP_409_CONFLICT : the firmware update feature is already configured.","title":"Return Value"},{"location":"ClientAPI/#header-file_27","text":"objects/iowa_firmware_update.h","title":"Header File"},{"location":"ClientAPI/#notes_16","text":"protocolSupport is a combination of the following: IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_COAP : Constrained Application Protocol (CoAP) IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_COAPS : DTLS-Secured CoAP IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_HTTP : HTTP 1.1 IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_HTTPS : TLS-Secured HTTP 1.1 IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_COAP_TCP : CoAP over TCP IOWA_FIRMWARE_UPDATE_PROTOCOL_SUPPORT_COAP_TLS : CoAP over TLS \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_firmware_update_set_status","text":"","title":"iowa_client_firmware_update_set_status"},{"location":"ClientAPI/#prototype_27","text":"iowa_status_t iowa_client_firmware_update_set_status ( iowa_context_t contextP , iowa_fw_status_t status );","title":"Prototype"},{"location":"ClientAPI/#description_27","text":"iowa_client_firmware_update_set_status() informs the IOWA stack of the result of the callbacks downloadCb and updateCb of iowa_client_firmware_update_configure() .","title":"Description"},{"location":"ClientAPI/#arguments_27","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. status : The result of the current firmware update operation.","title":"Arguments"},{"location":"ClientAPI/#return-value_34","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : the firmware update feature is not configured. Call first iowa_client_firmware_update_configure() . IOWA_COAP_412_PRECONDITION_FAILED : the value of status is unexpected. See iowa_fw_status_t for the possible value depending of the context.","title":"Return Value"},{"location":"ClientAPI/#header-file_28","text":"objects/iowa_firmware_update.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#gps-object-api","text":"This IPSO object represents GPS coordinates. To be able to use this object, iowa_gps.h must be included.","title":"GPS Object API"},{"location":"ClientAPI/#iowa_client_add_gps_object","text":"Prototype iowa_status_t iowa_client_add_gps_object ( iowa_context_t context , uint16_t optFlags , const char * applicationType , iowa_sensor_t * idP ); Description iowa_client_add_gps_object() creates a GPS object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. applicationType : The application type idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_gps.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_GPS_RSC_UNCERTAINTY IOWA_GPS_RSC_COMPASS_DIRECTION IOWA_GPS_RSC_VELOCITY IOWA_GPS_RSC_TIMESTAMP \\clearpage","title":"iowa_client_add_gps_object"},{"location":"ClientAPI/#iowa_client_remove_gps_object","text":"Prototype iowa_status_t iowa_client_remove_gps_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_gps_object() removes a GPS object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a GPS object. Valid id are only returned by iowa_client_add_gps_object() . IOWA_COAP_404_NOT_FOUND : GPS referred by id does not exist. Header File objects/iowa_gps.h \\clearpage","title":"iowa_client_remove_gps_object"},{"location":"ClientAPI/#iowa_client_gps_update_location","text":"Prototype iowa_status_t iowa_client_gps_update_location ( iowa_context_t context , iowa_sensor_t id , const char * latitude , const char * longitude ); Description iowa_client_gps_update_location() updates values of a GPS object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object latitude : New latitude longitude : New longitude Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a GPS object. Valid id are only returned by iowa_client_add_gps_object() . IOWA_COAP_404_NOT_FOUND : GPS referred by id does not exist. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. Header File objects/iowa_gps.h \\clearpage","title":"iowa_client_gps_update_location"},{"location":"ClientAPI/#iowa_client_gps_update_location_full","text":"Prototype iowa_status_t iowa_client_gps_update_location_full ( iowa_context_t context , iowa_sensor_t id , const char * latitude , const char * longitude , const char * uncertainty , float compassDirection , size_t velocityLength , uint8_t * velocity ); Description iowa_client_gps_update_location_full() updates values of a GPS object. Optionals resources are included. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object latitude : New latitude longitude : New longitude uncertainty : The accuracy of the position in meters. compassDirection : Measured Direction between 0 and 360 deg. velocityLength : Length of the velocity array velocity : The velocity of the device as defined in 3GPP 23.032 GAD specification. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a GPS object. Valid id are only returned by iowa_client_add_gps_object() . IOWA_COAP_404_NOT_FOUND : GPS referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : compassDirection 's value is outside the [0.0, 360.0] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. Header File objects/iowa_gps.h \\clearpage","title":"iowa_client_gps_update_location_full"},{"location":"ClientAPI/#gyrometer-object-api","text":"This IPSO Object is used to report the current reading of a gyrometer sensor in 3 axes. To be able to use this object, iowa_gyrometer.h must be included.","title":"Gyrometer Object API"},{"location":"ClientAPI/#iowa_client_add_gyrometer_object","text":"Prototype iowa_status_t iowa_client_add_gyrometer_object ( iowa_context_t context , uint16_t optFlags , float minRangeValue , float maxRangeValue , const char * sensorUnits , const char * applicationType , iowa_sensor_t * idP ); Description iowa_client_add_gyrometer_object() creates a gyrometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. minRangeValue : Minimal range value for the gyrometer. maxRangeValue : Maximal range value for the gyrometer. sensorUnits : Measurement units definition applicationType : The application type idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : minRangeValue argument is superior to maxRangeValue argument. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_gyrometer.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_GYROMETER_RSC_Y_VALUE IOWA_GYROMETER_RSC_Z_VALUE IOWA_GYROMETER_RSC_MIN_X_VALUE IOWA_GYROMETER_RSC_MAX_X_VALUE IOWA_GYROMETER_RSC_MIN_Y_VALUE IOWA_GYROMETER_RSC_MAX_Y_VALUE IOWA_GYROMETER_RSC_MIN_Z_VALUE IOWA_GYROMETER_RSC_MAX_Z_VALUE IOWA_GYROMETER_RSC_RESET_MIN_MAX_VALUES IOWA_GYROMETER_RSC_MIN_RANGE_VALUE IOWA_GYROMETER_RSC_MAX_RANGE_VALUE Moreover, you can add several optional resources at one time by using the following flags: IOWA_GYROMETER_3_AXIS IOWA_GYROMETER_MIN_MAX_VALUES IOWA_GYROMETER_RANGE_VALUE \\clearpage","title":"iowa_client_add_gyrometer_object"},{"location":"ClientAPI/#iowa_client_remove_gyrometer_object","text":"Prototype iowa_status_t iowa_client_remove_gyrometer_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_gyrometer_object() removes a gyrometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a gyrometer object. Valid id are only returned by iowa_client_add_gyrometer_object() . IOWA_COAP_404_NOT_FOUND : gyrometer referred by id does not exist. Header File objects/iowa_gyrometer.h \\clearpage","title":"iowa_client_remove_gyrometer_object"},{"location":"ClientAPI/#iowa_client_gyrometer_update_axis","text":"Prototype iowa_status_t iowa_client_gyrometer_update_axis ( iowa_context_t context , iowa_sensor_t id , float xValue , float yValue , float zValue ); Description iowa_client_gyrometer_update_axis() updates values of a gyrometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object xValue : X value axis yValue : Y value axis zValue : Z value axis Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a gyrometer object. Valid id are only returned by iowa_client_add_gyrometer_object() . IOWA_COAP_404_NOT_FOUND : gyrometer referred by id does not exist. Header File objects/iowa_gyrometer.h \\clearpage","title":"iowa_client_gyrometer_update_axis"},{"location":"ClientAPI/#ipso-objects","text":"This part allows the possibility to manipulate several IPSO Objects. To be able to use these objects, iowa_ipso.h must be included.","title":"IPSO Objects"},{"location":"ClientAPI/#iowa_client_ipso_add_sensor","text":"Prototype iowa_status_t iowa_client_IPSO_add_sensor ( iowa_context_t contextP , iowa_IPSO_ID_t type , float value , const char * unit , const char * appType , float rangeMin , float rangeMax , iowa_sensor_t * idP ); Description iowa_client_IPSO_add_sensor() adds a new IPSO sensor for the LwM2M Client to handle. The sensor is defined by its type. The unit, the application type and the range are only informative and reported as-is to the LwM2M Server. Note that the LwM2M Server can modify the application type. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The type of sensor. See below. value : The initial value measured by the sensor. unit : The unit of the measured value as a nil-terminated string. This can be nil. appType : The application type of the sensor as a free-form nil-terminated string. This can be nil. rangeMin : The minimum value that can be measured by the sensor. rangeMax : The maximum value that can be measured by the sensor. idP : Used to store the ID of the created sensor. Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : type is unknown. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - the sensor uses a Boolean value and value is neither 0.0 nor 1.0. : - the sensor uses a percentage value and value is outside the [0.0, 100.0] range. : - the sensor uses a compass direction value and value is outside the [0.0, 360.0] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. Header File objects/iowa_ipso.h Notes If both rangeMin and rangeMax are set to zero, the matching resources are ignored in the LwM2M Object. unit is not duplicated nor freed by IOWA. Make sure it is available until iowa_close() or iowa_client_IPSO_remove_sensor() is called. It is advised to use static strings. appType is duplicated internally by IOWA and can be reused or freed by the caller. Only a call to iowa_client_IPSO_remove_sensor() can free the memory allocated by iowa_client_IPSO_add_sensor() . If type equal to IOWA_IPSO_LEVEL_CONTROL this function will call iowa_client_add_dimmer_object() .","title":"iowa_client_IPSO_add_sensor"},{"location":"ClientAPI/#iowa_ipso_id_t","text":"This is an enumeration of the LwM2M IDs of the supported sensor types. See below.","title":"iowa_IPSO_ID_t"},{"location":"ClientAPI/#float-value-sensors","text":"IOWA_IPSO_ANALOG_INPUT (3202) IOWA_IPSO_GENERIC (3300) IOWA_IPSO_ILLUMINANCE (3301) IOWA_IPSO_TEMPERATURE (3303) IOWA_IPSO_HUMIDITY (3304) IOWA_IPSO_BAROMETER (3315) IOWA_IPSO_VOLTAGE (3316) IOWA_IPSO_CURRENT (3317) IOWA_IPSO_FREQUENCY (3318) IOWA_IPSO_DEPTH (3319) IOWA_IPSO_PERCENTAGE (3320) IOWA_IPSO_ALTITUDE (3321) IOWA_IPSO_LOAD (3322) IOWA_IPSO_PRESSURE (3323) IOWA_IPSO_LOUDNESS (3324) IOWA_IPSO_CONCENTRATION (3325) IOWA_IPSO_ACIDITY (3326) IOWA_IPSO_CONDUCTIVITY (3327) IOWA_IPSO_POWER (3328) IOWA_IPSO_POWER_FACTOR (3329) IOWA_IPSO_RATE (3346) IOWA_IPSO_DISTANCE (3330) IOWA_IPSO_ENERGY (3331)","title":"Float value sensors"},{"location":"ClientAPI/#boolean-value-sensors","text":"For these sensors, the value must be either 0.0 or 1.0: IOWA_IPSO_DIGITAL_INPUT (3200) IOWA_IPSO_PRESENCE (3302) IOWA_IPSO_ON_OFF_SWITCH (3342) IOWA_IPSO_PUSH_BUTTON (3347)","title":"Boolean value sensors"},{"location":"ClientAPI/#percentage-value-sensors","text":"For these sensors, the value must be between 0.0 and 100.0: IOWA_IPSO_LEVEL_CONTROL (3343)","title":"Percentage value sensors"},{"location":"ClientAPI/#compass-direction-value-sensors","text":"For these sensors, the value must be between 0.0 and 360.0: IOWA_IPSO_DIRECTION (3332) \\clearpage","title":"Compass direction value sensors"},{"location":"ClientAPI/#iowa_client_ipso_update_value","text":"Prototype iowa_status_t iowa_client_IPSO_update_value ( iowa_context_t contextP , iowa_sensor_t id , float value ); Description iowa_client_IPSO_update_value() updates the value of an IPSO sensor. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The ID of the sensor as returned by iowa_client_IPSO_add_sensor() . value : The new value measured by the sensor. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known sensor. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - the sensor uses a Boolean value and value is neither 0.0 nor 1.0. : - the sensor uses a percentage value and value is outside the [0.0, 100.0] range. : - the sensor uses a compass direction value and value is outside the [0.0, 360.0] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. Header File objects/iowa_ipso.h Notes If type equal to IOWA_IPSO_LEVEL_CONTROL this function will call iowa_client_dimmer_update_value() . \\clearpage","title":"iowa_client_IPSO_update_value"},{"location":"ClientAPI/#iowa_client_ipso_update_values","text":"Prototype iowa_status_t iowa_client_IPSO_update_values ( iowa_context_t contextP , iowa_sensor_t id , size_t valueCount , iowa_ipso_timed_value_t * valueArray ); Description iowa_client_IPSO_update_values() updates multiple times the value of an IPSO Object sensor. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The ID of the sensor as returned by iowa_client_IPSO_add_sensor() . valueCount : The number of values in valueArray . valueArray : The iowa_ipso_timed_value_t list of new values. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known sensor. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - one of the timestamped value has an negative value. : - the sensor uses a Boolean value and value is neither 0.0 nor 1.0. : - the sensor uses a percentage value and value is outside the [0.0, 100.0] range. : - the sensor uses a compass direction value and value is outside the [0.0, 360.0] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. Header File objects/iowa_ipso.h Notes iowa_client_IPSO_update_values() can only be used when the define [ LWM2M_SUPPORT_TIMESTAMP ][LWM2M_SUPPORT_TIMESTAMP] is set. The timestamp must be absolute and not relative to the current time, meaning negative values are not accepted. If the timestamp is equal to zero, it is ignored. Calling iowa_client_IPSO_update_values() will overwrite the previous values list. This has multiple consequences: If the values have not been sent to the Server, the previous values are lost. Values are only sent if the Server do a Read operation or if the Server has set an Observation. If the values are in the way to be sent to the Server and iowa_client_IPSO_update_values() is called during the process, some old values will be lost. This API is trying to send the values in best effort. Recent timestamped values are processed in priority before the oldest ones. Timestamp information is only present if the used Content Format is: JSON: [ LWM2M_SUPPORT_JSON ][LWM2M_SUPPORT_JSON] SenML JSON: [ LWM2M_SUPPORT_SENML_JSON ][LWM2M_SUPPORT_SENML_JSON] SenML CBOR: [ LWM2M_SUPPORT_SENML_CBOR ][LWM2M_SUPPORT_SENML_CBOR] If type equal to IOWA_IPSO_LEVEL_CONTROL this function will call iowa_client_dimmer_update_values() . \\clearpage","title":"iowa_client_IPSO_update_values"},{"location":"ClientAPI/#iowa_client_ipso_remove_sensor","text":"Prototype iowa_status_t iowa_client_IPSO_remove_sensor ( iowa_context_t contextP , iowa_sensor_t id ); Description iowa_client_IPSO_remove_sensor() removes from the LwM2M Client an IPSO sensor created with iowa_client_IPSO_add_sensor() . Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The ID of the sensor as returned by iowa_client_IPSO_add_sensor() . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not an IPSO sensor. Valid id are only returned by iowa_client_IPSO_add_sensor() . IOWA_COAP_404_NOT_FOUND : IPSO referred by id does not exist. Header File objects/iowa_ipso.h Notes If type equal to IOWA_IPSO_LEVEL_CONTROL this function will call iowa_client_remove_dimmer_object() . \\clearpage","title":"iowa_client_IPSO_remove_sensor"},{"location":"ClientAPI/#ligth-control-object-api","text":"This IPSO object is used to control a light source, such as a LED or other light. To be able to use this object, iowa_light_control.h must be included.","title":"Ligth Control Object API"},{"location":"ClientAPI/#callbacks_8","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_light_control_update_state_callback_t","text":"This callback is called when the LwM2M Server request the Client to update the state of the light. typedef iowa_status_t ( * iowa_light_control_update_state_callback_t )( iowa_sensor_t id , bool powerOn , int dimmer , char * colour , void * userDataCallback , iowa_context_t contextP ); id : ID of the object powerOn : Light power dimmer : Dimmer settings colour : A string representing a value in some color space userDataCallback : Application specific data from iowa_client_add_light_control_object . Can be nil. contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"iowa_light_control_update_state_callback_t"},{"location":"ClientAPI/#return-value_35","text":"IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"Return Value"},{"location":"ClientAPI/#api_9","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_add_light_control_object","text":"","title":"iowa_client_add_light_control_object"},{"location":"ClientAPI/#prototype_28","text":"iowa_status_t iowa_client_add_light_control_object ( iowa_context_t context , uint16_t optFlags , const float powerFactor , const char * colorSpace , iowa_light_control_update_state_callback_t updateStateCallback , void * userDataCallback , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_28","text":"iowa_client_add_light_control_object() creates a light control object.","title":"Description"},{"location":"ClientAPI/#arguments_28","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. powerFactor : The power factor of the light. colorSpace : Color space of the light. updateStateCallback : Called to update state of the light. This is called when the server request a new state. userDataCallback : Application specific data pass to the callback. Can be nil. applicationType : The application type idP : Used to store the ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_36","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : no update state callback provided means updateStateCallback is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_29","text":"objects/iowa_light_control.h","title":"Header File"},{"location":"ClientAPI/#notes_17","text":"Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_LIGHT_CONTROL_RSC_DIMMER IOWA_LIGHT_CONTROL_RSC_ON_TIME IOWA_LIGHT_CONTROL_RSC_CUMULATIVE_ACTIVE_POWER IOWA_LIGHT_CONTROL_RSC_POWER_FACTOR Moreover, you can add several optional resources at one time by using the following flag: IOWA_LIGHT_CONTROL_POWER The argument colorSpace must reflect the color representation of the light. Find below a non-exhaustive list of color spaces: RGB sRGB CMYK ... \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_light_control_object","text":"","title":"iowa_client_remove_light_control_object"},{"location":"ClientAPI/#prototype_29","text":"iowa_status_t iowa_client_remove_light_control_object ( iowa_context_t context , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_29","text":"iowa_client_remove_light_control_object() removes a light control object.","title":"Description"},{"location":"ClientAPI/#arguments_29","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object","title":"Arguments"},{"location":"ClientAPI/#return-value_37","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a light control object. Valid id are only returned by iowa_client_add_light_control_object() . IOWA_COAP_404_NOT_FOUND : light control referred by id does not exist.","title":"Return Value"},{"location":"ClientAPI/#header-file_30","text":"objects/iowa_light_control.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_light_control_set_state","text":"","title":"iowa_client_light_control_set_state"},{"location":"ClientAPI/#prototype_30","text":"iowa_status_t iowa_client_light_control_set_state ( iowa_context_t context , iowa_sensor_t id , bool powerOn , int dimmer , const char * colour );","title":"Prototype"},{"location":"ClientAPI/#description_30","text":"iowa_client_light_control_set_state() updates values of a light control object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object powerOn : Light power dimmer : Dimmer settings between 0 and 100 % colour : A string representing a value in some color space","title":"Description"},{"location":"ClientAPI/#return-value_38","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a light control object. Valid id are only returned by iowa_client_add_light_control_object() . IOWA_COAP_404_NOT_FOUND : light control referred by id does not exist. IOWA_COAP_412_PRECONDITION_FAILED : cannot affect the color. Color space has not been provided. To reconfigure the light control object, delete then readd the object or just add a new one with iowa_client_add_light_control_object() and iowa_client_remove_light_control_object() . IOWA_COAP_406_NOT_ACCEPTABLE : dimmer 's value is outside the [0, 100] range. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error when powerOn value changes and IOWA_LIGHT_CONTROL_RSC_ON_TIME resource is present.","title":"Return Value"},{"location":"ClientAPI/#header-file_31","text":"objects/iowa_light_control.h","title":"Header File"},{"location":"ClientAPI/#notes_18","text":"The Light Control Object may contain an \"On Time\" resource and/or a \"Cumulative Active Power\" resource. Calling this API updates their respective values. If colour is nil, the value of the resource Colour is not updated. \\clearpage","title":"Notes"},{"location":"ClientAPI/#location-object-api","text":"This LwM2M Object contains information on the device position and speed. To be able to use this object, iowa_location.h must be included.","title":"Location Object API"},{"location":"ClientAPI/#iowa_client_add_location_object","text":"Prototype iowa_status_t iowa_client_add_location_object ( iowa_context_t context , uint16_t optFlags , iowa_sensor_t * idP ); Description iowa_client_add_location_object() creates a location object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. idP : Used to store the ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_409_CONFLICT : a location object already exists. To reconfigure the location object, first delete the object with iowa_client_remove_location_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_location.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_LOCATION_RSC_ALTITUDE IOWA_LOCATION_RSC_RADIUS IOWA_LOCATION_RSC_VELOCITY IOWA_LOCATION_RSC_SPEED \\clearpage","title":"iowa_client_add_location_object"},{"location":"ClientAPI/#iowa_client_remove_location_object","text":"Prototype iowa_status_t iowa_client_remove_location_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_location_object() removes a location object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a location object. Valid id are only returned by iowa_client_add_location_object() . IOWA_COAP_404_NOT_FOUND : no location object to remove. iowa_client_add_location_object() was not called before, or failed. Header File objects/iowa_location.h \\clearpage","title":"iowa_client_remove_location_object"},{"location":"ClientAPI/#iowa_client_location_update","text":"Prototype iowa_status_t iowa_client_location_update ( iowa_context_t context , iowa_sensor_t id , float latitude , float longitude ); Description iowa_client_location_update() updates values of a location object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object latitude : New latitude longitude : New longitude Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a location object. Valid id are only returned by iowa_client_add_location_object() . IOWA_COAP_404_NOT_FOUND : object has not been created. First call iowa_client_add_location_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : iowa_system_gettime() returned an error. Header File objects/iowa_location.h \\clearpage","title":"iowa_client_location_update"},{"location":"ClientAPI/#iowa_client_location_update_full","text":"Prototype iowa_status_t iowa_client_location_update_full ( iowa_context_t context , iowa_sensor_t id , float latitude , float longitude , float altitude , float radius , size_t velocityLength , uint8_t * velocity , float speed ); Description iowa_client_location_update_full() updates values of a location object. Optionals resources are included. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object latitude : New latitude longitude : New longitude altitude : New altitude radius : Indicates the size in meters of a circular area around a point of geometry. velocityLength : Length of the velocity array velocity : The velocity of the device as defined in 3GPP 23.032 GAD specification. speed : Speed is the time rate of change in position of a LwM2M Client without regard for direction: the scalar component of velocity. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a location object. Valid id are only returned by iowa_client_add_location_object() . IOWA_COAP_404_NOT_FOUND : object has not been created. First call iowa_client_add_location_object() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. Header File objects/iowa_location.h \\clearpage","title":"iowa_client_location_update_full"},{"location":"ClientAPI/#magnetometer-object-api","text":"This IPSO object can be used to represent a 1-3 axis magnetometer with optional compass direction. To be able to use this object, iowa_magnetometer.h must be included.","title":"Magnetometer Object API"},{"location":"ClientAPI/#iowa_client_add_magnetometer_object","text":"Prototype iowa_status_t iowa_client_add_magnetometer_object ( iowa_context_t context , uint16_t optFlags , const char * sensorUnits , iowa_sensor_t * idP ); Description iowa_client_add_magnetometer_object() creates a magnetometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. sensorUnits : Measurement units definition. idP : Used to store the ID of the object. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File objects/iowa_magnetometer.h Notes Please refer to the OMA LightweightM2M (LwM2M) Object and Resource Registry to see how the object is defined: resources, resources type, ... When no optional flags are provided only mandatory resources of the object are implemented. To add optional resources, you can use the following flags: IOWA_MAGNETOMETER_RSC_Y_VALUE IOWA_MAGNETOMETER_RSC_Z_VALUE IOWA_MAGNETOMETER_RSC_COMPASS_DIRECTION Moreover, you can add several optional resources at one time by using the following flag: IOWA_MAGNETOMETER_3_AXIS \\clearpage","title":"iowa_client_add_magnetometer_object"},{"location":"ClientAPI/#iowa_client_remove_magnetometer_object","text":"Prototype iowa_status_t iowa_client_remove_magnetometer_object ( iowa_context_t context , iowa_sensor_t id ); Description iowa_client_remove_magnetometer_object() removes a magnetometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a magnetometer object. Valid id are only returned by iowa_client_add_magnetometer_object() . IOWA_COAP_404_NOT_FOUND : magnetometer referred by id does not exist. Header File objects/iowa_magnetometer.h \\clearpage","title":"iowa_client_remove_magnetometer_object"},{"location":"ClientAPI/#iowa_client_magnetometer_update_values","text":"Prototype iowa_status_t iowa_client_magnetometer_update_values ( iowa_context_t context , iowa_sensor_t id , float xValue , float yValue , float zValue , float compassDirection ); Description iowa_client_magnetometer_update_values() updates values of a magnetometer object. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the object xValue : X value axis yValue : Y value axis zValue : Z value axis compassDirection : Measured Direction between 0 and 360 deg. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a magnetometer object. Valid id are only returned by iowa_client_add_magnetometer_object() . IOWA_COAP_404_NOT_FOUND : magnetometer referred by id does not exist. IOWA_COAP_406_NOT_ACCEPTABLE : compassDirection 's value is outside the [0.0, 360.0] range. Header File objects/iowa_magnetometer.h \\clearpage","title":"iowa_client_magnetometer_update_values"},{"location":"ClientAPI/#software-component-object-api","text":"This LwM2M object provides the resources needed to activate/deactivate software components on the device. To be able to use this object, iowa_software_component.h must be included and IOWA_SUPPORT_SOFTWARE_COMPONENT_OBJECT must be defined before building IOWA.","title":"Software Component Object API"},{"location":"ClientAPI/#data-structures-and-constants_5","text":"","title":"Data Structures and Constants"},{"location":"ClientAPI/#iowa_sw_cmp_info_t","text":"This structure contains the description of a software component's information which could be set by users. typedef struct { const char * identityP ; const uint8_t * packP ; size_t packLength ; const char * versionP ; } iowa_sw_cmp_info_t ; identityP : Name or identifier of the software component, with size < 255. This can be nil. packP : Link to opaque data describing the software component. This can be nil. packLength : Length in bytes of the opaque data pointed by packP . versionP : Version of the software component, with size < 255. This can be nil. Note This structure will at least provide an identity ( identityP ) or a pack ( packP ) to identify the component. \\clearpage","title":"iowa_sw_cmp_info_t"},{"location":"ClientAPI/#callbacks_9","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_sw_cmp_update_callback_t","text":"This is the update callback, called when the Server adds or removes the software components. typedef iowa_status_t ( * iowa_sw_cmp_update_callback_t )( iowa_sensor_t id , iowa_dm_operation_t operation , iowa_sw_cmp_info_t * infoP , bool activationState , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software component. operation : the operation performed by the Server on this software component (either IOWA_DM_CREATE or IOWA_DM_DELETE ). infoP : software component information. activationState : initial activation state. Should be ignored if no iowa_sw_cmp_activation_callback_t() was passed to iowa_client_enable_software_component() . userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called.","title":"iowa_sw_cmp_update_callback_t"},{"location":"ClientAPI/#return-value_39","text":"IOWA_COAP_NO_ERROR in case of success or an error status.","title":"Return Value"},{"location":"ClientAPI/#iowa_sw_cmp_activation_callback_t","text":"This is the activation callback, called when the Server requests the device to activate or deactivate a software component. typedef iowa_status_t ( * iowa_sw_cmp_activation_callback_t ) ( iowa_sensor_t id , bool activationState , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software component. activationState : activation state requested. userDataP : The data passed to iowa_client_enable_software_component() . contextP : The IOWA context on which iowa_client_enable_software_component() was called.","title":"iowa_sw_cmp_activation_callback_t"},{"location":"ClientAPI/#return-value_40","text":"IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"Return Value"},{"location":"ClientAPI/#api_10","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_enable_software_component","text":"","title":"iowa_client_enable_software_component"},{"location":"ClientAPI/#prototype_31","text":"iowa_status_t iowa_client_enable_software_component ( iowa_context_t contextP , iowa_sw_cmp_update_callback_t updateCb , iowa_sw_cmp_activation_callback_t activationCb , void * userDataP );","title":"Prototype"},{"location":"ClientAPI/#description_31","text":"iowa_client_enable_software_component() enables the software component feature.","title":"Description"},{"location":"ClientAPI/#arguments_30","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. updateCb : The update callback called when the Server adds or removes a software component. This can be nil. activateCb : The activate callback, called when the Server requests the device to activate or deactivate a software component. This can be nil. userDataP : Passed as argument to the callback. This can be nil.","title":"Arguments"},{"location":"ClientAPI/#return-value_41","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_409_CONFLICT : Software component feature is already configured. To reconfigure the software component, disable it before with iowa_client_disable_software_component() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_32","text":"objects/iowa_software_component.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_disable_software_component","text":"","title":"iowa_client_disable_software_component"},{"location":"ClientAPI/#prototype_32","text":"iowa_status_t iowa_client_disable_software_component ( iowa_context_t contextP );","title":"Prototype"},{"location":"ClientAPI/#description_32","text":"iowa_client_disable_software_component() disables the software component feature.","title":"Description"},{"location":"ClientAPI/#arguments_31","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"Arguments"},{"location":"ClientAPI/#return-value_42","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : Software component feature was not enabled. iowa_client_enable_software_component() was not called before, or failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_33","text":"objects/iowa_software_component.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_add_software_component","text":"","title":"iowa_client_add_software_component"},{"location":"ClientAPI/#prototype_33","text":"iowa_status_t iowa_client_add_software_component ( iowa_context_t contextP , iowa_sw_cmp_info_t * infoP , bool activationState , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_33","text":"iowa_client_add_software_component() adds a software component.","title":"Description"},{"location":"ClientAPI/#arguments_32","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. infoP : software component information. activationState : current activation state of the software component. Ignored if no iowa_sw_cmp_activation_callback_t() was passed to iowa_client_enable_software_component() . idP : Used to store the ID of the created software component. Not checked at runtime.","title":"Arguments"},{"location":"ClientAPI/#return-value_43","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - infoP is nil. : - both infoP::identityP and infoP::packP are nil. : - a string in infoP is longer than 255 characters. IOWA_COAP_406_NOT_ACCEPTABLE : Software component feature was not enabled. Call first iowa_client_enable_software_component() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_34","text":"objects/iowa_software_component.h","title":"Header File"},{"location":"ClientAPI/#notes_19","text":"infoP must provide at least an identity ( infoP::identityP ) or a pack ( infoP::packP ) to identify the component. The \"const\" elements pointed by the fields of infoP are not duplicated nor freed by IOWA. Make sure they are available until corresponding iowa_client_remove_software_component() , iowa_client_disable_software_component() , or iowa_close() is called. \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_software_component","text":"","title":"iowa_client_remove_software_component"},{"location":"ClientAPI/#prototype_34","text":"iowa_status_t iowa_client_remove_software_component ( iowa_context_t contextP , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_34","text":"iowa_client_remove_software_component() removes a software component.","title":"Description"},{"location":"ClientAPI/#arguments_33","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software component.","title":"Arguments"},{"location":"ClientAPI/#return-value_44","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a software component. Valid id are only returned by iowa_client_add_software_component() . IOWA_COAP_404_NOT_FOUND : software component referred by id does not exist. IOWA_COAP_412_PRECONDITION_FAILED : Software component feature was not enabled. Call first iowa_client_enable_software_component() .","title":"Return Value"},{"location":"ClientAPI/#header-file_35","text":"objects/iowa_software_component.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_software_component_update_state","text":"","title":"iowa_client_software_component_update_state"},{"location":"ClientAPI/#prototype_35","text":"iowa_status_t iowa_client_software_component_update_state ( iowa_context_t contextP , iowa_sensor_t id , bool activationState );","title":"Prototype"},{"location":"ClientAPI/#description_35","text":"iowa_client_software_component_update_state() updates a software component's activation state.","title":"Description"},{"location":"ClientAPI/#arguments_34","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software component. activationState : New activation state of the software component. Note This API has no effect if no iowa_sw_cmp_activation_callback_t() was passed to iowa_client_enable_software_component() since the Activation State resource is not presented to the LwM2M Server.","title":"Arguments"},{"location":"ClientAPI/#return-value_45","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known software component. IOWA_COAP_406_NOT_ACCEPTABLE : Software component feature was not enabled. Call first iowa_client_enable_software_component() .","title":"Return Value"},{"location":"ClientAPI/#header-file_36","text":"objects/iowa_software_component.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#software-management-object-api","text":"In LightweightM2M, the Software Management mechanism is used to install and activate software components to a LwM2M Client. To be able to use this object, iowa_software_management.h must be included and IOWA_SUPPORT_SOFTWARE_MANAGEMENT_OBJECT must be defined before building the library. The [Device Update][Device Update]/[Software Management][Software Management] part of this specification adds more explanation about its mechanism and how to use it with IOWA. Note: As there is currently some confusion on the layout of of the Software Management Object, IOWA uses the definition provided in [LwM2M Overview][LwM2M Overview]/[Software Management Object][Software Management Object].","title":"Software Management Object API"},{"location":"ClientAPI/#data-structures-and-constants_6","text":"","title":"Data Structures and Constants"},{"location":"ClientAPI/#iowa_sw_pkg_result_t","text":"This enumeration is used to update the operation result from iowa_sw_pkg_download_callback_t() , iowa_sw_pkg_write_callback_t() and iowa_sw_pkg_install_callback_t() callbacks. It has the following values: IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL : success of any operation made on the software package (verification, installation, uninstallation, activation, deactivation) IOWA_SW_PKG_UPDATE_RESULT_DOWNLOADING_SUCCESSFUL : success of the new software package download. ( downloadCb only) IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_STORAGE : not enough storage for the new software package. ( downloadCb or writeCb only) IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_MEMORY : out of memory error during the download of the new software package. ( downloadCb or writeCb only) IOWA_SW_PKG_UPDATE_RESULT_CONNECTION_LOST : connection lost during the download of the new software package. ( downloadCb or writeCb only) IOWA_SW_PKG_UPDATE_RESULT_INTEGRITY_CHECK_FAILURE : integrity check failure of the new software package. ( downloadCb or writeCb only) IOWA_SW_PKG_UPDATE_RESULT_UNSUPPORTED_TYPE : unsupported new software package type. IOWA_SW_PKG_UPDATE_RESULT_INVALID_URI : invalid URI to download the new software package. ( downloadCb only) IOWA_SW_PKG_UPDATE_RESULT_UPDATE_FAILED : device defined update error. IOWA_SW_PKG_UPDATE_RESULT_INSTALLED_FAILURE : new software installation failure. ( installCb only) IOWA_SW_PKG_UPDATE_RESULT_UNINSTALLED_FAILURE : software uninstallation failure. ( installCb only)","title":"iowa_sw_pkg_result_t"},{"location":"ClientAPI/#iowa_sw_pkg_state_t","text":"This enumeration is used to control current state in iowa_client_add_software_package() and iowa_client_software_package_update_state() . It has the following values: IOWA_SW_PKG_STATE_UNINSTALLED : software is uninstalled. (default value) IOWA_SW_PKG_STATE_INSTALLED : software is installed. IOWA_SW_PKG_STATE_ACTIVATED : software is activate. Useful only if Software components are linked, otherwise same behavior than installed.","title":"iowa_sw_pkg_state_t"},{"location":"ClientAPI/#iowa_sw_pkg_write_cmd_t","text":"This enumeration is used in iowa_sw_pkg_write_callback_t() callback. It has the following values: IOWA_SW_PKG_COMMAND_RESET : To start software package packet writing. IOWA_SW_PKG_COMMAND_WRITE : To indicate other software package piece of the complete packet.","title":"iowa_sw_pkg_write_cmd_t"},{"location":"ClientAPI/#iowa_sw_pkg_install_cmd_t","text":"This enumeration is used in iowa_sw_pkg_install_callback_t() callback. It has the following values: IOWA_SW_PKG_COMMAND_INSTALL : software installation is requested. IOWA_SW_PKG_COMMAND_UNINSTALL : software uninstallation is requested. IOWA_SW_PKG_COMMAND_PREPARE_FOR_UPDATE : software uninstallation is requested to prepare an update.","title":"iowa_sw_pkg_install_cmd_t"},{"location":"ClientAPI/#iowa_sw_pkg_optional_info_t","text":"This structure contains the description of a optional software package's information which could be set by users. typedef struct { iowa_sensor_t * swComponentLinkP ; uint16_t swComponentLinkCount ; } iowa_sw_pkg_optional_info_t ; swComponentLinkP : Software Components downloaded and installed in scope of the present SW Update Package. This can be nil. : Each swComponentLinkP sensor id must have been provided by [ Software Component Object APIs ][Software Component Object API]. swComponentLinkCount : Software Components Link count. \\clearpage","title":"iowa_sw_pkg_optional_info_t"},{"location":"ClientAPI/#callbacks_10","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_sw_pkg_update_callback_t","text":"This is the update callback, called when the Server adds or removes the software packages. typedef iowa_status_t ( * iowa_sw_pkg_update_callback_t ) ( iowa_sensor_t id , iowa_dm_operation_t operation , const char * pkgNameP , const char * pkgVersionP , iowa_sw_pkg_optional_info_t * optP , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software package. operation : the operation performed by the Server on this software package (either IOWA_DM_CREATE or IOWA_DM_DELETE). pkgNameP : Name of the software package. pkgVersionP : Version of the software package. optP : Optional information. This can be nil. userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called.","title":"iowa_sw_pkg_update_callback_t"},{"location":"ClientAPI/#return-value_46","text":"IOWA_COAP_NO_ERROR in case of success or an error status.","title":"Return Value"},{"location":"ClientAPI/#iowa_sw_pkg_download_callback_t","text":"This is the download callback, called when the Server requests the device to download a new software Package (new value in \"Package URI\"). When the packet is downloaded, users should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_DOWNLOADING_SUCCESSFUL result if successful or an error result otherwise. When the packet is verified, users should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL result if successful or an error result otherwise. typedef void ( * iowa_sw_pkg_download_callback_t ) ( iowa_sensor_t id , const char * uriP , const char * userNameP , const char * passwordP , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software package instance. uriP : URI to download the package from. userNameP : User Name for access to SW Update Package in pull mode, with size < 255. Key based mechanism can alternatively use for talking to the component server instead of user name and password combination. This can be nil. passwordP : Password for access to SW Update Package in pull mode, with size < 255. This can be nil. userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called.","title":"iowa_sw_pkg_download_callback_t"},{"location":"ClientAPI/#iowa_sw_pkg_write_callback_t","text":"This is the write callback, called several times when the Server pushes the new software package to the device (new value in \"Package\"). The expected behavior is the same as writing to a file stream i.e. unless it is reset, written data are appended to the previous ones. typedef iowa_sw_pkg_result_t ( * iowa_sw_pkg_write_callback_t ) ( iowa_sensor_t id , iowa_sw_pkg_write_cmd_t cmd , size_t dataLength , uint8_t * dataP , void * userDataP , iowa_context_t contextP ); At the start of the push of the software package or if the LwM2M Server cancels it, this callback is called with the following parameters: id : ID of the corresponding software package instance. cmd : IOWA_SW_PKG_COMMAND_RESET dataLength : 0 dataP : NULL userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. When the software package is received, this callback is called several times with the following parameters: id : ID of the corresponding software package instance. cmd : IOWA_SW_PKG_COMMAND_WRITE dataLength : The length of the buffer pointed by dataP . data : The next chunk of the software package to write. userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. At the end of the push of the software package, this callback is called with the following parameters: id : ID of the corresponding software package instance. cmd : IOWA_SW_MGMT_PACKAGE_WRITE dataLength : 0 data : NULL userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called.","title":"iowa_sw_pkg_write_callback_t"},{"location":"ClientAPI/#return-value_47","text":"IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL in case of success or an error status.","title":"Return Value"},{"location":"ClientAPI/#iowa_sw_pkg_install_callback_t","text":"This is the install callback, called when the Server requests the device to install or uninstall the software Package. When the installation finishes, users should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL result if successful or an error result otherwise. typedef void ( * iowa_sw_pkg_install_callback_t ) ( iowa_sensor_t id , iowa_sw_pkg_install_cmd_t cmd , void * userDataP , iowa_context_t contextP ); id : ID of the corresponding software package instance. cmd : installed state requested. See iowa_sw_pkg_install_cmd_t . userDataP : The data passed to iowa_client_enable_software_package_management() . contextP : The IOWA context on which iowa_client_enable_software_package_management() was called. \\clearpage","title":"iowa_sw_pkg_install_callback_t"},{"location":"ClientAPI/#api_11","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_enable_software_package_management","text":"","title":"iowa_client_enable_software_package_management"},{"location":"ClientAPI/#prototype_36","text":"iowa_status_t iowa_client_enable_software_package_management ( iowa_context_t contextP , iowa_sw_pkg_update_callback_t updateCb , iowa_sw_pkg_download_callback_t downloadCb , iowa_sw_pkg_write_callback_t writeCb , iowa_sw_pkg_install_callback_t installCb , void * userDataP );","title":"Prototype"},{"location":"ClientAPI/#description_36","text":"iowa_client_enable_software_package_management() enables the software package management feature.","title":"Description"},{"location":"ClientAPI/#arguments_35","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. updateCb : The update callback called when the Server adds or removes the software packages. This can be nil. downloadCb : The download callback, called when the Server requests the device to download a new software Package (new value in \"Package URI\"). This can be nil. writeCb : The write callback, called several times when the Server pushes the new software Package to the device (new value in \"Package\"). This can be nil. installCb : The install callback, called when the Server requests the device to install or uninstall the software Package. userDataP : Passed as argument to the callbacks. This can be nil.","title":"Arguments"},{"location":"ClientAPI/#return-value_48","text":"IOWA_COAP_NO_ERROR : success. COAP_400_BAD_REQUEST : either: : - installCb is nil. : - both downloadCb and writeCb are nil. At least one must be defined. IOWA_COAP_409_CONFLICT : Software package feature is already configured. To reconfigure the software package, disable it before with iowa_client_disable_software_package_management() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_37","text":"objects/iowa_software_management.h","title":"Header File"},{"location":"ClientAPI/#notes_20","text":"The LwM2M Server has two methods to provide the software package: the \"pull\" method: the LwM2M Server provides the URI of the software package and the LwM2M Client downloads it directly. To use this method, downloadCb must be set. the \"push\" method: the LwM2M Server writes the software package in a LwM2M Resource exposed by the Client. To use this method, writeCb must be set. The Client can support both methods at the same time and must at least provide one of them. downloadCb and updateCb do not return any value. The progress and result of their operation are indicated asynchronously by calling iowa_client_set_software_package_command_result() . \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_disable_software_package_management","text":"","title":"iowa_client_disable_software_package_management"},{"location":"ClientAPI/#prototype_37","text":"iowa_status_t iowa_client_disable_software_package_management ( iowa_context_t contextP );","title":"Prototype"},{"location":"ClientAPI/#description_37","text":"iowa_client_disable_software_package_management() disables the software package management feature.","title":"Description"},{"location":"ClientAPI/#arguments_36","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"Arguments"},{"location":"ClientAPI/#return-value_49","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : Software package feature was not enabled. iowa_client_enable_software_package_management() was not called before, or failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_38","text":"objects/iowa_software_management.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_add_software_package","text":"","title":"iowa_client_add_software_package"},{"location":"ClientAPI/#prototype_38","text":"iowa_status_t iowa_client_add_software_package ( iowa_context_t contextP , const char * pkgNameP , const char * pkgVersionP , iowa_sw_pkg_state_t state , iowa_sw_pkg_optional_info_t * optP , iowa_sensor_t * idP );","title":"Prototype"},{"location":"ClientAPI/#description_38","text":"iowa_client_add_software_package() adds a software package instance.","title":"Description"},{"location":"ClientAPI/#arguments_37","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. pkgNameP : Name of the software package. pkgVersionP : Version of the software package. state : State of the software package. (default value: IOWA_SW_PKG_STATE_UNINSTALLED) optP : Optional information. This can be nil. idP : Used to store the ID of the created software package instance. Not checked at runtime.","title":"Arguments"},{"location":"ClientAPI/#return-value_50","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - pkgNameP is nil. : - pkgVersionP is nil. : - optP has invalid format. : - Any string is larger than 255 characters. IOWA_COAP_406_NOT_ACCEPTABLE : Software package feature was not enabled. Call first iowa_client_enable_software_package_management() . IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_39","text":"objects/iowa_software_management.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_remove_software_package","text":"","title":"iowa_client_remove_software_package"},{"location":"ClientAPI/#prototype_39","text":"iowa_status_t iowa_client_remove_software_package ( iowa_context_t contextP , iowa_sensor_t id );","title":"Prototype"},{"location":"ClientAPI/#description_39","text":"iowa_client_remove_software_package() removes a software package instance.","title":"Description"},{"location":"ClientAPI/#arguments_38","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software package instance.","title":"Arguments"},{"location":"ClientAPI/#return-value_51","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : id is not a software package. Valid id are only returned by iowa_client_add_software_package() . IOWA_COAP_404_NOT_FOUND : software package referred by id does not exist. IOWA_COAP_412_PRECONDITION_FAILED : Software package feature was not enabled. Call first iowa_client_enable_software_package_management() .","title":"Return Value"},{"location":"ClientAPI/#header-file_40","text":"objects/iowa_software_management.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_software_package_update_state","text":"","title":"iowa_client_software_package_update_state"},{"location":"ClientAPI/#prototype_40","text":"iowa_status_t iowa_client_software_package_update_state ( iowa_context_t contextP , iowa_sensor_t id , iowa_sw_pkg_state_t state );","title":"Prototype"},{"location":"ClientAPI/#description_40","text":"iowa_client_software_package_update_state() updates a software package instance's state.","title":"Description"},{"location":"ClientAPI/#arguments_39","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software package instance. state : state of the software package.","title":"Arguments"},{"location":"ClientAPI/#return-value_52","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known software package. IOWA_COAP_406_NOT_ACCEPTABLE : Software package feature was not enabled. Call first iowa_client_enable_software_package_management() .","title":"Return Value"},{"location":"ClientAPI/#header-file_41","text":"objects/iowa_software_management.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_set_software_package_command_result","text":"","title":"iowa_client_set_software_package_command_result"},{"location":"ClientAPI/#prototype_41","text":"iowa_status_t iowa_client_set_software_package_command_result ( iowa_context_t contextP , iowa_sensor_t id , iowa_sw_pkg_result_t result );","title":"Prototype"},{"location":"ClientAPI/#description_41","text":"iowa_client_set_software_package_command_result() informs the IOWA stack of the result of the callbacks downloadCb and installCb of iowa_client_enable_software_package_management() .","title":"Description"},{"location":"ClientAPI/#arguments_40","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : ID of the corresponding software package instance. result : The result of the software package callbacks.","title":"Arguments"},{"location":"ClientAPI/#return-value_53","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : id does not match any known software package. IOWA_COAP_406_NOT_ACCEPTABLE : Software package feature was not enabled. Call first iowa_client_enable_software_package_management() .","title":"Return Value"},{"location":"ClientAPI/#header-file_42","text":"objects/iowa_software_management.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#mqtt-object-api","text":"This part allows the possibility to connect with an MQTT Broker. To be able to use these objects, iowa_mqtt_objects.h must be included.","title":"MQTT Object API"},{"location":"ClientAPI/#data-structures-and-constants_7","text":"","title":"Data Structures and Constants"},{"location":"ClientAPI/#iowa_mqtt_broker_t","text":"typedef struct { char * uri ; char * clientId ; bool cleanSession ; uint16_t keepAlive ; char * userName ; uint8_t * password ; size_t passwordLength ; iowa_security_mode_t securityMode ; iowa_cert_usage_mode_t certificateUsage ; uint8_t * identity ; size_t identityLength ; uint8_t * brokerIdentity ; size_t brokerIdentityLength ; uint8_t * privateKey ; size_t privateKeyLength ; } iowa_mqtt_broker_t ; uri : The URI to reach the MQTT Broker as a nil-terminated string e.g. \"tcp://[::1]:1883\". clientId : MQTT Client Identifier to use when connecting to this MQTT broker. cleanSession : A boolean that's indicate to the MQTT broker to create a persistent session. keepAlive : The maximum time in seconds that's the client take to send or receive a message. userName : The User Name to declare in the MQTT CONNECT message. password : The Password value to declare in the MQTT CONNECT message. passwordLength : The length of the broker's password. securityMode : The security mode to use when connecting to this LwM2M Server. See iowa_security_mode_t . certificateUsage : The Certificate Usage Resource specifies the semantic of the certificate or raw public key stored in the \"MQTT Broker Public Key\" Resource, which is used to match the certificate presented in the TLS/DTLS handshake. See iowa_cert_usage_mode_t . : When this Resource is absent, value IOWA_CERTIFICATE_USAGE_DOMAIN_ISSUED_CERTIFICATE for domain issued certificate mode is assumed. identity : Stores the Device's certificate, public key (RPK mode) or PSK Identity (PSK mode). identityLength : The identity length. brokerIdentity : Stores the MQTT Broker's certificate, public key (RPK mode) or trust anchor. The Certificate Usage Resource determines the content of this resource. brokerIdentityLength : The length of the broker's Identity. privateKey : Stores the secret key (PSK mode) or private key (RPK or certificate mode). privateKeyLength : The private key's length","title":"iowa_mqtt_broker_t"},{"location":"ClientAPI/#iowa_mqtt_publication_t","text":"typedef struct { iowa_sensor_t brokerId ; char * source ; char * topic ; uint8_t qos ; bool retain ; bool active ; iowa_content_format_t encoding ; } iowa_mqtt_publication_t ; brokerId : The ID of the broker to be used. source : The source of the data to publish (e.g. \"\", or \";\"). If this Resource is empty, the published data are implementation dependent. topic : The MQTT topic to publish to. qos : The Quality of Service value to use when publishing. retain : The RETAIN flag value to use when publishing. active : A boolean to indicate if the Resource is not present, the Device publishes the data pointed by the Source Resource to the MQTT Broker pointed by the Broker Resource using the MQTT topic indicated in the Topic Resource. If false, the Device does nothing. encoding : A CoAP Content-Format value used to encode the data in the MQTT Publish message. If this Resource is not present or equal to 65535, the encoding of the data is implementation dependent. \\clearpage","title":"iowa_mqtt_publication_t"},{"location":"ClientAPI/#callbacks_11","text":"","title":"Callbacks"},{"location":"ClientAPI/#iowa_mqtt_broker_update_callback_t","text":"The callback called when a LwM2M Server modifies the MQTT Broker Object. typedef void ( * iowa_mqtt_broker_update_callback_t ) ( iowa_dm_operation_t operation , iowa_sensor_t brokerId , iowa_mqtt_broker_t * brokerDetailsP , void * userData , iowa_context_t contextP ); operation : the type of the operation among IOWA_DM_READ, IOWA_DM_WRITE and IOWA_DM_DELETE. brokerId : the ID of the modified MQTT broker. brokerDetailsP : the details of the modified MQTT broker. userData : Passed as argument to the callbacks. This can be nil. contextP : the IOWA context on which iowa_client_enable_mqtt_broker() was called.","title":"iowa_mqtt_broker_update_callback_t"},{"location":"ClientAPI/#iowa_mqtt_publication_update_callback_t","text":"The callback called when a LwM2M Server modifies the MQTT Publication Object. typedef void ( * iowa_mqtt_publication_update_callback_t ) ( iowa_dm_operation_t operation , iowa_sensor_t publicationId , iowa_mqtt_publication_t * publicationDetailsP , void * userData , iowa_context_t contextP ); operation : the type of the operation among IOWA_DM_READ and IOWA_DM_WRITE. publicationId : the ID of the modified MQTT Publication. publicationDetailsP : the details of the modified MQTT Publication. userData : Passed as argument to the callbacks. This can be nil. contextP : the IOWA context on which iowa_client_enable_mqtt_publication() was called. \\clearpage","title":"iowa_mqtt_publication_update_callback_t"},{"location":"ClientAPI/#api_12","text":"","title":"API"},{"location":"ClientAPI/#iowa_client_enable_mqtt_broker","text":"","title":"iowa_client_enable_mqtt_broker"},{"location":"ClientAPI/#prototype_42","text":"iowa_status_t iowa_client_enable_mqtt_broker ( iowa_context_t contextP , iowa_mqtt_broker_update_callback_t brokerCb , void * userData );","title":"Prototype"},{"location":"ClientAPI/#description_42","text":"iowa_client_enable_mqtt_broker() enables the MQTT brokers management.","title":"Description"},{"location":"ClientAPI/#arguments_41","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. brokerCb : The broker callback called when a LwM2M Server modify the MQTT brokers. userDataP : Passed as argument to the callbacks. This can be nil.","title":"Arguments"},{"location":"ClientAPI/#return-value_54","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : brokerCb is nil. IOWA_COAP_409_CONFLICT : MQTT brokers management is already enabled. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_43","text":"objects/iowa_mqtt_objects.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_disable_mqtt_broker","text":"","title":"iowa_client_disable_mqtt_broker"},{"location":"ClientAPI/#prototype_43","text":"iowa_status_t iowa_client_disable_mqtt_broker ( iowa_context_t contextP );","title":"Prototype"},{"location":"ClientAPI/#description_43","text":"iowa_client_disable_mqtt_broker() disables the MQTT brokers management.","title":"Description"},{"location":"ClientAPI/#arguments_42","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"Arguments"},{"location":"ClientAPI/#return-value_55","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : MQTT brokers management is not enabled.","title":"Return Value"},{"location":"ClientAPI/#header-file_44","text":"objects/iowa_mqtt_objects.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_add_mqtt_broker","text":"","title":"iowa_client_add_mqtt_broker"},{"location":"ClientAPI/#prototype_44","text":"iowa_status_t iowa_client_add_mqtt_broker ( iowa_context_t contextP , uint16_t optFlags , const iowa_mqtt_broker_t * brokerDetailsP , iowa_sensor_t * brokerIdP );","title":"Prototype"},{"location":"ClientAPI/#description_44","text":"iowa_client_add_mqtt_broker() adds an MQTT broker instance.","title":"Description"},{"location":"ClientAPI/#arguments_43","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to add optional resources. brokerDetailsP : The details of the MQTT Broker. Copied internally by IOWA. brokerIdP : Used to store the ID of the created MQTT Broker instance.","title":"Arguments"},{"location":"ClientAPI/#return-value_56","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - Invalid brokerDetailsP . : - brokerIdP is nil. IOWA_COAP_412_PRECONDITION_FAILED MQTT brokers management is not enabled. Call iowa_client_enable_mqtt_broker() first. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_45","text":"objects/iowa_mqtt_objects.h","title":"Header File"},{"location":"ClientAPI/#notes_21","text":"The invalid broker's details are : either: : - The client identity is nil. : - The password length is 0 and the password is not nil. : - The identity length is 0 and the identity is not nil. : - The private key length is 0 and the private key is not nil. : - The broker's identity length is 0 and the broker's identity is not nil. : - The security mode is IOWA_SEC_NONE and the identity length and/or private key length and/or broker's identity length are greater than 0. : - The security mode is different than IOWA_SEC_NONE and the identity length and/or private key length equal to 0. : - The security mode is IOWA_SEC_RAW_PUBLIC_KEY or IOWA_SEC_CERTIFICATE and the broker identity length equal to 0. : - The security mode value is unknown. : - The certificate usage value is unknown. To add optional resource, you can use the following flag: IOWA_MQTT_BROKER_CERTIFICATE_USAGE : a flag to set the broker certificate usage resource, if this resource is not set by the user, domain issued certificate mode is assumed. \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_mqtt_broker","text":"","title":"iowa_client_remove_mqtt_broker"},{"location":"ClientAPI/#prototype_45","text":"iowa_status_t iowa_client_remove_mqtt_broker ( iowa_context_t contextP , iowa_sensor_t brokerId );","title":"Prototype"},{"location":"ClientAPI/#description_45","text":"iowa_client_remove_mqtt_broker() removes an MQTT broker instance.","title":"Description"},{"location":"ClientAPI/#arguments_44","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. brokerId : The ID assigned to the MQTT Broker by IOWA.","title":"Arguments"},{"location":"ClientAPI/#return-value_57","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : brokerId is not valid. Valid brokerId are only returned by iowa_client_add_mqtt_broker() . IOWA_COAP_404_NOT_FOUND : brokerId does not match a known MQTT broker. IOWA_COAP_412_PRECONDITION_FAILED MQTT brokers management is not enabled. Call iowa_client_enable_mqtt_broker() first.","title":"Return Value"},{"location":"ClientAPI/#header-file_46","text":"objects/iowa_mqtt_objects.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_get_mqtt_broker","text":"","title":"iowa_client_get_mqtt_broker"},{"location":"ClientAPI/#prototype_46","text":"iowa_mqtt_broker_t * iowa_client_get_mqtt_broker ( iowa_context_t contextP , iowa_sensor_t brokerId );","title":"Prototype"},{"location":"ClientAPI/#description_46","text":"iowa_client_get_mqtt_broker() retrieves the details of an MQTT broker.","title":"Description"},{"location":"ClientAPI/#arguments_45","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. brokerId : The ID assigned to the MQTT Broker by IOWA.","title":"Arguments"},{"location":"ClientAPI/#return-value_58","text":"The MQTT broker's details, or NULL if the MQTT brokers management is not enabledor if brokerId does not match a known MQTT broker.","title":"Return Value"},{"location":"ClientAPI/#notes_22","text":"The returned pointer points to the internal data of IOWA and not to duplicated information. It is advised to not modify it.","title":"Notes"},{"location":"ClientAPI/#header-file_47","text":"objects/iowa_mqtt_objects.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_enable_mqtt_publication","text":"","title":"iowa_client_enable_mqtt_publication"},{"location":"ClientAPI/#prototype_47","text":"iowa_status_t iowa_client_enable_mqtt_publication ( iowa_context_t contextP , iowa_mqtt_publication_update_callback_t publicationCB , void * userData );","title":"Prototype"},{"location":"ClientAPI/#description_47","text":"iowa_client_enable_mqtt_publication() enables the MQTT Publication management.","title":"Description"},{"location":"ClientAPI/#arguments_46","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. publicationCB : The broker callback called when a LwM2M Server modify the MQTT brokers. userDataP : Passed as argument to the callbacks. This can be nil.","title":"Arguments"},{"location":"ClientAPI/#return-value_59","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : publicationCB is nil. IOWA_COAP_409_CONFLICT : MQTT Publication Object already exists. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"ClientAPI/#header-file_48","text":"objects/iowa_mqtt_objects.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_disable_mqtt_publication","text":"","title":"iowa_client_disable_mqtt_publication"},{"location":"ClientAPI/#prototype_48","text":"iowa_status_t iowa_client_disable_mqtt_publication ( iowa_context_t contextP );","title":"Prototype"},{"location":"ClientAPI/#description_48","text":"iowa_client_disable_mqtt_publication() disables the MQTT Publication management.","title":"Description"},{"location":"ClientAPI/#arguments_47","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"Arguments"},{"location":"ClientAPI/#return-value_60","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : MQTT publication Object not found.","title":"Return Value"},{"location":"ClientAPI/#header-file_49","text":"objects/iowa_mqtt_objects.h \\clearpage","title":"Header File"},{"location":"ClientAPI/#iowa_client_add_mqtt_publication","text":"","title":"iowa_client_add_mqtt_publication"},{"location":"ClientAPI/#prototype_49","text":"iowa_status_t iowa_client_add_mqtt_publication ( iowa_context_t contextP , uint16_t optFlags , const iowa_mqtt_publication_t * publicationDetailsP , iowa_sensor_t * publicationIdP );","title":"Prototype"},{"location":"ClientAPI/#description_49","text":"iowa_client_add_mqtt_publication() adds an MQTT publication instance.","title":"Description"},{"location":"ClientAPI/#arguments_48","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. optFlags : Optional flags to indicate optional resources. publicationDetailsP : publicationDetailsP: details of the MQTT Publication. Copied internally by IOWA. publicationIdP : Used to store the ID of the created MQTT Publication instance.","title":"Arguments"},{"location":"ClientAPI/#return-value_61","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - Invalid publicationDetailsP . : - publicationIdP is nil. IOWA_COAP_412_PRECONDITION_FAILED : MQTT publication management was not enabled. Call iowa_client_enable_mqtt_publication() first. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation or a call to iowa_system_gettime() failed. : Invalid publication source format.","title":"Return Value"},{"location":"ClientAPI/#header-file_50","text":"objects/iowa_mqtt_objects.h","title":"Header File"},{"location":"ClientAPI/#notes_23","text":"The invalid publication's details are either: : - The publication's topic is nil. : - The publication's source is nil. : - The publication's QOS is greater than 2. To add optional resources, you can use the following flag: IOWA_MQTT_PUBLICATION_RSC_ENCODING : a flag to set the publication encoding resource, if this resource is not set by the user, the encoding of the data is implementation dependent. IOWA_MQTT_PUBLICATION_RSC_ACTIVE : a flag to set the publication active resource. if this resource is not set by the user, it will be assumed to be true. \\clearpage","title":"Notes"},{"location":"ClientAPI/#iowa_client_remove_mqtt_publication","text":"","title":"iowa_client_remove_mqtt_publication"},{"location":"ClientAPI/#prototype_50","text":"iowa_status_t iowa_client_remove_mqtt_publication ( iowa_context_t contextP , iowa_sensor_t publicationId );","title":"Prototype"},{"location":"ClientAPI/#description_50","text":"iowa_client_remove_mqtt_publication() removes an MQTT Publication instance.","title":"Description"},{"location":"ClientAPI/#arguments_49","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. publicationId : The ID assigned to the MQTT Publication by IOWA.","title":"Arguments"},{"location":"ClientAPI/#return-value_62","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : publicationId is not an MQTT object. Valid publicationId are only returned by iowa_client_add_mqtt_publication() . IOWA_COAP_404_NOT_FOUND : MQTT object referred by publicationId does not exist. IOWA_COAP_412_PRECONDITION_FAILED : MQTT publication management was not enabled. Call iowa_client_enable_mqtt_publication() first.","title":"Return Value"},{"location":"ClientAPI/#header-file_51","text":"objects/iowa_mqtt_objects.h","title":"Header File"},{"location":"CoapAPI/","text":"CoAP API Reference \u00b6 The functions explained below are defined inside the file include/iowa_coap.h . CoAP client pseudo code \u00b6 #include \"iowa_coap.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_coap_peer_t * peerP ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); peerP = iowa_coap_peer_new ( iowaH , \"coap://coap.example.com\" , IOWA_SEC_NONE , NULL , prv_coapEventCallback , NULL ); result = iowa_coap_peer_connect ( iowaH , peerP ); /****************** * \"Main loop\" */ while ( result == IOWA_COAP_NO_ERROR ) { result = iowa_step ( iowaH , 10 ); } iowa_coap_peer_delete ( iowaH , peerP ); iowa_close ( iowaH ); close ( serverSocket ); return 0 ; } void prv_coapEventCallback ( iowa_coap_peer_t * fromPeer , iowa_coap_event_t event , void * userData , iowa_context_t contextP ) { if ( event == COAP_EVENT_CONNECTED ) { iowa_status_t result ; // Sending a GET on \"/test\" result = iowa_coap_peer_get ( contextP , fromPeer , \"/test\" , prv_resultCallback , userData ); } else if ( event == COAP_EVENT_DISCONNECTED ) { iowa_coap_peer_delete ( contextP , fromPeer ); } } void prv_resultCallback ( iowa_coap_peer_t * fromPeer , uint8_t code , iowa_coap_message_t * responseP , void * userData , iowa_context_t contextP ) { printf ( \"Result for GET: %u.%02u. \\r\\n \" , ( code & 0xFF ) >> 5 , ( code & 0x1F )); if ( code == IOWA_COAP_205_CONTENT ) { printf ( \"Payload: %.*s\" , responseP -> payloadLength , responseP -> payload ); } } Data types \u00b6 iowa_coap_peer_t \u00b6 typedef struct _iowa_coap_peer_t iowa_coap_peer_t ; iowa_coap_peer_t is an opaque type describing a CoAP peer. iowa_coap_peer_event_t \u00b6 typedef enum { COAP_EVENT_UNDEFINED = 0 , COAP_EVENT_CONNECTED , COAP_EVENT_DISCONNECTED } iowa_coap_peer_event_t ; iowa_coap_peer_event_t contains the possible events that can be reported by a CoAP peer. iowa_coap_message_t \u00b6 typedef struct _iowa_coap_message_t iowa_coap_message_t ; iowa_coap_message_t is an opaque type describing a CoAP message. iowa_coap_setting_id_t \u00b6 typedef uint8_t iowa_coap_setting_id_t ; Possible Values \u00b6 IOWA_COAP_SETTING_ACK_TIMEOUT : The RFC7252 ACK_TIMEOUT value as an uint8_t . IOWA_COAP_SETTING_MAX_RETRANSMIT : The RFC7252 MAX_RETRANSMIT value as an uint8_t . IOWA_COAP_SETTING_URI_LENGTH : The length in bytes of the URI as a size_t . This is a read-only setting. IOWA_COAP_SETTING_URI : The URI as a char * . This is a read-only setting. The passed argument must point to a buffer of at least the size indicated by IOWA_COAP_SETTING_URI_LENGTH . \\clearpage Callbacks \u00b6 iowa_coap_result_callback_t \u00b6 The CoAP APIs iowa_coap_peer_get() and iowa_coap_block_request_next() are using an iowa_coap_result_callback_t to asynchronously return the result of the operation. typedef void ( * iowa_coap_result_callback_t )( iowa_coap_peer_t * fromPeer , uint8_t code , iowa_coap_message_t * messageP , void * userData , iowa_context_t contextP ); fromPeer : The CoAP peer we sent the request to. code : The Code of the CoAP Message or the result of the transmission. messageP : The received CoAP Message. This can be nil. userData : The iowa_coap_peer_get() or iowa_coap_block_request_next() parameter. contextP : The IOWA context on which the CoAP API ( iowa_coap_peer_get() or iowa_coap_block_request_next() ) was called. iowa_coap_peer_event_callback_t \u00b6 typedef void ( * iowa_coap_peer_event_callback_t )( iowa_coap_peer_t * fromPeer , iowa_coap_peer_event_t event , void * userData , iowa_context_t contextP ); fromPeer : The CoAP peer which generated the event. event : The event generated by the peer. See iowa_coap_peer_event_t . userData : The iowa_coap_peer_new() parameter. contextP : The IOWA context on which iowa_coap_peer_new() was called. \\clearpage API \u00b6 iowa_coap_peer_new \u00b6 Prototype iowa_coap_peer_t * iowa_coap_peer_new ( iowa_context_t contextP , const char * uri , iowa_security_mode_t securityMode , iowa_coap_peer_event_callback_t eventCb , void * callbackUserData ); Description iowa_coap_peer_new() creates a new CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. uri : The URI of the CoAP peer. securityMode : The security to use with this CoAP peer. See iowa_security_mode_t . eventCb : The callback to call when this CoAP peer generates an event. callbackUserData : A pointer to application specific data. This is passed as argument to messageCb and eventCb . This can be nil. Return Value A pointer to an iowa_coap_peer_t in case of success or NULL in case of memory allocation error, invalid URI, or if iowa_system_connection_open() returned an error. Header File iowa_coap.h \\clearpage iowa_coap_peer_delete \u00b6 Prototype void iowa_coap_peer_delete ( iowa_context_t contextP , iowa_coap_peer_t * peerP ); Description iowa_coap_peer_delete() closes a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to close. This can be nil. Header File iowa_coap.h \\clearpage iowa_coap_peer_configuration_set \u00b6 Prototype iowa_status_t iowa_coap_peer_configuration_set ( iowa_context_t contextP , iowa_coap_peer_t * peerP , iowa_coap_setting_id_t settingId , void * argP ); Description iowa_coap_peer_configuration_set() configures the settings of a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to configure. settingId : The setting to set. See iowa_coap_setting_id_t . argP : A pointer to the setting value. Dependent on settingId . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP is nil. IOWA_COAP_405_METHOD_NOT_ALLOWED : settingId is not valid for this peer type. IOWA_COAP_422_UNPROCESSABLE_ENTITY : peerP is of an unsupported type. Header File iowa_coap.h \\clearpage iowa_coap_peer_configuration_get \u00b6 Prototype iowa_status_t iowa_coap_peer_configuration_get ( iowa_context_t contextP , iowa_coap_peer_t * peerP , iowa_coap_setting_id_t settingId , void * argP ); Description iowa_coap_peer_configuration_get() retrieves the value of a setting of a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to retrieve the setting from. settingId : The setting to retrieve. See iowa_coap_setting_id_t . argP : A pointer to store the setting value. Dependent on settingId . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP is nil. IOWA_COAP_405_METHOD_NOT_ALLOWED : settingId is not valid for this peer type. IOWA_COAP_422_UNPROCESSABLE_ENTITY : peerP is of an unsupported type. Header File iowa_coap.h \\clearpage iowa_coap_peer_connect \u00b6 Prototype iowa_status_t iowa_coap_peer_connect ( iowa_context_t contextP , iowa_coap_peer_t * peerP ); Description iowa_coap_peer_connect() opens a connection with a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to connect. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP is nil. Header File iowa_coap.h Notes The actual result of the connection is indicated by a call to the iowa_coap_peer_event_callback_t associated to the CoAP peer. \\clearpage iowa_coap_peer_disconnect \u00b6 Prototype void iowa_coap_peer_disconnect ( iowa_context_t contextP , iowa_coap_peer_t * peerP ); Description iowa_coap_peer_disconnect() closes a connection with a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to disconnect. This can be nil. Return Value None. Header File iowa_coap.h Notes The actual result of the disconnection is indicated by a call to the iowa_coap_peer_event_callback_t associated to the CoAP peer. \\clearpage iowa_coap_peer_get \u00b6 Prototype iowa_status_t iowa_coap_peer_get ( iowa_context_t contextP , iowa_coap_peer_t * peerP , const char * path , const char * query , iowa_coap_result_callback_t resultCb , void * userData ); Description iowa_coap_peer_get() sends a CoAP GET request to a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to send the request to. path : The path component of the uri to retrieve. This can be nil. query : The query component of the uri to retrieve. This can be nil. resultCb : The callback to call when a reply is received or when the transmission fails. userData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP or resultCb is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : either: : - the CoAP peer is not connected. : - iowa_system_connection_send() returned an error. Header File iowa_coap.h \\clearpage iowa_coap_message_get_payload \u00b6 Prototype size_t iowa_coap_message_get_payload ( iowa_coap_message_t * messageP , iowa_content_format_t * formatP , uint8_t ** payloadP ); Description iowa_coap_message_get_payload() retrieves the pointer to the payload of a CoAP message. Arguments messageP : the CoAP message to inspect. formatP : OUT. The content format of the payload. This can be nil. payloadP : OUT. A pointer to the payload of the message. This can be nil. Return Value The length in bytes of the payload. Notes If the CoAP message has ne Content-format option, formatP will be set to IOWA_CONTENT_FORMAT_UNSET . Header File iowa_coap.h \\clearpage iowa_coap_message_get_block_info \u00b6 Prototype iowa_status_t iowa_coap_message_get_block_info ( iowa_coap_message_t * messageP , uint32_t * numberP , bool * moreP , uint16_t * sizeP ); Description iowa_coap_message_get_block_info() retrieves block information in a CoAP message. Arguments messageP : the CoAP message to inspect. numberP : OUT. the block number. moreP : OUT. true if there are more blocks coming. sizeP : OUT. the size of the block. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : if the CoAP message has no block information. Header File iowa_coap.h \\clearpage iowa_coap_block_request_next \u00b6 Prototype iowa_status_t iowa_coap_block_request_next ( iowa_context_t contextP , iowa_coap_peer_t * peerP , iowa_coap_message_t * messageP , iowa_coap_message_callback_t resultCb , void * userData ); Description When receiving a reply with a block option, iowa_coap_block_request_next() requests the next block from the CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to send the message to. messageP : The CoAP message containing the previous block. resultCb : The callback to call when the next block is received, or if an error occurs. userData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP or messageP is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : either: : - the CoAP peer is not connected. : - iowa_system_connection_send() returned an error. Notes IOWA must be compiled with the flag [ IOWA_COAP_BLOCK_SUPPORT ][Additional flags]. Header File iowa_coap.h \\clearpage iowa_coap_block_request_block_number \u00b6 Prototype uint8_t iowa_coap_block_request_block_number ( iowa_context_t contextP , iowa_coap_peer_t * peerP , iowa_coap_message_t * messageP , uint32_t blockNumber , iowa_coap_result_callback_t resultCb , void * userData ); Description When receiving a reply with a block option, iowa_coap_block_request_block_number() requests a specific block from the CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to send the message to. messageP : The CoAP message containing the block transfer. blockNumber : the block number. resultCb : The callback to call when the block is received, or if an error occurs. userData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP or messageP is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : either: : - the CoAP peer is not connected. : - iowa_system_connection_send() returned an error. Notes IOWA must be compiled with the flag [ IOWA_COAP_BLOCK_SUPPORT ][Additional flags]. Header File iowa_coap.h \\clearpage Helper Functions \u00b6 iowa_coap_uri_parse \u00b6 Prototype iowa_status_t iowa_coap_uri_parse ( const char * uri , iowa_connection_type_t * typeP , char ** hostnameP , char ** portP , char ** pathP , char ** queryP , bool * isSecureP ); Description iowa_coap_uri_parse() parses an URI and may return its type, hostname, port, path, and query. Arguments uri : the URI to parse. typeP : OUT. the connection type. hostnameP : OUT. the hostname. This can be nil. portP : OUT. the port. This can be nil. pathP : OUT. the path. This can be nil. queryP : OUT. the path. This can be nil. isSecureP : OUT. inform if the connection is secured. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : uri is nil. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - the URI schema has not been recognized. : - the URI format is invalid. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Notes If hostnameP , portP , pathP , or queryP are not nil, they will point to dynamically allocated memory. It is the caller responsibility to free this memory. Header File iowa_coap.h \\clearpage","title":"CoAP API Reference"},{"location":"CoapAPI/#coap-api-reference","text":"The functions explained below are defined inside the file include/iowa_coap.h .","title":"CoAP API Reference"},{"location":"CoapAPI/#coap-client-pseudo-code","text":"#include \"iowa_coap.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_coap_peer_t * peerP ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); peerP = iowa_coap_peer_new ( iowaH , \"coap://coap.example.com\" , IOWA_SEC_NONE , NULL , prv_coapEventCallback , NULL ); result = iowa_coap_peer_connect ( iowaH , peerP ); /****************** * \"Main loop\" */ while ( result == IOWA_COAP_NO_ERROR ) { result = iowa_step ( iowaH , 10 ); } iowa_coap_peer_delete ( iowaH , peerP ); iowa_close ( iowaH ); close ( serverSocket ); return 0 ; } void prv_coapEventCallback ( iowa_coap_peer_t * fromPeer , iowa_coap_event_t event , void * userData , iowa_context_t contextP ) { if ( event == COAP_EVENT_CONNECTED ) { iowa_status_t result ; // Sending a GET on \"/test\" result = iowa_coap_peer_get ( contextP , fromPeer , \"/test\" , prv_resultCallback , userData ); } else if ( event == COAP_EVENT_DISCONNECTED ) { iowa_coap_peer_delete ( contextP , fromPeer ); } } void prv_resultCallback ( iowa_coap_peer_t * fromPeer , uint8_t code , iowa_coap_message_t * responseP , void * userData , iowa_context_t contextP ) { printf ( \"Result for GET: %u.%02u. \\r\\n \" , ( code & 0xFF ) >> 5 , ( code & 0x1F )); if ( code == IOWA_COAP_205_CONTENT ) { printf ( \"Payload: %.*s\" , responseP -> payloadLength , responseP -> payload ); } }","title":"CoAP client pseudo code"},{"location":"CoapAPI/#data-types","text":"","title":"Data types"},{"location":"CoapAPI/#iowa_coap_peer_t","text":"typedef struct _iowa_coap_peer_t iowa_coap_peer_t ; iowa_coap_peer_t is an opaque type describing a CoAP peer.","title":"iowa_coap_peer_t"},{"location":"CoapAPI/#iowa_coap_peer_event_t","text":"typedef enum { COAP_EVENT_UNDEFINED = 0 , COAP_EVENT_CONNECTED , COAP_EVENT_DISCONNECTED } iowa_coap_peer_event_t ; iowa_coap_peer_event_t contains the possible events that can be reported by a CoAP peer.","title":"iowa_coap_peer_event_t"},{"location":"CoapAPI/#iowa_coap_message_t","text":"typedef struct _iowa_coap_message_t iowa_coap_message_t ; iowa_coap_message_t is an opaque type describing a CoAP message.","title":"iowa_coap_message_t"},{"location":"CoapAPI/#iowa_coap_setting_id_t","text":"typedef uint8_t iowa_coap_setting_id_t ;","title":"iowa_coap_setting_id_t"},{"location":"CoapAPI/#possible-values","text":"IOWA_COAP_SETTING_ACK_TIMEOUT : The RFC7252 ACK_TIMEOUT value as an uint8_t . IOWA_COAP_SETTING_MAX_RETRANSMIT : The RFC7252 MAX_RETRANSMIT value as an uint8_t . IOWA_COAP_SETTING_URI_LENGTH : The length in bytes of the URI as a size_t . This is a read-only setting. IOWA_COAP_SETTING_URI : The URI as a char * . This is a read-only setting. The passed argument must point to a buffer of at least the size indicated by IOWA_COAP_SETTING_URI_LENGTH . \\clearpage","title":"Possible Values"},{"location":"CoapAPI/#callbacks","text":"","title":"Callbacks"},{"location":"CoapAPI/#iowa_coap_result_callback_t","text":"The CoAP APIs iowa_coap_peer_get() and iowa_coap_block_request_next() are using an iowa_coap_result_callback_t to asynchronously return the result of the operation. typedef void ( * iowa_coap_result_callback_t )( iowa_coap_peer_t * fromPeer , uint8_t code , iowa_coap_message_t * messageP , void * userData , iowa_context_t contextP ); fromPeer : The CoAP peer we sent the request to. code : The Code of the CoAP Message or the result of the transmission. messageP : The received CoAP Message. This can be nil. userData : The iowa_coap_peer_get() or iowa_coap_block_request_next() parameter. contextP : The IOWA context on which the CoAP API ( iowa_coap_peer_get() or iowa_coap_block_request_next() ) was called.","title":"iowa_coap_result_callback_t"},{"location":"CoapAPI/#iowa_coap_peer_event_callback_t","text":"typedef void ( * iowa_coap_peer_event_callback_t )( iowa_coap_peer_t * fromPeer , iowa_coap_peer_event_t event , void * userData , iowa_context_t contextP ); fromPeer : The CoAP peer which generated the event. event : The event generated by the peer. See iowa_coap_peer_event_t . userData : The iowa_coap_peer_new() parameter. contextP : The IOWA context on which iowa_coap_peer_new() was called. \\clearpage","title":"iowa_coap_peer_event_callback_t"},{"location":"CoapAPI/#api","text":"","title":"API"},{"location":"CoapAPI/#iowa_coap_peer_new","text":"Prototype iowa_coap_peer_t * iowa_coap_peer_new ( iowa_context_t contextP , const char * uri , iowa_security_mode_t securityMode , iowa_coap_peer_event_callback_t eventCb , void * callbackUserData ); Description iowa_coap_peer_new() creates a new CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. uri : The URI of the CoAP peer. securityMode : The security to use with this CoAP peer. See iowa_security_mode_t . eventCb : The callback to call when this CoAP peer generates an event. callbackUserData : A pointer to application specific data. This is passed as argument to messageCb and eventCb . This can be nil. Return Value A pointer to an iowa_coap_peer_t in case of success or NULL in case of memory allocation error, invalid URI, or if iowa_system_connection_open() returned an error. Header File iowa_coap.h \\clearpage","title":"iowa_coap_peer_new"},{"location":"CoapAPI/#iowa_coap_peer_delete","text":"Prototype void iowa_coap_peer_delete ( iowa_context_t contextP , iowa_coap_peer_t * peerP ); Description iowa_coap_peer_delete() closes a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to close. This can be nil. Header File iowa_coap.h \\clearpage","title":"iowa_coap_peer_delete"},{"location":"CoapAPI/#iowa_coap_peer_configuration_set","text":"Prototype iowa_status_t iowa_coap_peer_configuration_set ( iowa_context_t contextP , iowa_coap_peer_t * peerP , iowa_coap_setting_id_t settingId , void * argP ); Description iowa_coap_peer_configuration_set() configures the settings of a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to configure. settingId : The setting to set. See iowa_coap_setting_id_t . argP : A pointer to the setting value. Dependent on settingId . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP is nil. IOWA_COAP_405_METHOD_NOT_ALLOWED : settingId is not valid for this peer type. IOWA_COAP_422_UNPROCESSABLE_ENTITY : peerP is of an unsupported type. Header File iowa_coap.h \\clearpage","title":"iowa_coap_peer_configuration_set"},{"location":"CoapAPI/#iowa_coap_peer_configuration_get","text":"Prototype iowa_status_t iowa_coap_peer_configuration_get ( iowa_context_t contextP , iowa_coap_peer_t * peerP , iowa_coap_setting_id_t settingId , void * argP ); Description iowa_coap_peer_configuration_get() retrieves the value of a setting of a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to retrieve the setting from. settingId : The setting to retrieve. See iowa_coap_setting_id_t . argP : A pointer to store the setting value. Dependent on settingId . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP is nil. IOWA_COAP_405_METHOD_NOT_ALLOWED : settingId is not valid for this peer type. IOWA_COAP_422_UNPROCESSABLE_ENTITY : peerP is of an unsupported type. Header File iowa_coap.h \\clearpage","title":"iowa_coap_peer_configuration_get"},{"location":"CoapAPI/#iowa_coap_peer_connect","text":"Prototype iowa_status_t iowa_coap_peer_connect ( iowa_context_t contextP , iowa_coap_peer_t * peerP ); Description iowa_coap_peer_connect() opens a connection with a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to connect. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP is nil. Header File iowa_coap.h Notes The actual result of the connection is indicated by a call to the iowa_coap_peer_event_callback_t associated to the CoAP peer. \\clearpage","title":"iowa_coap_peer_connect"},{"location":"CoapAPI/#iowa_coap_peer_disconnect","text":"Prototype void iowa_coap_peer_disconnect ( iowa_context_t contextP , iowa_coap_peer_t * peerP ); Description iowa_coap_peer_disconnect() closes a connection with a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to disconnect. This can be nil. Return Value None. Header File iowa_coap.h Notes The actual result of the disconnection is indicated by a call to the iowa_coap_peer_event_callback_t associated to the CoAP peer. \\clearpage","title":"iowa_coap_peer_disconnect"},{"location":"CoapAPI/#iowa_coap_peer_get","text":"Prototype iowa_status_t iowa_coap_peer_get ( iowa_context_t contextP , iowa_coap_peer_t * peerP , const char * path , const char * query , iowa_coap_result_callback_t resultCb , void * userData ); Description iowa_coap_peer_get() sends a CoAP GET request to a CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to send the request to. path : The path component of the uri to retrieve. This can be nil. query : The query component of the uri to retrieve. This can be nil. resultCb : The callback to call when a reply is received or when the transmission fails. userData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP or resultCb is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : either: : - the CoAP peer is not connected. : - iowa_system_connection_send() returned an error. Header File iowa_coap.h \\clearpage","title":"iowa_coap_peer_get"},{"location":"CoapAPI/#iowa_coap_message_get_payload","text":"Prototype size_t iowa_coap_message_get_payload ( iowa_coap_message_t * messageP , iowa_content_format_t * formatP , uint8_t ** payloadP ); Description iowa_coap_message_get_payload() retrieves the pointer to the payload of a CoAP message. Arguments messageP : the CoAP message to inspect. formatP : OUT. The content format of the payload. This can be nil. payloadP : OUT. A pointer to the payload of the message. This can be nil. Return Value The length in bytes of the payload. Notes If the CoAP message has ne Content-format option, formatP will be set to IOWA_CONTENT_FORMAT_UNSET . Header File iowa_coap.h \\clearpage","title":"iowa_coap_message_get_payload"},{"location":"CoapAPI/#iowa_coap_message_get_block_info","text":"Prototype iowa_status_t iowa_coap_message_get_block_info ( iowa_coap_message_t * messageP , uint32_t * numberP , bool * moreP , uint16_t * sizeP ); Description iowa_coap_message_get_block_info() retrieves block information in a CoAP message. Arguments messageP : the CoAP message to inspect. numberP : OUT. the block number. moreP : OUT. true if there are more blocks coming. sizeP : OUT. the size of the block. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : if the CoAP message has no block information. Header File iowa_coap.h \\clearpage","title":"iowa_coap_message_get_block_info"},{"location":"CoapAPI/#iowa_coap_block_request_next","text":"Prototype iowa_status_t iowa_coap_block_request_next ( iowa_context_t contextP , iowa_coap_peer_t * peerP , iowa_coap_message_t * messageP , iowa_coap_message_callback_t resultCb , void * userData ); Description When receiving a reply with a block option, iowa_coap_block_request_next() requests the next block from the CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to send the message to. messageP : The CoAP message containing the previous block. resultCb : The callback to call when the next block is received, or if an error occurs. userData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP or messageP is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : either: : - the CoAP peer is not connected. : - iowa_system_connection_send() returned an error. Notes IOWA must be compiled with the flag [ IOWA_COAP_BLOCK_SUPPORT ][Additional flags]. Header File iowa_coap.h \\clearpage","title":"iowa_coap_block_request_next"},{"location":"CoapAPI/#iowa_coap_block_request_block_number","text":"Prototype uint8_t iowa_coap_block_request_block_number ( iowa_context_t contextP , iowa_coap_peer_t * peerP , iowa_coap_message_t * messageP , uint32_t blockNumber , iowa_coap_result_callback_t resultCb , void * userData ); Description When receiving a reply with a block option, iowa_coap_block_request_block_number() requests a specific block from the CoAP peer. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. peerP : The CoAP peer to send the message to. messageP : The CoAP message containing the block transfer. blockNumber : the block number. resultCb : The callback to call when the block is received, or if an error occurs. userData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_402_BAD_OPTION : peerP or messageP is nil. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : either: : - the CoAP peer is not connected. : - iowa_system_connection_send() returned an error. Notes IOWA must be compiled with the flag [ IOWA_COAP_BLOCK_SUPPORT ][Additional flags]. Header File iowa_coap.h \\clearpage","title":"iowa_coap_block_request_block_number"},{"location":"CoapAPI/#helper-functions","text":"","title":"Helper Functions"},{"location":"CoapAPI/#iowa_coap_uri_parse","text":"Prototype iowa_status_t iowa_coap_uri_parse ( const char * uri , iowa_connection_type_t * typeP , char ** hostnameP , char ** portP , char ** pathP , char ** queryP , bool * isSecureP ); Description iowa_coap_uri_parse() parses an URI and may return its type, hostname, port, path, and query. Arguments uri : the URI to parse. typeP : OUT. the connection type. hostnameP : OUT. the hostname. This can be nil. portP : OUT. the port. This can be nil. pathP : OUT. the path. This can be nil. queryP : OUT. the path. This can be nil. isSecureP : OUT. inform if the connection is secured. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : uri is nil. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - the URI schema has not been recognized. : - the URI format is invalid. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Notes If hostnameP , portP , pathP , or queryP are not nil, they will point to dynamically allocated memory. It is the caller responsibility to free this memory. Header File iowa_coap.h \\clearpage","title":"iowa_coap_uri_parse"},{"location":"CommonAPI/","text":"Common API Reference \u00b6 The functions explained below are defined inside the file include/iowa.h . Presentation \u00b6 Whatever the role of your application (Client or Server), it builds on the following skeleton: #include \"iowa.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); /****************** * \"Main loop\" */ do { result = iowa_step ( iowaH , 5 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_close ( iowaH ); return 0 ; } Data types \u00b6 iowa_status_t \u00b6 This is the return type of most of the IOWA APIs. This is an enumeration matching the CoAP status codes, similar to the HTTP status codes. typedef uint8_t iowa_status_t ; #define IOWA_COAP_NO_ERROR 0x00 #define IOWA_COAP_201_CREATED 0x41 #define IOWA_COAP_202_DELETED 0x42 #define IOWA_COAP_203_VALID 0x43 #define IOWA_COAP_204_CHANGED 0x44 #define IOWA_COAP_205_CONTENT 0x45 #define IOWA_COAP_231_CONTINUE 0x5F #define IOWA_COAP_400_BAD_REQUEST 0x80 #define IOWA_COAP_401_UNAUTHORIZED 0x81 #define IOWA_COAP_402_BAD_OPTION 0x82 #define IOWA_COAP_403_FORBIDDEN 0x83 #define IOWA_COAP_404_NOT_FOUND 0x84 #define IOWA_COAP_405_METHOD_NOT_ALLOWED 0x85 #define IOWA_COAP_406_NOT_ACCEPTABLE 0x86 #define IOWA_COAP_408_REQUEST_ENTITY_INCOMPLETE 0x88 #define IOWA_COAP_409_CONFLICT 0x89 #define IOWA_COAP_412_PRECONDITION_FAILED 0x8C #define IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE 0x8D #define IOWA_COAP_415_UNSUPPORTED_CONTENT_FORMAT 0x8F #define IOWA_COAP_422_UNPROCESSABLE_ENTITY 0x96 #define IOWA_COAP_429_TOO_MANY_REQUESTS 0x9D #define IOWA_COAP_500_INTERNAL_SERVER_ERROR 0xA0 #define IOWA_COAP_501_NOT_IMPLEMENTED 0xA1 #define IOWA_COAP_502_BAD_GATEWAY 0xA2 #define IOWA_COAP_503_SERVICE_UNAVAILABLE 0xA3 #define IOWA_COAP_504_GATEWAY_TIMEOUT 0xA4 #define IOWA_COAP_505_PROXYING_NOT_SUPPORTED 0xA5 iowa_context_t \u00b6 This opaque type is used to store the context of the IOWA stack engine. It is created by calling iowa_init() and destroyed by calling iowa_close() . Multiple iowa_context_t can be created within the same process. iowa_dm_operation_t \u00b6 typedef uint8_t iowa_dm_operation_t ; #define IOWA_DM_UNDEFINED 0 #define IOWA_DM_READ 1 #define IOWA_DM_FREE 2 #define IOWA_DM_WRITE 3 #define IOWA_DM_EXECUTE 4 #define IOWA_DM_CREATE 5 #define IOWA_DM_DELETE 6 #define IOWA_DM_DISCOVER 7 #define IOWA_DM_WRITE_ATTRIBUTES 8 #define IOWA_DM_NOTIFY 9 #define IOWA_DM_CANCEL 10 #define IOWA_DM_DATA_PUSH 11 #define IOWA_DM_READ_REQUEST 12 This is an enumeration of the following values: IOWA_DM_UNDEFINED : No specific LwM2M operation, this should never be used and only serves as a non default operation. IOWA_DM_READ : LwM2M Read operation is used to access the value of an Object, Object Instances, and Resources. IOWA_DM_FREE : Free operation is used to clean the allocated memory on IOWA_DM_READ operation. IOWA_DM_WRITE : LwM2M Write operation is used to change the value of an Object, Object Instances, and Resources. IOWA_DM_EXECUTE : LwM2M Execute operation is used to initiate some action, and can only be performed on individual Resources. IOWA_DM_CREATE : LwM2M Create operation is used to create Object Instance(s). IOWA_DM_DELETE : LwM2M Delete operation is used to delete an Object Instance. IOWA_DM_DISCOVER : LwM2M Discover operation is used to discover LwM2M Attributes attached to an Object, Object Instances, and Resources. IOWA_DM_WRITE_ATTRIBUTES : LwM2M Write-Attributes operation is used to change the LwM2M Attributes of an Object, Object Instances, and Resources. IOWA_DM_NOTIFY : LwM2M Notify operation is used to notify the change of a value during a valid Observation on an Object Instance or Resource. IOWA_DM_CANCEL : LwM2M Cancel operation is used to end an Observation. IOWA_DM_DATA_PUSH : LwM2M Data push operation is used when LwM2M Server receives the value of an Object, Object Instances, and Resources without requested it. IOWA_DM_READ_REQUEST : On the Client side, inform a custom Object that a LwM2M Server will perform a READ operation. See iowa_lwm2m_resource_desc_t . Notes \u00b6 This enumeration is used on both Server and Client side. But not all the values are used depending of the side. Server callbacks can be called with: IOWA_DM_READ IOWA_DM_WRITE IOWA_DM_EXECUTE IOWA_DM_CREATE IOWA_DM_DELETE IOWA_DM_DISCOVER IOWA_DM_WRITE_ATTRIBUTES IOWA_DM_NOTIFY IOWA_DM_DATA_PUSH Client callbacks can be called with: IOWA_DM_READ IOWA_DM_FREE IOWA_DM_WRITE IOWA_DM_EXECUTE IOWA_DM_CREATE IOWA_DM_DELETE IOWA_DM_DATA_PUSH iowa_bootstrap_operation_t \u00b6 typedef uint8_t iowa_bootstrap_operation_t ; #define IOWA_BOOTSTRAP_UNDEFINED 0 #define IOWA_BOOTSTRAP_READ 101 #define IOWA_BOOTSTRAP_WRITE 102 #define IOWA_BOOTSTRAP_DELETE 103 #define IOWA_BOOTSTRAP_DISCOVER 104 #define IOWA_BOOTSTRAP_FINISH 105 #define IOWA_BOOTSTRAP_ADD_SERVER 106 #define IOWA_BOOTSTRAP_REMOVE_SERVER 107 #define IOWA_BOOTSTRAP_ADD_BOOTSTRAP_SERVER 108 #define IOWA_BOOTSTRAP_REMOVE_BOOTSTRAP_SERVER 109 This is an enumeration of the following values: IOWA_BOOTSTRAP_UNDEFINED : No specific LwM2M operation, this should never be used and only serves as a non default operation. IOWA_BOOTSTRAP_READ : LwM2M Read operation is used to access the value of an Object, Object Instances, and Resources. IOWA_BOOTSTRAP_WRITE : LwM2M Write operation is used to change the value of an Object, and Object Instances regardless of an existence of the targeted Object Instance(s). IOWA_BOOTSTRAP_DELETE : LwM2M Delete operation is used to delete any Object Instance or all Instances of any Object including the Security Object (ID:0). IOWA_BOOTSTRAP_DISCOVER : LwM2M Bootstrap Discover operation is used to discover which LwM2M Objects and Object Instances are supported on a LwM2M Client. In particular, the list of Security Object Instances (ID:0) is reported. IOWA_BOOTSTRAP_FINISH : LwM2M Finish operation is used to terminate the Bootstrap Sequence. IOWA_BOOTSTRAP_ADD_SERVER : Custom LwM2M Bootstrap Add Server operation is used to write the proper Object Instances of Security Object (ID:0) and Server Object (ID:1) to add a LwM2M Server Account. IOWA_BOOTSTRAP_REMOVE_SERVER : Custom LwM2M Bootstrap Remove Server operation is used to delete the proper Object Instances of Security Object (ID:0) and Server Object (ID:1) associated to a LwM2M Server Account. IOWA_BOOTSTRAP_ADD_BOOTSTRAP_SERVER : Custom LwM2M Bootstrap Add Bootstrap Server operation is used to write the proper Object Instance of Security Object (ID:0) add a LwM2M Bootstrap Server Account. IOWA_BOOTSTRAP_REMOVE_BOOTSTRAP_SERVER : Custom LwM2M Bootstrap Remove Bootstrap Server operation is used to delete the proper Object Instance of Security Object (ID:0) associated to a LwM2M Bootstrap Server Account. iowa_lwm2m_data_type_t \u00b6 typedef uint8_t iowa_lwm2m_data_type_t ; #define IOWA_LWM2M_TYPE_UNDEFINED 0 #define IOWA_LWM2M_TYPE_STRING 1 #define IOWA_LWM2M_TYPE_OPAQUE 2 #define IOWA_LWM2M_TYPE_INTEGER 3 #define IOWA_LWM2M_TYPE_FLOAT 4 #define IOWA_LWM2M_TYPE_BOOLEAN 5 #define IOWA_LWM2M_TYPE_CORE_LINK 6 #define IOWA_LWM2M_TYPE_OBJECT_LINK 7 #define IOWA_LWM2M_TYPE_TIME 8 #define IOWA_LWM2M_TYPE_UNSIGNED_INTEGER 9 This is an enumeration of the following values: IOWA_LWM2M_TYPE_UNDEFINED : No specific data type: it is only used for Executable Resource. IOWA_LWM2M_TYPE_STRING : A UTF-8 string. IOWA_LWM2M_TYPE_OPAQUE : A sequence of binary octets. IOWA_LWM2M_TYPE_INTEGER : An 64-bit signed integer. IOWA_LWM2M_TYPE_FLOAT : A 32 or 64-bit floating point value. IOWA_LWM2M_TYPE_BOOLEAN : An unsigned integer with the value 0 for false and the value 1 for true. IOWA_LWM2M_TYPE_CORE_LINK : A UTF-8 string representing the relation between resources and links. IOWA_LWM2M_TYPE_OBJECT_LINK : Reference to an Instance of a given Object. IOWA_LWM2M_TYPE_TIME : A signed integer representing the number of seconds. IOWA_LWM2M_TYPE_UNSIGNED_INTEGER : An unsigned integer. iowa_lwm2m_data_t \u00b6 When the LwM2M Server and the LwM2M Client exchange data, at the application level, they are presented in iowa_lwm2m_data_t structures. typedef struct { uint16_t objectID ; uint16_t instanceID ; uint16_t resourceID ; uint16_t resInstanceID ; iowa_lwm2m_data_type_t type ; union { bool asBoolean ; int64_t asInteger ; double asFloat ; struct { size_t length ; uint8_t * buffer ; } asBuffer ; iowa_lwm2m_object_link_t asObjLink ; } value ; int32_t timestamp ; } iowa_lwm2m_data_t ; This structure contains the value of a LwM2M resource along its complete URI. objectID : ID of the Object containing the resource. instanceID : ID of the Object Instance containing the resource. resourceID : ID of the resource. resInstanceID : ID of the resource instance. For single instance resource, this is always IOWA_LWM2M_ID_ALL . type : The datatype of the resource. value.asBoolean : The value of the resource when type is IOWA_LWM2M_TYPE_BOOLEAN . value.asInteger : The value of the resource when type is IOWA_LWM2M_TYPE_INTEGER , IOWA_LWM2M_TYPE_TIME or IOWA_LWM2M_TYPE_UNSIGNED_INTEGER . value.asFloat : The value of the resource when type is IOWA_LWM2M_TYPE_FLOAT . value.asBuffer : The value of the resource when type is IOWA_LWM2M_TYPE_CORE_LINK , IOWA_LWM2M_TYPE_STRING , IOWA_LWM2M_TYPE_OPAQUE or IOWA_LWM2M_TYPE_UNDEFINED . value.asObjLink : The value of the resource when type is IOWA_LWM2M_TYPE_OBJECT_LINK . timestamp : The timestamp value in seconds. Time is always absolute, and timestamp is present when the value is greater than zero. This can not be negative. iowa_lwm2m_object_link_t \u00b6 typedef struct { uint16_t objectId ; uint16_t instanceId ; } iowa_lwm2m_object_link_t ; iowa_content_format_t \u00b6 typedef uint16_t iowa_content_format_t ; #define IOWA_CONTENT_FORMAT_TEXT 0 #define IOWA_CONTENT_FORMAT_OPAQUE 42 #define IOWA_CONTENT_FORMAT_CBOR 60 #define IOWA_CONTENT_FORMAT_SENML_JSON 110 #define IOWA_CONTENT_FORMAT_SENML_CBOR 112 #define IOWA_CONTENT_FORMAT_TLV_OLD 1542 #define IOWA_CONTENT_FORMAT_JSON_OLD 1543 #define IOWA_CONTENT_FORMAT_TLV 11542 #define IOWA_CONTENT_FORMAT_JSON 11543 #define IOWA_CONTENT_FORMAT_UNSET 0xFFFF This is an enumeration of the following values: IOWA_CONTENT_FORMAT_TEXT : Plain text encoding (e.g. \"123\", \"-123.45\"). Usable only for single resource encoding. IOWA_CONTENT_FORMAT_OPAQUE : A sequence of binary octets. Usable only for single resource encoding which data type is Opaque . IOWA_CONTENT_FORMAT_CBOR : CBOR encoding. Usable only for single resource encoding. IOWA_CONTENT_FORMAT_SENML_JSON : LwM2M specific SenML JSON encoding. This may not be supported by all Clients. See iowa_client_t . IOWA_CONTENT_FORMAT_SENML_CBOR : LwM2M specific SenML CBOR encoding. This may not be supported by all Clients. See iowa_client_t . IOWA_CONTENT_FORMAT_TLV_OLD : LwM2M specific binary Type-Length-Value format. Usually the most compact one. This one is not anymore used, it only serves as backward compatibility with old LwM2M stack implementation (previous 1.0). IOWA_CONTENT_FORMAT_JSON_OLD : LwM2M specific JSON encoding. This may not be supported by all Clients. See iowa_client_t . This one is not anymore used, it only serves as backward compatibility with old LwM2M stack implementation (previous 1.0). IOWA_CONTENT_FORMAT_TLV : LwM2M specific binary Type-Length-Value format. Usually the most compact one. IOWA_CONTENT_FORMAT_JSON : LwM2M specific JSON encoding. This may not be supported by all Clients. See iowa_client_t . IOWA_CONTENT_FORMAT_UNSET : Used to reset the encoding to the default one. iowa_lwm2m_uri_t \u00b6 typedef struct { uint16_t objectId ; uint16_t instanceId ; uint16_t resourceId ; uint16_t resInstanceId ; } iowa_lwm2m_uri_t ; This structure represents a LwM2M URI. In the LwM2M resource model, resources are grouped into Objects. These Objects have instances. Hence the URI of a resource is in the form /{Object}/{Object Instance}/{Resource} . Moreover some resources, described are multiple , can have several instances, leading to URI in the form /{Object}/{Object Instance}/{Resource}/{Resource Instance} . objectId : ID of a LwM2M Object. instanceId : ID of the Object Instance. resourceId : ID of the resource. resInstanceId : ID of the resource instance. When a segment of the URI is not set, the value of the corresponding field is set to IOWA_LWM2M_ID_ALL . For instance, the URI /3/0/9 is represented as: iowa_lwm2m_uri_t :: objectId = 3 iowa_lwm2m_uri_t :: instanceId = 0 iowa_lwm2m_uri_t :: resourceId = 9 iowa_lwm2m_uri_t :: resInstanceId = IOWA_LWM2M_ID_ALL the URI /5 is represented as: iowa_lwm2m_uri_t :: objectId = 5 iowa_lwm2m_uri_t :: instanceId = IOWA_LWM2M_ID_ALL iowa_lwm2m_uri_t :: resourceId = IOWA_LWM2M_ID_ALL iowa_lwm2m_uri_t :: resInstanceId = IOWA_LWM2M_ID_ALL \\clearpage iowa_response_content_t \u00b6 This structure contains the response content from iowa_response_callback_t() according to its requested operation . typedef struct { union { struct { size_t dataCount ; iowa_lwm2m_data_t * dataP ; } read ; struct { uint32_t notificationNumber ; size_t dataCount ; iowa_lwm2m_data_t * dataP ; } observe ; struct { size_t dataCount ; iowa_lwm2m_data_t * dataP ; } dataPush ; } details ; } iowa_response_content_t ; details.read : The information related to IOWA_DM_READ operation. details.read.dataCount : The number of elements in the details.read.dataP . This may be 0. details.read.dataP : An array containing the Resource values returned by the Client. This may be nil. details.observe : The information related to IOWA_DM_NOTIFY operation. details.observe.notificationNumber : The notification counter. details.observe.dataCount : The number of elements in the details.observe.dataP . This may be 0. details.observe.dataP : An array containing the Resource values returned by the Client. This may be nil. details.dataPush : The information related to IOWA_DM_DATA_PUSH operation. details.dataPush.dataCount : The number of elements in the details.dataPush.dataP . This may be 0. details.dataPush.dataP : An array containing the Resource values send by the Client. This may be nil. \\clearpage Callbacks \u00b6 iowa_response_callback_t \u00b6 The device management APIs ( iowa_server_read() , iowa_server_observe() , iowa_server_write() , iowa_server_write_attributes_string() , iowa_server_configure_data_push() , iowa_bootstrap_server_read() , iowa_client_send_sensor_data() , iowa_client_send_data() ) are using an iowa_response_callback_t to asynchronously return the result of the operation. typedef void ( * iowa_response_callback_t ) ( uint32_t sourceId , uint8_t operation , iowa_status_t status , iowa_response_content_t * contentP , void * userDataP , iowa_context_t contextP ); sourceId : The ID of the client targeted by the command for the server APIs ( iowa_server_read() , iowa_server_observe() , iowa_server_write() , iowa_server_write_attributes_string() , iowa_server_configure_data_push() ). : The ID of the server targeted by the command for the client APIs ( iowa_client_send_sensor_data() , iowa_client_send_data() ). operation : The type of command matching this result. status : The status of the command. contentP : The content of the operation. It is nil for IOWA_DM_WRITE , IOWA_DM_EXECUTE , IOWA_DM_CREATE , IOWA_DM_DELETE and IOWA_DM_WRITE_ATTRIBUTES operations. : It is also nil for IOWA_DM_DATA_PUSH if operation comes from the client APIs. : It is also nil for IOWA_DM_READ , IOWA_DM_NOTIFY , IOWA_DM_DISCOVER and IOWA_DM_DATA_PUSH if the the status is different from IOWA_205_COAP_CONTENT userDataP : A pointer to application specific data. This is a parameter of the matching device management API. contextP : The IOWA context on which the device management API was called. Notes The status can have the following values: status Description IOWA_COAP_201_CREATED IOWA_DM_CREATE operation completed successfully IOWA_COAP_202_DELETED IOWA_DM_DELETE operation completed successfully IOWA_COAP_204_CHANGED IOWA_DM_WRITE , IOWA_DM_EXECUTE , or IOWA_DM_WRITE_ATTRIBUTES operation completed successfully IOWA_COAP_205_CONTENT IOWA_DM_READ , IOWA_DM_NOTIFY , IOWA_DM_DISCOVER , or IOWA_DM_DATA_PUSH operation completed successfully IOWA_COAP_400_BAD_REQUEST Undetermined error occurred, when the request is ill-formed IOWA_COAP_401_UNAUTHORIZED Access Right Permission Denied IOWA_COAP_404_NOT_FOUND URI of the operation is not found IOWA_COAP_405_METHOD_NOT_ALLOWED Target is not allowed for the operation IOWA_COAP_406_NOT_ACCEPTABLE None of the preferred Content-Formats can be returned IOWA_COAP_408_REQUEST_ENTITY_INCOMPLETE The request or answer is incomplete IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE The request or answer is too large for the system IOWA_COAP_415_UNSUPPORTED_CONTENT_FORMAT The specified format is not supported IOWA_COAP_500_INTERNAL_SERVER_ERROR An internal server error occurred \\clearpage iowa_load_callback_t \u00b6 This callback is called during a context load with the data stored inside the context backup. typedef void ( * iowa_load_callback_t ) ( uint16_t callbackId , uint8_t * buffer , size_t bufferLength , void * userDataP ); callbackId : The identifier of the callback as passed to iowa_backup_register_callback() . buffer : The data loaded from the backup. This can be nil. bufferLength : The length of buffer in bytes. userDataP : A pointer to application specific data as passed to iowa_backup_register_callback() . \\clearpage iowa_save_callback_t \u00b6 This callback is called during a context save. It is called first to retrieve the length of the data to save, then a second time with an allocated buffer to fill with the data to save. typedef size_t ( * iowa_save_callback_t ) ( uint16_t callbackId , uint8_t * buffer , size_t bufferLength , void * userDataP ); callbackId : The identifier of the callback as passed to iowa_backup_register_callback() . buffer : A buffer to store the data. This can be nil. bufferLength : The length of buffer in bytes. userDataP : A pointer to application specific data as passed to iowa_backup_register_callback() . \\clearpage API \u00b6 iowa_init \u00b6 Prototype iowa_context_t iowa_init ( void * userData ); Description iowa_init() initializes an IOWA context. Arguments userData : Pointer to application-specific data. This is passed as argument to the Communication Abstraction Interface functions. This can be nil. Return Value An iowa_context_t in case of success or NULL in case of memory allocation error. Header File iowa.h \\clearpage iowa_step \u00b6 Prototype iowa_status_t iowa_step ( iowa_context_t contextP , int32_t timeout ); Description iowa_step() runs the stack engine during the specified time. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. timeout : The allowed time to run in seconds. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : one of the iowa_system_connection...() functions returned an error. : LwM2M Client only: when the Client failed to connect to any Server. ( iowa_event_callback_t is called with a IOWA_EVENT_REG_FAILED event.) Header File iowa.h Notes If timeout is a negative value: iowa_step() will return only in case of error. iowa_system_connection_select() will be called with INT32_MAX . For LwM2M Clients: if iowa_step() returns an IOWA_COAP_503_SERVICE_UNAVAILABLE error because it is not registered to any LwM2M Server, subsequent call to iowa_step() , will retry to register to the known LwM2M Servers. iowa_stop() can be used to make iowa_step() return immediately. \\clearpage iowa_flush_before_pause \u00b6 Prototype iowa_status_t iowa_flush_before_pause ( iowa_context_t contextP , int32_t duration , uint32_t * delayP ); Description iowa_flush_before_pause() is used to inform the stack that the device will pause. iowa_flush_before_pause() performs all the pending and required operations of the stack engine before returning. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. duration : The duration of the planned pause in seconds. delayP : The delay before the next IOWA scheduled operation. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - duration is negative. : - for a LwM2M Client: duration is longer than one of the LwM2M Server registration lifetime. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : one of the iowa_system_connection...() functions returned an error. Header File iowa.h Notes In LwM2M Client mode: if no server are configured, the function returns immediately with no error. A LwM2M Server should never stop. For a LwM2M Server, iowa_flush_before_pause() will just wait for all pending CoAP transactions to finish. \\clearpage iowa_stop \u00b6 Prototype void iowa_stop ( iowa_context_t contextP ); Description iowa_stop() stops the stack engine and make iowa_step() return immediately. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value None. Header File iowa.h \\clearpage iowa_close \u00b6 Prototype void iowa_close ( iowa_context_t contextP ); Description iowa_close() closes an IOWA context. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value None. Header File iowa.h \\clearpage iowa_clock_reset \u00b6 Prototype iowa_status_t iowa_clock_reset ( iowa_context_t contextP ); Description iowa_clock_reset() informs IOWA that iowa_system_gettime() has lost track of time and that IOWA must re-synchronize its internal timers. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : - the iowa_system_gettime() function returned an error. Header File iowa.h \\clearpage iowa_save_context \u00b6 Prototype iowa_status_t iowa_save_context ( iowa_context_t contextP ); Description iowa_save_context() saves the current IOWA context. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - the iowa_system_store_context() function returned an error. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. If IOWA is built with the IOWA_STORAGE_CONTEXT_AUTOMATIC_BACKUP flag, the context will be automatically saved: After a LwM2M Bootstrap Server or a LwM2M Server were added. After a successful Bootstrap procedure. After a LwM2M Server operation on resources related to Server Accounts. \\clearpage iowa_save_context_snapshot \u00b6 Prototype iowa_status_t iowa_save_context_snapshot ( iowa_context_t contextP ); Description iowa_save_context_snapshot() saves the current IOWA context with runtime information, observations and attributes. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - the iowa_system_store_context() function returned an error. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. \\clearpage iowa_load_context \u00b6 Prototype iowa_status_t iowa_load_context ( iowa_context_t contextP ); Description iowa_load_context() loads a saved IOWA context. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - no previous saved IOWA context found. : - In LwM2M client mode: no Security or Server objects found, the function iowa_client_configure must be called first. IOWA_COAP_409_CONFLICT : contextP isn't in init state. IOWA_COAP_422_UNPROCESSABLE_ENTITY : either: : - failed to decode the buffer retrieved from iowa_system_retrieve_context() function. : - context version isn't present or is incorrect. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - the iowa_system_retrieve_context() function returned an error. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. \\clearpage iowa_backup_register_callback \u00b6 Prototype iowa_status_t iowa_backup_register_callback ( iowa_context_t contextP , uint16_t id , iowa_save_callback_t saveCallback , iowa_load_callback_t loadCallback , void * userDataP ); Description iowa_backup_register_callback() registers context callbacks from IOWA. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The id of the callback. Must be greater than 0xF000. saveCallback : The function called during context saving. loadCallback : The function called during context loading. userDataP : Pointer to application-specific data. This is passed as argument to the callback. This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : either: : - id is incorrect. : - one of the callback is NULL. IOWA_COAP_409_CONFLICT : id is already used. IOWA_COAP_422_UNPROCESSABLE_ENTITY : failed to decode the buffer retrieved from iowa_system_retrieve_context() function. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. \\clearpage iowa_backup_deregister_callback \u00b6 Prototype void iowa_backup_deregister_callback ( iowa_context_t contextP , uint16_t id ); Description iowa_backup_deregister_callback() deregisters context callbacks from IOWA. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The id of the callback. Must be greater than 0xF000. Return Value None. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. \\clearpage iowa_connection_closed \u00b6 Prototype void iowa_connection_closed ( iowa_context_t contextP , void * connP ); Description iowa_connection_closed() informs IOWA that a connection was closed by an external event (e.g. peer disconnection). Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. connP : The closed connection of the same user-defined type as the one returned by iowa_system_connection_open() . Return Value None. Header File iowa.h \\clearpage iowa_data_get_block_info \u00b6 Prototype iowa_status_t iowa_data_get_block_info ( iowa_lwm2m_data_t * dataP , uint32_t * numberP , bool * moreP , uint16_t * sizeP ); Description iowa_data_get_block_info() retrieves the block information from an iowa_lwm2m_data_t . Arguments dataP : the iowa_lwm2m_data_t to retrieve the block information from. numberP : OUT. The block number. moreP : OUT. true if there are more blocks coming, false otherwise. sizeP : OUT. The size of the block in bytes. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : dataP does not contain any block information. IOWA_COAP_400_BAD_REQUEST : either: : - one of the parameters is nil. : - the block information in dataP is invalid. Header File iowa.h \\clearpage iowa_data_set_block_info \u00b6 Prototype iowa_status_t iowa_data_set_block_info ( iowa_lwm2m_data_t * dataP , uint32_t number , bool more , uint16_t size ); Description iowa_data_set_block_info() sets the block information of an iowa_lwm2m_data_t . Arguments dataP : the iowa_lwm2m_data_t to set the block information to. number : The block number. more : true if there are more blocks coming, false otherwise. size : The size of the block in bytes. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : dataP is nil. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - number is greater than 262 143. : - more is set to true and size is different than 16, 32, 64, 128, 256, 512, or 1024. : - more is set to false and size is either zero or greater than 1024. : - dataP data type is neither IOWA_LWM2M_TYPE_STRING , IOWA_LWM2M_TYPE_OPAQUE , nor IOWA_LWM2M_TYPE_CORE_LINK . Header File iowa.h","title":"Common APIs"},{"location":"CommonAPI/#common-api-reference","text":"The functions explained below are defined inside the file include/iowa.h .","title":"Common API Reference"},{"location":"CommonAPI/#presentation","text":"Whatever the role of your application (Client or Server), it builds on the following skeleton: #include \"iowa.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); /****************** * \"Main loop\" */ do { result = iowa_step ( iowaH , 5 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_close ( iowaH ); return 0 ; }","title":"Presentation"},{"location":"CommonAPI/#data-types","text":"","title":"Data types"},{"location":"CommonAPI/#iowa_status_t","text":"This is the return type of most of the IOWA APIs. This is an enumeration matching the CoAP status codes, similar to the HTTP status codes. typedef uint8_t iowa_status_t ; #define IOWA_COAP_NO_ERROR 0x00 #define IOWA_COAP_201_CREATED 0x41 #define IOWA_COAP_202_DELETED 0x42 #define IOWA_COAP_203_VALID 0x43 #define IOWA_COAP_204_CHANGED 0x44 #define IOWA_COAP_205_CONTENT 0x45 #define IOWA_COAP_231_CONTINUE 0x5F #define IOWA_COAP_400_BAD_REQUEST 0x80 #define IOWA_COAP_401_UNAUTHORIZED 0x81 #define IOWA_COAP_402_BAD_OPTION 0x82 #define IOWA_COAP_403_FORBIDDEN 0x83 #define IOWA_COAP_404_NOT_FOUND 0x84 #define IOWA_COAP_405_METHOD_NOT_ALLOWED 0x85 #define IOWA_COAP_406_NOT_ACCEPTABLE 0x86 #define IOWA_COAP_408_REQUEST_ENTITY_INCOMPLETE 0x88 #define IOWA_COAP_409_CONFLICT 0x89 #define IOWA_COAP_412_PRECONDITION_FAILED 0x8C #define IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE 0x8D #define IOWA_COAP_415_UNSUPPORTED_CONTENT_FORMAT 0x8F #define IOWA_COAP_422_UNPROCESSABLE_ENTITY 0x96 #define IOWA_COAP_429_TOO_MANY_REQUESTS 0x9D #define IOWA_COAP_500_INTERNAL_SERVER_ERROR 0xA0 #define IOWA_COAP_501_NOT_IMPLEMENTED 0xA1 #define IOWA_COAP_502_BAD_GATEWAY 0xA2 #define IOWA_COAP_503_SERVICE_UNAVAILABLE 0xA3 #define IOWA_COAP_504_GATEWAY_TIMEOUT 0xA4 #define IOWA_COAP_505_PROXYING_NOT_SUPPORTED 0xA5","title":"iowa_status_t"},{"location":"CommonAPI/#iowa_context_t","text":"This opaque type is used to store the context of the IOWA stack engine. It is created by calling iowa_init() and destroyed by calling iowa_close() . Multiple iowa_context_t can be created within the same process.","title":"iowa_context_t"},{"location":"CommonAPI/#iowa_dm_operation_t","text":"typedef uint8_t iowa_dm_operation_t ; #define IOWA_DM_UNDEFINED 0 #define IOWA_DM_READ 1 #define IOWA_DM_FREE 2 #define IOWA_DM_WRITE 3 #define IOWA_DM_EXECUTE 4 #define IOWA_DM_CREATE 5 #define IOWA_DM_DELETE 6 #define IOWA_DM_DISCOVER 7 #define IOWA_DM_WRITE_ATTRIBUTES 8 #define IOWA_DM_NOTIFY 9 #define IOWA_DM_CANCEL 10 #define IOWA_DM_DATA_PUSH 11 #define IOWA_DM_READ_REQUEST 12 This is an enumeration of the following values: IOWA_DM_UNDEFINED : No specific LwM2M operation, this should never be used and only serves as a non default operation. IOWA_DM_READ : LwM2M Read operation is used to access the value of an Object, Object Instances, and Resources. IOWA_DM_FREE : Free operation is used to clean the allocated memory on IOWA_DM_READ operation. IOWA_DM_WRITE : LwM2M Write operation is used to change the value of an Object, Object Instances, and Resources. IOWA_DM_EXECUTE : LwM2M Execute operation is used to initiate some action, and can only be performed on individual Resources. IOWA_DM_CREATE : LwM2M Create operation is used to create Object Instance(s). IOWA_DM_DELETE : LwM2M Delete operation is used to delete an Object Instance. IOWA_DM_DISCOVER : LwM2M Discover operation is used to discover LwM2M Attributes attached to an Object, Object Instances, and Resources. IOWA_DM_WRITE_ATTRIBUTES : LwM2M Write-Attributes operation is used to change the LwM2M Attributes of an Object, Object Instances, and Resources. IOWA_DM_NOTIFY : LwM2M Notify operation is used to notify the change of a value during a valid Observation on an Object Instance or Resource. IOWA_DM_CANCEL : LwM2M Cancel operation is used to end an Observation. IOWA_DM_DATA_PUSH : LwM2M Data push operation is used when LwM2M Server receives the value of an Object, Object Instances, and Resources without requested it. IOWA_DM_READ_REQUEST : On the Client side, inform a custom Object that a LwM2M Server will perform a READ operation. See iowa_lwm2m_resource_desc_t .","title":"iowa_dm_operation_t"},{"location":"CommonAPI/#notes","text":"This enumeration is used on both Server and Client side. But not all the values are used depending of the side. Server callbacks can be called with: IOWA_DM_READ IOWA_DM_WRITE IOWA_DM_EXECUTE IOWA_DM_CREATE IOWA_DM_DELETE IOWA_DM_DISCOVER IOWA_DM_WRITE_ATTRIBUTES IOWA_DM_NOTIFY IOWA_DM_DATA_PUSH Client callbacks can be called with: IOWA_DM_READ IOWA_DM_FREE IOWA_DM_WRITE IOWA_DM_EXECUTE IOWA_DM_CREATE IOWA_DM_DELETE IOWA_DM_DATA_PUSH","title":"Notes"},{"location":"CommonAPI/#iowa_bootstrap_operation_t","text":"typedef uint8_t iowa_bootstrap_operation_t ; #define IOWA_BOOTSTRAP_UNDEFINED 0 #define IOWA_BOOTSTRAP_READ 101 #define IOWA_BOOTSTRAP_WRITE 102 #define IOWA_BOOTSTRAP_DELETE 103 #define IOWA_BOOTSTRAP_DISCOVER 104 #define IOWA_BOOTSTRAP_FINISH 105 #define IOWA_BOOTSTRAP_ADD_SERVER 106 #define IOWA_BOOTSTRAP_REMOVE_SERVER 107 #define IOWA_BOOTSTRAP_ADD_BOOTSTRAP_SERVER 108 #define IOWA_BOOTSTRAP_REMOVE_BOOTSTRAP_SERVER 109 This is an enumeration of the following values: IOWA_BOOTSTRAP_UNDEFINED : No specific LwM2M operation, this should never be used and only serves as a non default operation. IOWA_BOOTSTRAP_READ : LwM2M Read operation is used to access the value of an Object, Object Instances, and Resources. IOWA_BOOTSTRAP_WRITE : LwM2M Write operation is used to change the value of an Object, and Object Instances regardless of an existence of the targeted Object Instance(s). IOWA_BOOTSTRAP_DELETE : LwM2M Delete operation is used to delete any Object Instance or all Instances of any Object including the Security Object (ID:0). IOWA_BOOTSTRAP_DISCOVER : LwM2M Bootstrap Discover operation is used to discover which LwM2M Objects and Object Instances are supported on a LwM2M Client. In particular, the list of Security Object Instances (ID:0) is reported. IOWA_BOOTSTRAP_FINISH : LwM2M Finish operation is used to terminate the Bootstrap Sequence. IOWA_BOOTSTRAP_ADD_SERVER : Custom LwM2M Bootstrap Add Server operation is used to write the proper Object Instances of Security Object (ID:0) and Server Object (ID:1) to add a LwM2M Server Account. IOWA_BOOTSTRAP_REMOVE_SERVER : Custom LwM2M Bootstrap Remove Server operation is used to delete the proper Object Instances of Security Object (ID:0) and Server Object (ID:1) associated to a LwM2M Server Account. IOWA_BOOTSTRAP_ADD_BOOTSTRAP_SERVER : Custom LwM2M Bootstrap Add Bootstrap Server operation is used to write the proper Object Instance of Security Object (ID:0) add a LwM2M Bootstrap Server Account. IOWA_BOOTSTRAP_REMOVE_BOOTSTRAP_SERVER : Custom LwM2M Bootstrap Remove Bootstrap Server operation is used to delete the proper Object Instance of Security Object (ID:0) associated to a LwM2M Bootstrap Server Account.","title":"iowa_bootstrap_operation_t"},{"location":"CommonAPI/#iowa_lwm2m_data_type_t","text":"typedef uint8_t iowa_lwm2m_data_type_t ; #define IOWA_LWM2M_TYPE_UNDEFINED 0 #define IOWA_LWM2M_TYPE_STRING 1 #define IOWA_LWM2M_TYPE_OPAQUE 2 #define IOWA_LWM2M_TYPE_INTEGER 3 #define IOWA_LWM2M_TYPE_FLOAT 4 #define IOWA_LWM2M_TYPE_BOOLEAN 5 #define IOWA_LWM2M_TYPE_CORE_LINK 6 #define IOWA_LWM2M_TYPE_OBJECT_LINK 7 #define IOWA_LWM2M_TYPE_TIME 8 #define IOWA_LWM2M_TYPE_UNSIGNED_INTEGER 9 This is an enumeration of the following values: IOWA_LWM2M_TYPE_UNDEFINED : No specific data type: it is only used for Executable Resource. IOWA_LWM2M_TYPE_STRING : A UTF-8 string. IOWA_LWM2M_TYPE_OPAQUE : A sequence of binary octets. IOWA_LWM2M_TYPE_INTEGER : An 64-bit signed integer. IOWA_LWM2M_TYPE_FLOAT : A 32 or 64-bit floating point value. IOWA_LWM2M_TYPE_BOOLEAN : An unsigned integer with the value 0 for false and the value 1 for true. IOWA_LWM2M_TYPE_CORE_LINK : A UTF-8 string representing the relation between resources and links. IOWA_LWM2M_TYPE_OBJECT_LINK : Reference to an Instance of a given Object. IOWA_LWM2M_TYPE_TIME : A signed integer representing the number of seconds. IOWA_LWM2M_TYPE_UNSIGNED_INTEGER : An unsigned integer.","title":"iowa_lwm2m_data_type_t"},{"location":"CommonAPI/#iowa_lwm2m_data_t","text":"When the LwM2M Server and the LwM2M Client exchange data, at the application level, they are presented in iowa_lwm2m_data_t structures. typedef struct { uint16_t objectID ; uint16_t instanceID ; uint16_t resourceID ; uint16_t resInstanceID ; iowa_lwm2m_data_type_t type ; union { bool asBoolean ; int64_t asInteger ; double asFloat ; struct { size_t length ; uint8_t * buffer ; } asBuffer ; iowa_lwm2m_object_link_t asObjLink ; } value ; int32_t timestamp ; } iowa_lwm2m_data_t ; This structure contains the value of a LwM2M resource along its complete URI. objectID : ID of the Object containing the resource. instanceID : ID of the Object Instance containing the resource. resourceID : ID of the resource. resInstanceID : ID of the resource instance. For single instance resource, this is always IOWA_LWM2M_ID_ALL . type : The datatype of the resource. value.asBoolean : The value of the resource when type is IOWA_LWM2M_TYPE_BOOLEAN . value.asInteger : The value of the resource when type is IOWA_LWM2M_TYPE_INTEGER , IOWA_LWM2M_TYPE_TIME or IOWA_LWM2M_TYPE_UNSIGNED_INTEGER . value.asFloat : The value of the resource when type is IOWA_LWM2M_TYPE_FLOAT . value.asBuffer : The value of the resource when type is IOWA_LWM2M_TYPE_CORE_LINK , IOWA_LWM2M_TYPE_STRING , IOWA_LWM2M_TYPE_OPAQUE or IOWA_LWM2M_TYPE_UNDEFINED . value.asObjLink : The value of the resource when type is IOWA_LWM2M_TYPE_OBJECT_LINK . timestamp : The timestamp value in seconds. Time is always absolute, and timestamp is present when the value is greater than zero. This can not be negative.","title":"iowa_lwm2m_data_t"},{"location":"CommonAPI/#iowa_lwm2m_object_link_t","text":"typedef struct { uint16_t objectId ; uint16_t instanceId ; } iowa_lwm2m_object_link_t ;","title":"iowa_lwm2m_object_link_t"},{"location":"CommonAPI/#iowa_content_format_t","text":"typedef uint16_t iowa_content_format_t ; #define IOWA_CONTENT_FORMAT_TEXT 0 #define IOWA_CONTENT_FORMAT_OPAQUE 42 #define IOWA_CONTENT_FORMAT_CBOR 60 #define IOWA_CONTENT_FORMAT_SENML_JSON 110 #define IOWA_CONTENT_FORMAT_SENML_CBOR 112 #define IOWA_CONTENT_FORMAT_TLV_OLD 1542 #define IOWA_CONTENT_FORMAT_JSON_OLD 1543 #define IOWA_CONTENT_FORMAT_TLV 11542 #define IOWA_CONTENT_FORMAT_JSON 11543 #define IOWA_CONTENT_FORMAT_UNSET 0xFFFF This is an enumeration of the following values: IOWA_CONTENT_FORMAT_TEXT : Plain text encoding (e.g. \"123\", \"-123.45\"). Usable only for single resource encoding. IOWA_CONTENT_FORMAT_OPAQUE : A sequence of binary octets. Usable only for single resource encoding which data type is Opaque . IOWA_CONTENT_FORMAT_CBOR : CBOR encoding. Usable only for single resource encoding. IOWA_CONTENT_FORMAT_SENML_JSON : LwM2M specific SenML JSON encoding. This may not be supported by all Clients. See iowa_client_t . IOWA_CONTENT_FORMAT_SENML_CBOR : LwM2M specific SenML CBOR encoding. This may not be supported by all Clients. See iowa_client_t . IOWA_CONTENT_FORMAT_TLV_OLD : LwM2M specific binary Type-Length-Value format. Usually the most compact one. This one is not anymore used, it only serves as backward compatibility with old LwM2M stack implementation (previous 1.0). IOWA_CONTENT_FORMAT_JSON_OLD : LwM2M specific JSON encoding. This may not be supported by all Clients. See iowa_client_t . This one is not anymore used, it only serves as backward compatibility with old LwM2M stack implementation (previous 1.0). IOWA_CONTENT_FORMAT_TLV : LwM2M specific binary Type-Length-Value format. Usually the most compact one. IOWA_CONTENT_FORMAT_JSON : LwM2M specific JSON encoding. This may not be supported by all Clients. See iowa_client_t . IOWA_CONTENT_FORMAT_UNSET : Used to reset the encoding to the default one.","title":"iowa_content_format_t"},{"location":"CommonAPI/#iowa_lwm2m_uri_t","text":"typedef struct { uint16_t objectId ; uint16_t instanceId ; uint16_t resourceId ; uint16_t resInstanceId ; } iowa_lwm2m_uri_t ; This structure represents a LwM2M URI. In the LwM2M resource model, resources are grouped into Objects. These Objects have instances. Hence the URI of a resource is in the form /{Object}/{Object Instance}/{Resource} . Moreover some resources, described are multiple , can have several instances, leading to URI in the form /{Object}/{Object Instance}/{Resource}/{Resource Instance} . objectId : ID of a LwM2M Object. instanceId : ID of the Object Instance. resourceId : ID of the resource. resInstanceId : ID of the resource instance. When a segment of the URI is not set, the value of the corresponding field is set to IOWA_LWM2M_ID_ALL . For instance, the URI /3/0/9 is represented as: iowa_lwm2m_uri_t :: objectId = 3 iowa_lwm2m_uri_t :: instanceId = 0 iowa_lwm2m_uri_t :: resourceId = 9 iowa_lwm2m_uri_t :: resInstanceId = IOWA_LWM2M_ID_ALL the URI /5 is represented as: iowa_lwm2m_uri_t :: objectId = 5 iowa_lwm2m_uri_t :: instanceId = IOWA_LWM2M_ID_ALL iowa_lwm2m_uri_t :: resourceId = IOWA_LWM2M_ID_ALL iowa_lwm2m_uri_t :: resInstanceId = IOWA_LWM2M_ID_ALL \\clearpage","title":"iowa_lwm2m_uri_t"},{"location":"CommonAPI/#iowa_response_content_t","text":"This structure contains the response content from iowa_response_callback_t() according to its requested operation . typedef struct { union { struct { size_t dataCount ; iowa_lwm2m_data_t * dataP ; } read ; struct { uint32_t notificationNumber ; size_t dataCount ; iowa_lwm2m_data_t * dataP ; } observe ; struct { size_t dataCount ; iowa_lwm2m_data_t * dataP ; } dataPush ; } details ; } iowa_response_content_t ; details.read : The information related to IOWA_DM_READ operation. details.read.dataCount : The number of elements in the details.read.dataP . This may be 0. details.read.dataP : An array containing the Resource values returned by the Client. This may be nil. details.observe : The information related to IOWA_DM_NOTIFY operation. details.observe.notificationNumber : The notification counter. details.observe.dataCount : The number of elements in the details.observe.dataP . This may be 0. details.observe.dataP : An array containing the Resource values returned by the Client. This may be nil. details.dataPush : The information related to IOWA_DM_DATA_PUSH operation. details.dataPush.dataCount : The number of elements in the details.dataPush.dataP . This may be 0. details.dataPush.dataP : An array containing the Resource values send by the Client. This may be nil. \\clearpage","title":"iowa_response_content_t"},{"location":"CommonAPI/#callbacks","text":"","title":"Callbacks"},{"location":"CommonAPI/#iowa_response_callback_t","text":"The device management APIs ( iowa_server_read() , iowa_server_observe() , iowa_server_write() , iowa_server_write_attributes_string() , iowa_server_configure_data_push() , iowa_bootstrap_server_read() , iowa_client_send_sensor_data() , iowa_client_send_data() ) are using an iowa_response_callback_t to asynchronously return the result of the operation. typedef void ( * iowa_response_callback_t ) ( uint32_t sourceId , uint8_t operation , iowa_status_t status , iowa_response_content_t * contentP , void * userDataP , iowa_context_t contextP ); sourceId : The ID of the client targeted by the command for the server APIs ( iowa_server_read() , iowa_server_observe() , iowa_server_write() , iowa_server_write_attributes_string() , iowa_server_configure_data_push() ). : The ID of the server targeted by the command for the client APIs ( iowa_client_send_sensor_data() , iowa_client_send_data() ). operation : The type of command matching this result. status : The status of the command. contentP : The content of the operation. It is nil for IOWA_DM_WRITE , IOWA_DM_EXECUTE , IOWA_DM_CREATE , IOWA_DM_DELETE and IOWA_DM_WRITE_ATTRIBUTES operations. : It is also nil for IOWA_DM_DATA_PUSH if operation comes from the client APIs. : It is also nil for IOWA_DM_READ , IOWA_DM_NOTIFY , IOWA_DM_DISCOVER and IOWA_DM_DATA_PUSH if the the status is different from IOWA_205_COAP_CONTENT userDataP : A pointer to application specific data. This is a parameter of the matching device management API. contextP : The IOWA context on which the device management API was called. Notes The status can have the following values: status Description IOWA_COAP_201_CREATED IOWA_DM_CREATE operation completed successfully IOWA_COAP_202_DELETED IOWA_DM_DELETE operation completed successfully IOWA_COAP_204_CHANGED IOWA_DM_WRITE , IOWA_DM_EXECUTE , or IOWA_DM_WRITE_ATTRIBUTES operation completed successfully IOWA_COAP_205_CONTENT IOWA_DM_READ , IOWA_DM_NOTIFY , IOWA_DM_DISCOVER , or IOWA_DM_DATA_PUSH operation completed successfully IOWA_COAP_400_BAD_REQUEST Undetermined error occurred, when the request is ill-formed IOWA_COAP_401_UNAUTHORIZED Access Right Permission Denied IOWA_COAP_404_NOT_FOUND URI of the operation is not found IOWA_COAP_405_METHOD_NOT_ALLOWED Target is not allowed for the operation IOWA_COAP_406_NOT_ACCEPTABLE None of the preferred Content-Formats can be returned IOWA_COAP_408_REQUEST_ENTITY_INCOMPLETE The request or answer is incomplete IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE The request or answer is too large for the system IOWA_COAP_415_UNSUPPORTED_CONTENT_FORMAT The specified format is not supported IOWA_COAP_500_INTERNAL_SERVER_ERROR An internal server error occurred \\clearpage","title":"iowa_response_callback_t"},{"location":"CommonAPI/#iowa_load_callback_t","text":"This callback is called during a context load with the data stored inside the context backup. typedef void ( * iowa_load_callback_t ) ( uint16_t callbackId , uint8_t * buffer , size_t bufferLength , void * userDataP ); callbackId : The identifier of the callback as passed to iowa_backup_register_callback() . buffer : The data loaded from the backup. This can be nil. bufferLength : The length of buffer in bytes. userDataP : A pointer to application specific data as passed to iowa_backup_register_callback() . \\clearpage","title":"iowa_load_callback_t"},{"location":"CommonAPI/#iowa_save_callback_t","text":"This callback is called during a context save. It is called first to retrieve the length of the data to save, then a second time with an allocated buffer to fill with the data to save. typedef size_t ( * iowa_save_callback_t ) ( uint16_t callbackId , uint8_t * buffer , size_t bufferLength , void * userDataP ); callbackId : The identifier of the callback as passed to iowa_backup_register_callback() . buffer : A buffer to store the data. This can be nil. bufferLength : The length of buffer in bytes. userDataP : A pointer to application specific data as passed to iowa_backup_register_callback() . \\clearpage","title":"iowa_save_callback_t"},{"location":"CommonAPI/#api","text":"","title":"API"},{"location":"CommonAPI/#iowa_init","text":"Prototype iowa_context_t iowa_init ( void * userData ); Description iowa_init() initializes an IOWA context. Arguments userData : Pointer to application-specific data. This is passed as argument to the Communication Abstraction Interface functions. This can be nil. Return Value An iowa_context_t in case of success or NULL in case of memory allocation error. Header File iowa.h \\clearpage","title":"iowa_init"},{"location":"CommonAPI/#iowa_step","text":"Prototype iowa_status_t iowa_step ( iowa_context_t contextP , int32_t timeout ); Description iowa_step() runs the stack engine during the specified time. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. timeout : The allowed time to run in seconds. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : one of the iowa_system_connection...() functions returned an error. : LwM2M Client only: when the Client failed to connect to any Server. ( iowa_event_callback_t is called with a IOWA_EVENT_REG_FAILED event.) Header File iowa.h Notes If timeout is a negative value: iowa_step() will return only in case of error. iowa_system_connection_select() will be called with INT32_MAX . For LwM2M Clients: if iowa_step() returns an IOWA_COAP_503_SERVICE_UNAVAILABLE error because it is not registered to any LwM2M Server, subsequent call to iowa_step() , will retry to register to the known LwM2M Servers. iowa_stop() can be used to make iowa_step() return immediately. \\clearpage","title":"iowa_step"},{"location":"CommonAPI/#iowa_flush_before_pause","text":"Prototype iowa_status_t iowa_flush_before_pause ( iowa_context_t contextP , int32_t duration , uint32_t * delayP ); Description iowa_flush_before_pause() is used to inform the stack that the device will pause. iowa_flush_before_pause() performs all the pending and required operations of the stack engine before returning. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. duration : The duration of the planned pause in seconds. delayP : The delay before the next IOWA scheduled operation. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - duration is negative. : - for a LwM2M Client: duration is longer than one of the LwM2M Server registration lifetime. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : one of the iowa_system_connection...() functions returned an error. Header File iowa.h Notes In LwM2M Client mode: if no server are configured, the function returns immediately with no error. A LwM2M Server should never stop. For a LwM2M Server, iowa_flush_before_pause() will just wait for all pending CoAP transactions to finish. \\clearpage","title":"iowa_flush_before_pause"},{"location":"CommonAPI/#iowa_stop","text":"Prototype void iowa_stop ( iowa_context_t contextP ); Description iowa_stop() stops the stack engine and make iowa_step() return immediately. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value None. Header File iowa.h \\clearpage","title":"iowa_stop"},{"location":"CommonAPI/#iowa_close","text":"Prototype void iowa_close ( iowa_context_t contextP ); Description iowa_close() closes an IOWA context. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value None. Header File iowa.h \\clearpage","title":"iowa_close"},{"location":"CommonAPI/#iowa_clock_reset","text":"Prototype iowa_status_t iowa_clock_reset ( iowa_context_t contextP ); Description iowa_clock_reset() informs IOWA that iowa_system_gettime() has lost track of time and that IOWA must re-synchronize its internal timers. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : - the iowa_system_gettime() function returned an error. Header File iowa.h \\clearpage","title":"iowa_clock_reset"},{"location":"CommonAPI/#iowa_save_context","text":"Prototype iowa_status_t iowa_save_context ( iowa_context_t contextP ); Description iowa_save_context() saves the current IOWA context. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - the iowa_system_store_context() function returned an error. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. If IOWA is built with the IOWA_STORAGE_CONTEXT_AUTOMATIC_BACKUP flag, the context will be automatically saved: After a LwM2M Bootstrap Server or a LwM2M Server were added. After a successful Bootstrap procedure. After a LwM2M Server operation on resources related to Server Accounts. \\clearpage","title":"iowa_save_context"},{"location":"CommonAPI/#iowa_save_context_snapshot","text":"Prototype iowa_status_t iowa_save_context_snapshot ( iowa_context_t contextP ); Description iowa_save_context_snapshot() saves the current IOWA context with runtime information, observations and attributes. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - the iowa_system_store_context() function returned an error. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. \\clearpage","title":"iowa_save_context_snapshot"},{"location":"CommonAPI/#iowa_load_context","text":"Prototype iowa_status_t iowa_load_context ( iowa_context_t contextP ); Description iowa_load_context() loads a saved IOWA context. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - no previous saved IOWA context found. : - In LwM2M client mode: no Security or Server objects found, the function iowa_client_configure must be called first. IOWA_COAP_409_CONFLICT : contextP isn't in init state. IOWA_COAP_422_UNPROCESSABLE_ENTITY : either: : - failed to decode the buffer retrieved from iowa_system_retrieve_context() function. : - context version isn't present or is incorrect. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - the iowa_system_retrieve_context() function returned an error. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. \\clearpage","title":"iowa_load_context"},{"location":"CommonAPI/#iowa_backup_register_callback","text":"Prototype iowa_status_t iowa_backup_register_callback ( iowa_context_t contextP , uint16_t id , iowa_save_callback_t saveCallback , iowa_load_callback_t loadCallback , void * userDataP ); Description iowa_backup_register_callback() registers context callbacks from IOWA. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The id of the callback. Must be greater than 0xF000. saveCallback : The function called during context saving. loadCallback : The function called during context loading. userDataP : Pointer to application-specific data. This is passed as argument to the callback. This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : either: : - id is incorrect. : - one of the callback is NULL. IOWA_COAP_409_CONFLICT : id is already used. IOWA_COAP_422_UNPROCESSABLE_ENTITY : failed to decode the buffer retrieved from iowa_system_retrieve_context() function. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. \\clearpage","title":"iowa_backup_register_callback"},{"location":"CommonAPI/#iowa_backup_deregister_callback","text":"Prototype void iowa_backup_deregister_callback ( iowa_context_t contextP , uint16_t id ); Description iowa_backup_deregister_callback() deregisters context callbacks from IOWA. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. id : The id of the callback. Must be greater than 0xF000. Return Value None. Header File iowa.h Notes Currently, this API is only for a LwM2M Client. \\clearpage","title":"iowa_backup_deregister_callback"},{"location":"CommonAPI/#iowa_connection_closed","text":"Prototype void iowa_connection_closed ( iowa_context_t contextP , void * connP ); Description iowa_connection_closed() informs IOWA that a connection was closed by an external event (e.g. peer disconnection). Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. connP : The closed connection of the same user-defined type as the one returned by iowa_system_connection_open() . Return Value None. Header File iowa.h \\clearpage","title":"iowa_connection_closed"},{"location":"CommonAPI/#iowa_data_get_block_info","text":"Prototype iowa_status_t iowa_data_get_block_info ( iowa_lwm2m_data_t * dataP , uint32_t * numberP , bool * moreP , uint16_t * sizeP ); Description iowa_data_get_block_info() retrieves the block information from an iowa_lwm2m_data_t . Arguments dataP : the iowa_lwm2m_data_t to retrieve the block information from. numberP : OUT. The block number. moreP : OUT. true if there are more blocks coming, false otherwise. sizeP : OUT. The size of the block in bytes. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : dataP does not contain any block information. IOWA_COAP_400_BAD_REQUEST : either: : - one of the parameters is nil. : - the block information in dataP is invalid. Header File iowa.h \\clearpage","title":"iowa_data_get_block_info"},{"location":"CommonAPI/#iowa_data_set_block_info","text":"Prototype iowa_status_t iowa_data_set_block_info ( iowa_lwm2m_data_t * dataP , uint32_t number , bool more , uint16_t size ); Description iowa_data_set_block_info() sets the block information of an iowa_lwm2m_data_t . Arguments dataP : the iowa_lwm2m_data_t to set the block information to. number : The block number. more : true if there are more blocks coming, false otherwise. size : The size of the block in bytes. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : dataP is nil. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - number is greater than 262 143. : - more is set to true and size is different than 16, 32, 64, 128, 256, 512, or 1024. : - more is set to false and size is either zero or greater than 1024. : - dataP data type is neither IOWA_LWM2M_TYPE_STRING , IOWA_LWM2M_TYPE_OPAQUE , nor IOWA_LWM2M_TYPE_CORE_LINK . Header File iowa.h","title":"iowa_data_set_block_info"},{"location":"Components/","text":"IOWA Components \u00b6 This section describes how you can replace some parts of IOWA by your own. Unlike the APIs, the internals functions described in this section may change between IOWA releases. Overview \u00b6 Internally, IOWA is organized in several components as shown in the figure below. Objects : Found in src/objects . This is an aggregate of the implementations of the LwM2M Objects supported by IOWA. LwM2M : Found in src/lwm2m . The LightweightM2M engine of IOWA. Data : Found in src/data . This component handles the serialization and deserialization of the various data formats used by IOWA. CoAP : Found in src/coap . The Constrained Application Protocol stack of IOWA. Security : Found in src/security . In charge of the security sessions management and a wrapper to the [Security layers][Security layers]. Communication : Found in src/comm . A wrapper to the iowa_system_connection_...() functions to aggregate all the connections opened by the other components. Logger : Found in src/logger . Formats then outputs the IOWA logs through iowa_system_trace() .","title":"IOWA Components"},{"location":"Components/#iowa-components","text":"This section describes how you can replace some parts of IOWA by your own. Unlike the APIs, the internals functions described in this section may change between IOWA releases.","title":"IOWA Components"},{"location":"Components/#overview","text":"Internally, IOWA is organized in several components as shown in the figure below. Objects : Found in src/objects . This is an aggregate of the implementations of the LwM2M Objects supported by IOWA. LwM2M : Found in src/lwm2m . The LightweightM2M engine of IOWA. Data : Found in src/data . This component handles the serialization and deserialization of the various data formats used by IOWA. CoAP : Found in src/coap . The Constrained Application Protocol stack of IOWA. Security : Found in src/security . In charge of the security sessions management and a wrapper to the [Security layers][Security layers]. Communication : Found in src/comm . A wrapper to the iowa_system_connection_...() functions to aggregate all the connections opened by the other components. Logger : Found in src/logger . Formats then outputs the IOWA logs through iowa_system_trace() .","title":"Overview"},{"location":"CustomObject/","text":"Custom Object \u00b6 IOWA abstracts lot of objects for the LwM2M Client through dedicated API. But additional object can be provided to the stack by using the following functions: iowa_client_add_custom_object iowa_client_remove_custom_object iowa_client_object_resource_changed iowa_client_object_instance_changed Below some examples described how to use these APIs to implement your objects. Controlling a Power Switch \u00b6 Let\u2019s consider that the device containing the IOWA Client is connected to a power switch. You want to be able to monitor and control this power switch from a LwM2M Server. The first step is to determine the best layout of the LwM2M Object describing the power switch. Fortunately, the IPSO Alliance defined the Power Control Object (ID: 3312) which suits our needs. By re-using a standardized Object, we do not need to provide the LwM2M Servers with the layout of our Object. A server already knows the Object 3312 which contains the following resources: Resource Name Resource ID Access Type Mandatory Type Description On/Off 5850 R, W Mandatory Boolean On/off control, 0=OFF, 1=ON. Dimmer 5851 R, W Optional Integer Proportional control, integer value between 0 and 100 as a percentage. On Time 5852 R, W Optional Integer The time in seconds that the power relay has been on. Writing a value of 0 resets the counter. Cumulative active power 5805 R Optional Float The cumulative active power since the last cumulative energy reset or device start. Power factor 5820 R Optional Float The power factor of the load. Application Type 5750 R, W Optional String The application type of the sensor or actuator as a string, for instance, \"Air Pressure\". The On/Off resource is mandatory to implement and is used to both control and monitor our power switch. The Dimmer resource is not relevant to our use case. As it is optional, we do not implement it. The On Time is optional but interesting for this example unlike the Cumulative active power, Power factor and Application Type resources. To implement this Object in our device, in our main(), after initializing the IOWA context (see above), we declare an array describing the two resources: iowa_lwm2m_resource_desc_t resources [ 2 ] = { { 5850 , IOWA_LWM2M_TYPE_BOOLEAN , IOWA_DM_READ | IOWA_DM_WRITE , IOWA_RESOURCE_FLAG_MANDATORY }, { 5852 , IOWA_LWM2M_TYPE_INTEGER , IOWA_DM_READ | IOWA_DM_WRITE , IOWA_RESOURCE_FLAG_OPTIONAL } }; Note that the header file \"iowa_IPSO_ID.h\" in the \"include\" folder contains defines for the ID, type and operations of the Reusable Resources defined by the IPSO Alliance. Using these macros, we can write the equivalent code as: iowa_lwm2m_resource_desc_t resources [ 2 ] = { { IPSO_RSC_ID_ON_OFF , IPSO_RSC_TYPE_ON_OFF , IPSO_RSC_OP_ON_OFF , IOWA_RESOURCE_FLAG_MANDATORY }, { IPSO_RSC_ID_ON_TIME , IPSO_RSC_TYPE_ON_TIME , IPSO_RSC_OP_ON_TIME , IOWA_RESOURCE_FLAG_OPTIONAL } }; Instance-wise, we only have one power switch to control and it makes no sense that the LwM2M Server could create new instances or delete some and the object does not used resources that can be multiple. The instanceCallback and the resInstanceCallback can be omitted and we declare a single instance with ID 0: uint16_t singleInstanceID [ 1 ] = { 0 }; result = iowa_client_add_custom_object ( contextP , 3312 , 1 , singleInstanceID , 2 , resources , powerSwitchCallback , NULL , NULL , NULL ); Now the Power Control Object is presented to the LwM2M Servers by the IOWA stack. When a Server performs a command on one of its resources (or the whole Object), the powerSwitchCallback function is called. Let\u2019s assume our device provides two functions switch_on() and switch_off() to control the power switch and three interruptions to handle: SWITCH_ON when the power switch is set to On, SWITCH_OFF when the power switch is set to Off TIMER when a second had elapsed. We first define two global variables to store the power switch state: bool switchState ; unsigned int onTime ; In the interrupt handler, we modify these variables to be in sync with the actual power switch state (pseudo-code): switch ( interrupt ) { (...) case SWITCH_ON : switchState = true ; break ; case SWITCH_OFF : switchState = false ; break ; case TIMER : if ( switchState == true ) { onTime ++ ; } break ; (...) } Now the powerSwitchCallback function can be implemented: iowa_status_t powerSwitchCallback ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t iowaH ) { size_t i ; switch ( operation ) { case IOWA_DM_READ : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 5850 : dataP [ i ]. value . asBoolean = switchState ; break ; case 5852 : dataP [ i ]. value . asInteger = onTime ; break ; default : // Already handled by IOWA stack break ; } } break ; case IOWA_DM_WRITE : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 5850 : if ( dataP [ i ]. value . asBoolean == true ) { switch_on (); } else { switch_off (); } break ; case 5852 : if ( dataP [ i ]. value . asInteger == 0 ) { onTime = 0 ; } else { return IOWA_COAP_406_NOT_ACCEPTABLE ; } break ; default : // Already handled by IOWA stack break ; } } break ; default : // Already handled by IOWA stack break ; } return IOWA_COAP_NO_ERROR ; } Here we assume that the switch_on() and switch_off() functions will trigger an interrupt and the switchState variable is updated by the interrupt handler. A LwM2M Server can write only 0 as the new value of the On Time resource hence the check. If you test this code, you will notice that you can control the power switch remotely and check its state. However the LwM2M Server will not receive notifications when observing the Object resources. To correct this, we need to inform the IOWA stack of the changes not triggered by a LwM2M Server. This is done by calling the API iowa_client_object_resource_changed() whenever a change occurs. A correct interrupt handler is then: switch ( interrupt ) { (...) case SWITCH_ON : if ( switchState == false ) { iowa_client_object_resource_changed ( contextP , 3312 , 0 , 5850 ); } switchState = true ; break ; case SWITCH_OFF : if ( switchState == true ) { iowa_client_object_resource_changed ( contextP , 3312 , 0 , 5850 ); } switchState = false ; break ; case TIMER : if ( switchState == true ) { onTime ++ ; iowa_client_notification_lock ( contextP , true ); iowa_client_object_resource_changed ( contextP , 3312 , 0 , 5852 ); iowa_client_notification_lock ( contextP , false ); } break ; (...) } Note that the calls to iowa_client_notification_lock() are not necessary but are here as an example. /clearpage Monitoring the temperature during a period \u00b6 Let\u2019s consider that the device containing the IOWA Client is connected to a temperature sensor. You want to be able to monitor this sensor from a LwM2M Server. Monitored value will be reported with the time at which the value was taken. The following example can be implemented with iowa_client_IPSO_add_sensor and iowa_client_IPSO_update_values . But we will instead implement our own Custom Object to understand how monitored values with timestamp can be sent to a LwM2M Server. The first step is to determine the best layout of the LwM2M Object describing the temperature sensor. Fortunately, the IPSO Alliance defined the Temperature Object (ID: 3303) which suits our needs. By re-using a standardized Object, we do not need to provide the LwM2M Servers with the layout of our Object. A server already knows the Object 3303 which contains the following resources: Resource Name Resource ID Access Type Mandatory Type Description Sensor Value 5700 R Mandatory Float Last or Current Measured Value from the Sensor. Min Measured Value 5601 R Optional Float The minimum value measured by the sensor since power ON or reset. Max Measured Value 5602 R Optional Float The maximum value measured by the sensor since power ON or reset. Min Range Value 5603 R Optional Float The minimum value that can be measured by the sensor. Max Range Value 5604 R Optional Float The maximum value that can be measured by the sensor. Sensor Units 5701 R Optional String Measurement Units Definition e.g. \"Cel\" for Temperature in Celsius. Reset Min and Max Measured Values 5605 E Optional Reset the Min and Max Measured Values to Current Value. The Sensor Value resource is mandatory to implement and is used to monitor the temperature value. All the others resources are not relevant to our use case. As they are optional, we do not implement them. To implement this Object in our device, in our main(), after initializing the IOWA context (see above), we declare an array describing resource: iowa_lwm2m_resource_desc_t resources [ 1 ] = { { 5700 , IOWA_LWM2M_TYPE_FLOAT , IOWA_DM_READ , IOWA_RESOURCE_FLAG_MANDATORY } }; Note that the header file \"iowa_IPSO_ID.h\" in the \"include\" folder contains defines for the ID, type and operations of the Reusable Resources defined by the IPSO Alliance. Using these macros, we can write the equivalent code as: iowa_lwm2m_resource_desc_t resources [ 1 ] = { { IPSO_RSC_ID_SENSOR_VALUE , IPSO_RSC_TYPE_SENSOR_VALUE , IPSO_RSC_OP_SENSOR_VALUE , IOWA_RESOURCE_FLAG_MANDATORY } }; Instance-wise, we only have one temperature sensor to monitor and it makes no sense that the LwM2M Server could create new instances or delete some and the object does not used resources that can be multiple. The instanceCallback and the resInstanceCallback can be omitted and we declare a single instance with ID 0: uint16_t singleInstanceID [ 1 ] = { 0 }; result = iowa_client_add_custom_object ( contextP , 3303 , 1 , singleInstanceID , 1 , resources , tempSensorCallback , NULL , NULL , NULL ); Now the Temperature Object is presented to the LwM2M Servers by the IOWA stack. When a Server performs a command on one of its resources (or the whole Object), the tempSensorCallback function is called. We want to inform to the LwM2M Server the last values taken with the timestamp associated to each value. Let\u2019s assume our device provides two functions get_time() and get_temperature() to monitor the temperature value and one interruption to handle: NEW_TEMP when a new temperature value is available. We first define a new structure and two global variables to store the temperature values. The temperature values will be stored inside a circular buffer: #define NB_VALUE 10 typedef struct { int32_t timestamp ; float value ; } temp_value_t ; temp_value_t valuesList [ NB_VALUE ] = { 0 }; size_t currentIndex = 0 ; In the interrupt handler, we modify these variables to store the temperature values (pseudo-code): switch ( interrupt ) { (...) case NEW_TEMP : { valuesList [ currentIndex ]. timestamp = get_time (); valuesList [ currentIndex ]. value = get_temperature (); currentIndex ++ ; if ( currentIndex == NB_VALUE ) { currentIndex = 0 ; } break ; } (...) } Now the tempSensorCallback function can be implemented: iowa_status_t tempSensorCallback ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t iowaH ) { iowa_status_t result ; size_t i ; result = IOWA_COAP_NO_ERROR ; switch ( operation ) { case IOWA_DM_READ : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 5700 : { // On a Read operation, provides all the timestamp values size_t j ; if ( valuesList [ 0 ]. timestamp == 0 ) { // No value added yet break ; } if ( dataP [ i ]. timestamp != 0 ) { // Loop on next element break ; } // Find the latest timestamp not currently added j = currentIndex - 1 ; if ( i > 0 ) { while ( j != currentIndex ) { if ( j > 0 ) { if ( valuesList [ j -1 ]. timestamp == 0 ) { break ; } } else if ( valuesList [ NB_VALUE -1 ]. timestamp == 0 ) { break ; } if ( valuesList [ j ]. timestamp < dataP [ i -1 ]. timestamp ) { break ; } if ( j == 0 ) { j = NB_VALUE - 1 ; } else { j -- ; } } } dataP [ i ]. value . asFloat = valuesList [ j ]. value ; dataP [ i ]. timestamp = valuesList [ j ]. timestamp ; if ( j > 0 ) { if ( valuesList [ j -1 ]. timestamp != 0 ) { // Changed result to be called again in the callback result = IOWA_COAP_231_CONTINUE ; } } else if ( valuesList [ NB_VALUE -1 ]. timestamp != 0 ) { // Changed result to be called again in the callback result = IOWA_COAP_231_CONTINUE ; } break ; } default : // Already handled by IOWA stack break ; } } break ; default : // Already handled by IOWA stack break ; } return result ; } Pay attention that the timestamp must be absolute and not relative to the current time, means negative values are not accepted. If the timestamp is zero, it's ignored. If you test this code, you will notice that you can retrieve the current temperature value. However the LwM2M Server will not receive notifications when observing the Object resources. To correct this, we need to inform the IOWA stack of the changes not triggered by a LwM2M Server. This is done by calling the API iowa_client_object_resource_changed() whenever a change occurs. A correct interrupt handler is then: switch ( interrupt ) { (...) case NEW_TEMP : { valuesList [ currentIndex ]. timestamp = get_time (); valuesList [ currentIndex ]. value = get_temperature (); currentIndex ++ ; if ( currentIndex == NB_VALUE ) { currentIndex = 0 ; } iowa_client_object_resource_changed ( contextP , 3303 , 0 , 5700 ); break ; } (...) } The diagram of the above example can be: The Server sends first an Observation on /3303/0/5700. At this time the LwM2M Client has only one value to send back, and so the return value of the callback is 0.00 (No Error). Then the LwM2M Client retrieves the temperature values and call iowa_client_object_resource_changed for each new value. The Object callback has the possibility to return multiple values by returning the 2.31 (Continue) code. On first round, the application has to provide the first value, the callback is called with: numData : 1 dataP[0] : dataP[0].objectID : 3303, dataP[0].instanceID : 0, dataP[0].resourceID : 5700, dataP[0].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[0].type : IOWA_LWM2M_TYPE_FLOAT, dataP[0].value.asFloat : 0.0 dataP[0].timestamp : 0 On second round, the application has to provide the second value, the callback is called with: numData : 2 dataP[0] : dataP[0].objectID : 3303, dataP[0].instanceID : 0, dataP[0].resourceID : 5700, dataP[0].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[0].type : IOWA_LWM2M_TYPE_FLOAT, dataP[0].value.asFloat : FIRST_VALUE dataP[0].timestamp : FIRST_TIMESTAMP dataP[1] : dataP[1].objectID : 3303, dataP[1].instanceID : 0, dataP[1].resourceID : 5700, dataP[1].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[1].type : IOWA_LWM2M_TYPE_FLOAT, dataP[1].value.asFloat : 0.0 dataP[1].timestamp : 0 On third round, the application has to provide the third value, the callback is called with: numData : 3 dataP[0] : dataP[0].objectID : 3303, dataP[0].instanceID : 0, dataP[0].resourceID : 5700, dataP[0].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[0].type : IOWA_LWM2M_TYPE_FLOAT, dataP[0].value.asFloat : FIRST_VALUE dataP[0].timestamp : FIRST_TIMESTAMP dataP[1] : dataP[1].objectID : 3303, dataP[1].instanceID : 0, dataP[1].resourceID : 5700, dataP[1].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[1].type : IOWA_LWM2M_TYPE_FLOAT, dataP[1].value.asFloat : SECOND_VALUE dataP[1].timestamp : SECOND_TIMESTAMP dataP[2] : dataP[2].objectID : 3303, dataP[2].instanceID : 0, dataP[2].resourceID : 5700, dataP[2].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[2].type : IOWA_LWM2M_TYPE_FLOAT, dataP[2].value.asFloat : 0.0 dataP[2].timestamp : 0 And so on, until the last value is provided and the return value of the callback is 0.00 (No Error).","title":"Custom Object"},{"location":"CustomObject/#custom-object","text":"IOWA abstracts lot of objects for the LwM2M Client through dedicated API. But additional object can be provided to the stack by using the following functions: iowa_client_add_custom_object iowa_client_remove_custom_object iowa_client_object_resource_changed iowa_client_object_instance_changed Below some examples described how to use these APIs to implement your objects.","title":"Custom Object"},{"location":"CustomObject/#controlling-a-power-switch","text":"Let\u2019s consider that the device containing the IOWA Client is connected to a power switch. You want to be able to monitor and control this power switch from a LwM2M Server. The first step is to determine the best layout of the LwM2M Object describing the power switch. Fortunately, the IPSO Alliance defined the Power Control Object (ID: 3312) which suits our needs. By re-using a standardized Object, we do not need to provide the LwM2M Servers with the layout of our Object. A server already knows the Object 3312 which contains the following resources: Resource Name Resource ID Access Type Mandatory Type Description On/Off 5850 R, W Mandatory Boolean On/off control, 0=OFF, 1=ON. Dimmer 5851 R, W Optional Integer Proportional control, integer value between 0 and 100 as a percentage. On Time 5852 R, W Optional Integer The time in seconds that the power relay has been on. Writing a value of 0 resets the counter. Cumulative active power 5805 R Optional Float The cumulative active power since the last cumulative energy reset or device start. Power factor 5820 R Optional Float The power factor of the load. Application Type 5750 R, W Optional String The application type of the sensor or actuator as a string, for instance, \"Air Pressure\". The On/Off resource is mandatory to implement and is used to both control and monitor our power switch. The Dimmer resource is not relevant to our use case. As it is optional, we do not implement it. The On Time is optional but interesting for this example unlike the Cumulative active power, Power factor and Application Type resources. To implement this Object in our device, in our main(), after initializing the IOWA context (see above), we declare an array describing the two resources: iowa_lwm2m_resource_desc_t resources [ 2 ] = { { 5850 , IOWA_LWM2M_TYPE_BOOLEAN , IOWA_DM_READ | IOWA_DM_WRITE , IOWA_RESOURCE_FLAG_MANDATORY }, { 5852 , IOWA_LWM2M_TYPE_INTEGER , IOWA_DM_READ | IOWA_DM_WRITE , IOWA_RESOURCE_FLAG_OPTIONAL } }; Note that the header file \"iowa_IPSO_ID.h\" in the \"include\" folder contains defines for the ID, type and operations of the Reusable Resources defined by the IPSO Alliance. Using these macros, we can write the equivalent code as: iowa_lwm2m_resource_desc_t resources [ 2 ] = { { IPSO_RSC_ID_ON_OFF , IPSO_RSC_TYPE_ON_OFF , IPSO_RSC_OP_ON_OFF , IOWA_RESOURCE_FLAG_MANDATORY }, { IPSO_RSC_ID_ON_TIME , IPSO_RSC_TYPE_ON_TIME , IPSO_RSC_OP_ON_TIME , IOWA_RESOURCE_FLAG_OPTIONAL } }; Instance-wise, we only have one power switch to control and it makes no sense that the LwM2M Server could create new instances or delete some and the object does not used resources that can be multiple. The instanceCallback and the resInstanceCallback can be omitted and we declare a single instance with ID 0: uint16_t singleInstanceID [ 1 ] = { 0 }; result = iowa_client_add_custom_object ( contextP , 3312 , 1 , singleInstanceID , 2 , resources , powerSwitchCallback , NULL , NULL , NULL ); Now the Power Control Object is presented to the LwM2M Servers by the IOWA stack. When a Server performs a command on one of its resources (or the whole Object), the powerSwitchCallback function is called. Let\u2019s assume our device provides two functions switch_on() and switch_off() to control the power switch and three interruptions to handle: SWITCH_ON when the power switch is set to On, SWITCH_OFF when the power switch is set to Off TIMER when a second had elapsed. We first define two global variables to store the power switch state: bool switchState ; unsigned int onTime ; In the interrupt handler, we modify these variables to be in sync with the actual power switch state (pseudo-code): switch ( interrupt ) { (...) case SWITCH_ON : switchState = true ; break ; case SWITCH_OFF : switchState = false ; break ; case TIMER : if ( switchState == true ) { onTime ++ ; } break ; (...) } Now the powerSwitchCallback function can be implemented: iowa_status_t powerSwitchCallback ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t iowaH ) { size_t i ; switch ( operation ) { case IOWA_DM_READ : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 5850 : dataP [ i ]. value . asBoolean = switchState ; break ; case 5852 : dataP [ i ]. value . asInteger = onTime ; break ; default : // Already handled by IOWA stack break ; } } break ; case IOWA_DM_WRITE : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 5850 : if ( dataP [ i ]. value . asBoolean == true ) { switch_on (); } else { switch_off (); } break ; case 5852 : if ( dataP [ i ]. value . asInteger == 0 ) { onTime = 0 ; } else { return IOWA_COAP_406_NOT_ACCEPTABLE ; } break ; default : // Already handled by IOWA stack break ; } } break ; default : // Already handled by IOWA stack break ; } return IOWA_COAP_NO_ERROR ; } Here we assume that the switch_on() and switch_off() functions will trigger an interrupt and the switchState variable is updated by the interrupt handler. A LwM2M Server can write only 0 as the new value of the On Time resource hence the check. If you test this code, you will notice that you can control the power switch remotely and check its state. However the LwM2M Server will not receive notifications when observing the Object resources. To correct this, we need to inform the IOWA stack of the changes not triggered by a LwM2M Server. This is done by calling the API iowa_client_object_resource_changed() whenever a change occurs. A correct interrupt handler is then: switch ( interrupt ) { (...) case SWITCH_ON : if ( switchState == false ) { iowa_client_object_resource_changed ( contextP , 3312 , 0 , 5850 ); } switchState = true ; break ; case SWITCH_OFF : if ( switchState == true ) { iowa_client_object_resource_changed ( contextP , 3312 , 0 , 5850 ); } switchState = false ; break ; case TIMER : if ( switchState == true ) { onTime ++ ; iowa_client_notification_lock ( contextP , true ); iowa_client_object_resource_changed ( contextP , 3312 , 0 , 5852 ); iowa_client_notification_lock ( contextP , false ); } break ; (...) } Note that the calls to iowa_client_notification_lock() are not necessary but are here as an example. /clearpage","title":"Controlling a Power Switch"},{"location":"CustomObject/#monitoring-the-temperature-during-a-period","text":"Let\u2019s consider that the device containing the IOWA Client is connected to a temperature sensor. You want to be able to monitor this sensor from a LwM2M Server. Monitored value will be reported with the time at which the value was taken. The following example can be implemented with iowa_client_IPSO_add_sensor and iowa_client_IPSO_update_values . But we will instead implement our own Custom Object to understand how monitored values with timestamp can be sent to a LwM2M Server. The first step is to determine the best layout of the LwM2M Object describing the temperature sensor. Fortunately, the IPSO Alliance defined the Temperature Object (ID: 3303) which suits our needs. By re-using a standardized Object, we do not need to provide the LwM2M Servers with the layout of our Object. A server already knows the Object 3303 which contains the following resources: Resource Name Resource ID Access Type Mandatory Type Description Sensor Value 5700 R Mandatory Float Last or Current Measured Value from the Sensor. Min Measured Value 5601 R Optional Float The minimum value measured by the sensor since power ON or reset. Max Measured Value 5602 R Optional Float The maximum value measured by the sensor since power ON or reset. Min Range Value 5603 R Optional Float The minimum value that can be measured by the sensor. Max Range Value 5604 R Optional Float The maximum value that can be measured by the sensor. Sensor Units 5701 R Optional String Measurement Units Definition e.g. \"Cel\" for Temperature in Celsius. Reset Min and Max Measured Values 5605 E Optional Reset the Min and Max Measured Values to Current Value. The Sensor Value resource is mandatory to implement and is used to monitor the temperature value. All the others resources are not relevant to our use case. As they are optional, we do not implement them. To implement this Object in our device, in our main(), after initializing the IOWA context (see above), we declare an array describing resource: iowa_lwm2m_resource_desc_t resources [ 1 ] = { { 5700 , IOWA_LWM2M_TYPE_FLOAT , IOWA_DM_READ , IOWA_RESOURCE_FLAG_MANDATORY } }; Note that the header file \"iowa_IPSO_ID.h\" in the \"include\" folder contains defines for the ID, type and operations of the Reusable Resources defined by the IPSO Alliance. Using these macros, we can write the equivalent code as: iowa_lwm2m_resource_desc_t resources [ 1 ] = { { IPSO_RSC_ID_SENSOR_VALUE , IPSO_RSC_TYPE_SENSOR_VALUE , IPSO_RSC_OP_SENSOR_VALUE , IOWA_RESOURCE_FLAG_MANDATORY } }; Instance-wise, we only have one temperature sensor to monitor and it makes no sense that the LwM2M Server could create new instances or delete some and the object does not used resources that can be multiple. The instanceCallback and the resInstanceCallback can be omitted and we declare a single instance with ID 0: uint16_t singleInstanceID [ 1 ] = { 0 }; result = iowa_client_add_custom_object ( contextP , 3303 , 1 , singleInstanceID , 1 , resources , tempSensorCallback , NULL , NULL , NULL ); Now the Temperature Object is presented to the LwM2M Servers by the IOWA stack. When a Server performs a command on one of its resources (or the whole Object), the tempSensorCallback function is called. We want to inform to the LwM2M Server the last values taken with the timestamp associated to each value. Let\u2019s assume our device provides two functions get_time() and get_temperature() to monitor the temperature value and one interruption to handle: NEW_TEMP when a new temperature value is available. We first define a new structure and two global variables to store the temperature values. The temperature values will be stored inside a circular buffer: #define NB_VALUE 10 typedef struct { int32_t timestamp ; float value ; } temp_value_t ; temp_value_t valuesList [ NB_VALUE ] = { 0 }; size_t currentIndex = 0 ; In the interrupt handler, we modify these variables to store the temperature values (pseudo-code): switch ( interrupt ) { (...) case NEW_TEMP : { valuesList [ currentIndex ]. timestamp = get_time (); valuesList [ currentIndex ]. value = get_temperature (); currentIndex ++ ; if ( currentIndex == NB_VALUE ) { currentIndex = 0 ; } break ; } (...) } Now the tempSensorCallback function can be implemented: iowa_status_t tempSensorCallback ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t iowaH ) { iowa_status_t result ; size_t i ; result = IOWA_COAP_NO_ERROR ; switch ( operation ) { case IOWA_DM_READ : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 5700 : { // On a Read operation, provides all the timestamp values size_t j ; if ( valuesList [ 0 ]. timestamp == 0 ) { // No value added yet break ; } if ( dataP [ i ]. timestamp != 0 ) { // Loop on next element break ; } // Find the latest timestamp not currently added j = currentIndex - 1 ; if ( i > 0 ) { while ( j != currentIndex ) { if ( j > 0 ) { if ( valuesList [ j -1 ]. timestamp == 0 ) { break ; } } else if ( valuesList [ NB_VALUE -1 ]. timestamp == 0 ) { break ; } if ( valuesList [ j ]. timestamp < dataP [ i -1 ]. timestamp ) { break ; } if ( j == 0 ) { j = NB_VALUE - 1 ; } else { j -- ; } } } dataP [ i ]. value . asFloat = valuesList [ j ]. value ; dataP [ i ]. timestamp = valuesList [ j ]. timestamp ; if ( j > 0 ) { if ( valuesList [ j -1 ]. timestamp != 0 ) { // Changed result to be called again in the callback result = IOWA_COAP_231_CONTINUE ; } } else if ( valuesList [ NB_VALUE -1 ]. timestamp != 0 ) { // Changed result to be called again in the callback result = IOWA_COAP_231_CONTINUE ; } break ; } default : // Already handled by IOWA stack break ; } } break ; default : // Already handled by IOWA stack break ; } return result ; } Pay attention that the timestamp must be absolute and not relative to the current time, means negative values are not accepted. If the timestamp is zero, it's ignored. If you test this code, you will notice that you can retrieve the current temperature value. However the LwM2M Server will not receive notifications when observing the Object resources. To correct this, we need to inform the IOWA stack of the changes not triggered by a LwM2M Server. This is done by calling the API iowa_client_object_resource_changed() whenever a change occurs. A correct interrupt handler is then: switch ( interrupt ) { (...) case NEW_TEMP : { valuesList [ currentIndex ]. timestamp = get_time (); valuesList [ currentIndex ]. value = get_temperature (); currentIndex ++ ; if ( currentIndex == NB_VALUE ) { currentIndex = 0 ; } iowa_client_object_resource_changed ( contextP , 3303 , 0 , 5700 ); break ; } (...) } The diagram of the above example can be: The Server sends first an Observation on /3303/0/5700. At this time the LwM2M Client has only one value to send back, and so the return value of the callback is 0.00 (No Error). Then the LwM2M Client retrieves the temperature values and call iowa_client_object_resource_changed for each new value. The Object callback has the possibility to return multiple values by returning the 2.31 (Continue) code. On first round, the application has to provide the first value, the callback is called with: numData : 1 dataP[0] : dataP[0].objectID : 3303, dataP[0].instanceID : 0, dataP[0].resourceID : 5700, dataP[0].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[0].type : IOWA_LWM2M_TYPE_FLOAT, dataP[0].value.asFloat : 0.0 dataP[0].timestamp : 0 On second round, the application has to provide the second value, the callback is called with: numData : 2 dataP[0] : dataP[0].objectID : 3303, dataP[0].instanceID : 0, dataP[0].resourceID : 5700, dataP[0].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[0].type : IOWA_LWM2M_TYPE_FLOAT, dataP[0].value.asFloat : FIRST_VALUE dataP[0].timestamp : FIRST_TIMESTAMP dataP[1] : dataP[1].objectID : 3303, dataP[1].instanceID : 0, dataP[1].resourceID : 5700, dataP[1].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[1].type : IOWA_LWM2M_TYPE_FLOAT, dataP[1].value.asFloat : 0.0 dataP[1].timestamp : 0 On third round, the application has to provide the third value, the callback is called with: numData : 3 dataP[0] : dataP[0].objectID : 3303, dataP[0].instanceID : 0, dataP[0].resourceID : 5700, dataP[0].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[0].type : IOWA_LWM2M_TYPE_FLOAT, dataP[0].value.asFloat : FIRST_VALUE dataP[0].timestamp : FIRST_TIMESTAMP dataP[1] : dataP[1].objectID : 3303, dataP[1].instanceID : 0, dataP[1].resourceID : 5700, dataP[1].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[1].type : IOWA_LWM2M_TYPE_FLOAT, dataP[1].value.asFloat : SECOND_VALUE dataP[1].timestamp : SECOND_TIMESTAMP dataP[2] : dataP[2].objectID : 3303, dataP[2].instanceID : 0, dataP[2].resourceID : 5700, dataP[2].resInstanceID : 65535 (IOWA_LWM2M_ID_ALL) dataP[2].type : IOWA_LWM2M_TYPE_FLOAT, dataP[2].value.asFloat : 0.0 dataP[2].timestamp : 0 And so on, until the last value is provided and the return value of the callback is 0.00 (No Error).","title":"Monitoring the temperature during a period"},{"location":"DeprecatedAPI/","text":"Deprecated API Reference \u00b6 Deprecated APIs are no longer supported which means that regression bugs will not be fixed. These APIs should not be used anymore. You are strongly advised to use their replacement. Note that deprecated API can be removed in a future IOWA release. Deprecated Compilation Flags \u00b6 IOWA_SINGLE_CONNECTION_MODE \u00b6 Support only one connection at a time. Useful for constrained devices in a single LwM2M Server environment. Notes \u00b6 This define has no more effect when set. LWM2M_SINGLE_SERVER_MODE \u00b6 This is only relevant when IOWA is in Client mode. When set, the Client supports only one Server configuration at a time. Useful for constrained devices in a single LwM2M Server environment. This define cannot be set when [ LWM2M_BOOTSTRAP ][LWM2M_BOOTSTRAP] is already set. Notes \u00b6 This define has no more effect when set. LWM2M_OLD_CONTENT_FORMAT_SUPPORT \u00b6 During the development of the Lightweight M2M protocol, some LwM2M products were released. These products were using temporary numbers for the content format of the LwM2M payload. Setting this flag allows IOWA to interact with these old implementations. It should be seldom required. Notes \u00b6 This define has no more effect when set. By default, the old content formats code are always supported. IOWA_LORAWAN_MINIMAL_SUPPORT \u00b6 Minimal support for LoRaWAN transport. URI scheme is in the form \"lorawan://\". The Endpoint will not be able to send its Objects list in the Registration message and Registration Update message if needs. This define should only be considered if the code size of IOWA is a concern. Notes \u00b6 This define has no more effect when set. LWM2M_NOTIFICATION_QUEUE_SIZE \u00b6 This is only relevant when IOWA is in Client mode. When set, this define sets the maximum stored notification values when the notification are not able to reach the Server. The values are saved in RAM by IOWA internally inside a First In First Out Queue. The maximum values stored is per observation. By default, when the define is not set, the value is 4. Notes \u00b6 This define has no more effect when set. LWM2M_STORAGE_QUEUE_PEEK_SUPPORT \u00b6 When a LwM2M Server observing some resources is not reachable, the LwM2M Client stores the notifications until the connectivity is restored. By default, IOWA stores the last notifications in memory. When this flag is set, IOWA discharges the storage of these notifications to the platform. New version using a peek/remove mechanism instead of a dequeue mechanism. This feature requires the system abstraction functions iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_peek() , iowa_system_queue_remove() , and iowa_system_queue_delete() to be implemented. Notes \u00b6 This define will be later replaced by LWM2M_STORAGE_QUEUE_SUPPORT . It means the Storage Queue with Peek behavior will be the default. LwM2M features removal \u00b6 LwM2M mandatory features can be removed depending of the use case. Removing a feature should only be done to reduce the code size of IOWA on constrained devices, and should not be considered for other case: LWM2M_READ_OPERATION_REMOVE : Remove the ability to handle a Read Operation. Only relevant for LwM2M Client mode. When this flag is set, LWM2M_OBSERVE_OPERATION_REMOVE and LWM2M_WRITE_ATTRIBUTES_OPERATION_REMOVE are also set. LWM2M_DISCOVER_OPERATION_REMOVE : Remove the ability to handle a Discover Operation. Only relevant for LwM2M Client mode. LWM2M_WRITE_OPERATION_REMOVE : Remove the ability to handle a Write Operation. Only relevant for LwM2M Client mode. LWM2M_WRITE_ATTRIBUTES_OPERATION_REMOVE : Remove the ability to handle a Write-Attributes Operation. Only relevant for LwM2M Client mode. LWM2M_EXECUTE_OPERATION_REMOVE : Remove the ability to handle a Execute Operation. Only relevant for LwM2M Client mode. LWM2M_CREATE_OPERATION_REMOVE : Remove the ability to handle a Create Operation. Only relevant for LwM2M Client mode. LWM2M_DELETE_OPERATION_REMOVE : Remove the ability to handle a Delete Operation. Only relevant for LwM2M Client mode. LWM2M_OBSERVE_OPERATION_REMOVE : Remove the ability to handle a Observe Operation. Only relevant for LwM2M Client mode. When this flag is set, LWM2M_WRITE_ATTRIBUTES_OPERATION_REMOVE is also set. LWM2M_OPAQUE_CONTENT_FORMAT_REMOVE : Remove the ability to decode/encode the Opaque Content Format. LWM2M_TEXT_CONTENT_FORMAT_REMOVE : Remove the ability to decode/encode the Plain Text Content Format. Notes \u00b6 These defines have no more effect when set. Deprecated Enumeration Values \u00b6 Deprecated enumeration values are no longer supported which means that regression bugs will not be fixed. These enumeration values should not be used anymore. You are strongly advised to use their replacement. Note that deprecated Enumeration can be removed in a future IOWA release. IOWA_IPSO_LEVEL_CONTROL \u00b6 An [ iowa_IPSO_ID_t ][iowa_IPSO_ID_t] enumeration value, used to define percentage sensors. Notes \u00b6 The Dimmer API is now responsible of adding, removing and updating percentage sensors, by using the following functions: iowa_client_add_dimmer_object() : to add a new dimmer sensor. iowa_client_remove_dimmer_object() : to remove a dimmer sensor. iowa_client_dimmer_update_value() : to update the dimmer's level value. iowa_client_dimmer_update_values() : to update the dimmer's multiple level values, . Deprecated API \u00b6 iowa_server_configuration_set \u00b6 This API has been replaced by iowa_client_set_server_configuration() . Prototype iowa_status_t iowa_server_configuration_set ( iowa_context_t contextP , uint16_t shortId , iowa_server_setting_id_t settingId , void * argP ); Description iowa_server_configuration_set() configures the settings of a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The short ID of a LwM2M Server. settingId : The setting to set. See iowa_server_setting_id_t . argP : A pointer to the setting value. Dependent on settingId . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortId does not match any known server. IOWA_COAP_405_METHOD_NOT_ALLOWED : settingId is nil. IOWA_COAP_501_NOT_IMPLEMENTED : invalid settingId value. Header File iowa_client.h","title":"Deprecated APIs"},{"location":"DeprecatedAPI/#deprecated-api-reference","text":"Deprecated APIs are no longer supported which means that regression bugs will not be fixed. These APIs should not be used anymore. You are strongly advised to use their replacement. Note that deprecated API can be removed in a future IOWA release.","title":"Deprecated API Reference"},{"location":"DeprecatedAPI/#deprecated-compilation-flags","text":"","title":"Deprecated Compilation Flags"},{"location":"DeprecatedAPI/#iowa_single_connection_mode","text":"Support only one connection at a time. Useful for constrained devices in a single LwM2M Server environment.","title":"IOWA_SINGLE_CONNECTION_MODE"},{"location":"DeprecatedAPI/#notes","text":"This define has no more effect when set.","title":"Notes"},{"location":"DeprecatedAPI/#lwm2m_single_server_mode","text":"This is only relevant when IOWA is in Client mode. When set, the Client supports only one Server configuration at a time. Useful for constrained devices in a single LwM2M Server environment. This define cannot be set when [ LWM2M_BOOTSTRAP ][LWM2M_BOOTSTRAP] is already set.","title":"LWM2M_SINGLE_SERVER_MODE"},{"location":"DeprecatedAPI/#notes_1","text":"This define has no more effect when set.","title":"Notes"},{"location":"DeprecatedAPI/#lwm2m_old_content_format_support","text":"During the development of the Lightweight M2M protocol, some LwM2M products were released. These products were using temporary numbers for the content format of the LwM2M payload. Setting this flag allows IOWA to interact with these old implementations. It should be seldom required.","title":"LWM2M_OLD_CONTENT_FORMAT_SUPPORT"},{"location":"DeprecatedAPI/#notes_2","text":"This define has no more effect when set. By default, the old content formats code are always supported.","title":"Notes"},{"location":"DeprecatedAPI/#iowa_lorawan_minimal_support","text":"Minimal support for LoRaWAN transport. URI scheme is in the form \"lorawan://\". The Endpoint will not be able to send its Objects list in the Registration message and Registration Update message if needs. This define should only be considered if the code size of IOWA is a concern.","title":"IOWA_LORAWAN_MINIMAL_SUPPORT"},{"location":"DeprecatedAPI/#notes_3","text":"This define has no more effect when set.","title":"Notes"},{"location":"DeprecatedAPI/#lwm2m_notification_queue_size","text":"This is only relevant when IOWA is in Client mode. When set, this define sets the maximum stored notification values when the notification are not able to reach the Server. The values are saved in RAM by IOWA internally inside a First In First Out Queue. The maximum values stored is per observation. By default, when the define is not set, the value is 4.","title":"LWM2M_NOTIFICATION_QUEUE_SIZE"},{"location":"DeprecatedAPI/#notes_4","text":"This define has no more effect when set.","title":"Notes"},{"location":"DeprecatedAPI/#lwm2m_storage_queue_peek_support","text":"When a LwM2M Server observing some resources is not reachable, the LwM2M Client stores the notifications until the connectivity is restored. By default, IOWA stores the last notifications in memory. When this flag is set, IOWA discharges the storage of these notifications to the platform. New version using a peek/remove mechanism instead of a dequeue mechanism. This feature requires the system abstraction functions iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_peek() , iowa_system_queue_remove() , and iowa_system_queue_delete() to be implemented.","title":"LWM2M_STORAGE_QUEUE_PEEK_SUPPORT"},{"location":"DeprecatedAPI/#notes_5","text":"This define will be later replaced by LWM2M_STORAGE_QUEUE_SUPPORT . It means the Storage Queue with Peek behavior will be the default.","title":"Notes"},{"location":"DeprecatedAPI/#lwm2m-features-removal","text":"LwM2M mandatory features can be removed depending of the use case. Removing a feature should only be done to reduce the code size of IOWA on constrained devices, and should not be considered for other case: LWM2M_READ_OPERATION_REMOVE : Remove the ability to handle a Read Operation. Only relevant for LwM2M Client mode. When this flag is set, LWM2M_OBSERVE_OPERATION_REMOVE and LWM2M_WRITE_ATTRIBUTES_OPERATION_REMOVE are also set. LWM2M_DISCOVER_OPERATION_REMOVE : Remove the ability to handle a Discover Operation. Only relevant for LwM2M Client mode. LWM2M_WRITE_OPERATION_REMOVE : Remove the ability to handle a Write Operation. Only relevant for LwM2M Client mode. LWM2M_WRITE_ATTRIBUTES_OPERATION_REMOVE : Remove the ability to handle a Write-Attributes Operation. Only relevant for LwM2M Client mode. LWM2M_EXECUTE_OPERATION_REMOVE : Remove the ability to handle a Execute Operation. Only relevant for LwM2M Client mode. LWM2M_CREATE_OPERATION_REMOVE : Remove the ability to handle a Create Operation. Only relevant for LwM2M Client mode. LWM2M_DELETE_OPERATION_REMOVE : Remove the ability to handle a Delete Operation. Only relevant for LwM2M Client mode. LWM2M_OBSERVE_OPERATION_REMOVE : Remove the ability to handle a Observe Operation. Only relevant for LwM2M Client mode. When this flag is set, LWM2M_WRITE_ATTRIBUTES_OPERATION_REMOVE is also set. LWM2M_OPAQUE_CONTENT_FORMAT_REMOVE : Remove the ability to decode/encode the Opaque Content Format. LWM2M_TEXT_CONTENT_FORMAT_REMOVE : Remove the ability to decode/encode the Plain Text Content Format.","title":"LwM2M features removal"},{"location":"DeprecatedAPI/#notes_6","text":"These defines have no more effect when set.","title":"Notes"},{"location":"DeprecatedAPI/#deprecated-enumeration-values","text":"Deprecated enumeration values are no longer supported which means that regression bugs will not be fixed. These enumeration values should not be used anymore. You are strongly advised to use their replacement. Note that deprecated Enumeration can be removed in a future IOWA release.","title":"Deprecated Enumeration Values"},{"location":"DeprecatedAPI/#iowa_ipso_level_control","text":"An [ iowa_IPSO_ID_t ][iowa_IPSO_ID_t] enumeration value, used to define percentage sensors.","title":"IOWA_IPSO_LEVEL_CONTROL"},{"location":"DeprecatedAPI/#notes_7","text":"The Dimmer API is now responsible of adding, removing and updating percentage sensors, by using the following functions: iowa_client_add_dimmer_object() : to add a new dimmer sensor. iowa_client_remove_dimmer_object() : to remove a dimmer sensor. iowa_client_dimmer_update_value() : to update the dimmer's level value. iowa_client_dimmer_update_values() : to update the dimmer's multiple level values, .","title":"Notes"},{"location":"DeprecatedAPI/#deprecated-api","text":"","title":"Deprecated API"},{"location":"DeprecatedAPI/#iowa_server_configuration_set","text":"This API has been replaced by iowa_client_set_server_configuration() . Prototype iowa_status_t iowa_server_configuration_set ( iowa_context_t contextP , uint16_t shortId , iowa_server_setting_id_t settingId , void * argP ); Description iowa_server_configuration_set() configures the settings of a LwM2M Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortId : The short ID of a LwM2M Server. settingId : The setting to set. See iowa_server_setting_id_t . argP : A pointer to the setting value. Dependent on settingId . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_403_FORBIDDEN : shortId is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : shortId does not match any known server. IOWA_COAP_405_METHOD_NOT_ALLOWED : settingId is nil. IOWA_COAP_501_NOT_IMPLEMENTED : invalid settingId value. Header File iowa_client.h","title":"iowa_server_configuration_set"},{"location":"DeviceUpdate/","text":"Device Update \u00b6 Firmware Update \u00b6 In LightweightM2M, the Firmware Update mechanism is used to deliver a Firmware Package to a LwM2M Client. There is no constraint on the format of the Firmware Package. A LwM2M Client supporting Firmware Update exposes to the LwM2M Server the [ Firmware Update Object ][Firmware Update Object]. The Firmware Update mechanism is a state machine as summarized below: To update the firmware of a LwM2M Client, the LwM2M Server first chooses the delivery method to use by reading the LwM2M Client\u2019s Delivery Method ( /5/0/9 ). This resource indicates the delivery methods supported by the LwM2M Client: The \"pull\" method : The LwM2M Server writes an URI on the LwM2M Client\u2019s Package URI ( /5/0/1 ). The LwM2M Client then downloads the Firmware Package from this URI using an alternate mechanism e.g. FTP or HTTP. The \"push\" method : The LwM2M Server writes the Firmware Package on the LwM2M Client\u2019s Package ( /5/0/0 ). It is advised for the LwM2M Server to start an observation of the LwM2M Client\u2019s resources State ( /5/0/3 ) and Result ( /5/0/5 ) to be informed of the progress of the LwM2M Client. Assuming the LwM2M Client is in Idle state (value of /5/0/3 is 0 ), the LwM2M Server starts the delivery of the Firmware Package: \"pull\" method : The LwM2M Server writes the URI of the Firmware Package in LwM2M Client\u2019s Package URI ( /5/0/1 ). : The State ( /5/0/3 ) changes to Downloading ( 1 ), meaning the LwM2M Client starts to download the Firmware Package. : The LwM2M Server now waits for the State to change to Downloaded ( 2 ), meaning the download completed successfully and the Firmware Package is valid. \"push\" method : The LwM2M Server writes the content of the Firmware Package in LwM2M Client\u2019s Package ( /5/0/0 ). At the end of the write, the State ( /5/0/3 ) changes to Downloaded ( 2 ), meaning the Firmware Package is valid. : Note that the State may change to Downloading ( 1 ) during the write if it takes time. In both methods, in case of error, the State ( /5/0/3 ) becomes Idle ( 0 ) and the reason of the error is indicated by Result ( /5/0/5 ): 2: Not enough flash memory for the new firmware package. 3: Out of RAM during downloading process. 4: Connection lost during downloading process. 5: Integrity check failure for new downloaded package. 6: Unsupported package type. 7: Invalid URI 9: Unsupported protocol. Now the LwM2M Client is in Downloaded state, meaning that it contains the new Firmware Package. The LwM2M Server triggers the update by sending an Execute command on Update ( /5/0/2 ). The State ( /5/0/3 ) changes to Updating ( 3 ). In case of error, the State ( /5/0/3 ) reverts to Downloaded ( 2 ) and the Result ( /5/0/5 ) changes to Firmware Update Failed ( 8 ). In case of success, the State ( /5/0/3 ) changes to Idle ( 0 ) and the Result ( /5/0/5 ) changes to Firmware Updated Successfully ( 1 ). Note that the firmware update may require the LwM2M Client to reboot. In this case, after the reboot, the LwM2M Client registers to the LwM2M Server and the previous observations are no longer valid. In this case, the LwM2M Server must read State ( /5/0/3 ) and Result ( /5/0/5 ) to determine if the update was successful. When the LwM2M Client is in Downloaded state, the LwM2M Server may delete the stored Firmware Package by writing a zero-length value to the resource Package ( /5/0/0 ) or Package URI ( /5/0/1 ). Firmware Update using IOWA \u00b6 The API iowa_client_firmware_update_configure() allows an IOWA Client to support the LwM2M Firmware Update. The compilation flag [ IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT ][IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT] must be set. This API requires a delivery callback. It is either a \"download callback\" for the \"pull\" method or a \"write callback\" for the \"push\" method. Of course, the IOWA Client can support both methods by providing two callbacks. The API also requires an \"update callback\". The IOWA stack takes care of the implementation of the [ Firmware Update Object ][Firmware Update Object] and its associated state machine. The user-provided callbacks are called as illustrated below: \"Pull\" method \u00b6 The \"download callback\" and the \"update callback\" should start an independent task to keep the IOWA Client responsive to the LwM2M Server\u2019s requests. Both these callbacks inform the IOWA Stack of their success or failure by calling the API iowa_client_firmware_update_set_status() . \"Push\" method \u00b6 The \"write callback\" is called with the Firmware Package received from the Server. As the Firmware Package is usually bigger than the network MTU, it is advised to enable the [ IOWA_COAP_BLOCK_MINIMAL_SUPPORT ][Additional flags] compilation flag. Then the Firmware Package can be received in several chunks. In this case, the \"write callback\" is called several times. However, the data is always provided in sequence with no gaps nor duplicates. Additionally, the flag [ IOWA_FIRMWARE_UPDATE_MAX_BLOCK_INTERVAL ][IOWA_FIRMWARE_UPDATE_MAX_BLOCK_INTERVAL] can be set to define the maximum time in seconds to wait between block reception. If this delay expires, the Firmware Update state machine resets to the Idle state with a Connection Lost error.\\ If this flag is not set, IOWA will wait indefinitely for the next block. This is useful for device with intermittent connectivity. Below an example in pseudo-code of the Client to support both Firmware Update methods without using Multithread: #include \"iowa_client.h\" static void prv_downloadCallback ( char * uri , void * userData , iowa_context_t contextP ) { if ( DOWNLOAD_PACKAGE ( uri )) { iowa_client_firmware_update_set_status ( contextP , IOWA_FW_STATUS_SUCCESSFUL ); } else { // Set the error. Possible value: // - IOWA_FW_STATUS_OUT_OF_STORAGE // - IOWA_FW_STATUS_OUT_OF_MEMORY // - IOWA_FW_STATUS_CONNECTION_LOST // - IOWA_FW_STATUS_INVALID_URI // - IOWA_FW_STATUS_UNSUPPORTED_PROTOCOL iowa_client_firmware_update_set_status ( contextP , /* ERROR */ ); } } static iowa_fw_status_t prv_writeCallback ( iowa_fw_write_cmd_t cmd , size_t dataLength , uint8_t * data , void * userData , iowa_context_t contextP ) { iowa_fw_status_t status ; status = IOWA_FW_STATUS_SUCCESSFUL ; switch ( cmd ) { case IOWA_FW_PACKAGE_RESET : // Reset the package break ; case IOWA_FW_PACKAGE_WRITE : if ( WRITE_PACKAGE ( dataLength , data ) == false ) { // Set the error. Possible value: // - IOWA_FW_STATUS_OUT_OF_STORAGE // - IOWA_FW_STATUS_OUT_OF_MEMORY // - IOWA_FW_STATUS_INTEGRITY_CHECK_FAILURE // - IOWA_FW_STATUS_UNSUPPORTED_TYPE status = /* ERROR */ ; } break ; default : // This should not happen break ; } return status ; } static void prv_updateCallback ( void * userData , iowa_context_t contextP ) { if ( UPDATE_PACKAGE ()) { iowa_client_firmware_update_set_status ( contextP , IOWA_FW_STATUS_SUCCESSFUL ); } else { iowa_client_firmware_update_set_status ( contextP , IOWA_FW_STATUS_UPDATE_FAILED ); } } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); iowa_client_configure ( iowaH , \"IOWA_FU_Client\" , NULL , NULL ); iowa_client_firmware_update_configure ( iowaH , NULL , NULL , prv_downloadCallback , prv_writeCallback , prv_updateCallback , NULL ); iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_server ( iowaH , 1234 ); iowa_close ( iowaH ); return 0 ; } Software Management \u00b6 In LightweightM2M, the Software Management mechanism is used to install software package and/or activate Software Components to a LwM2M Client. A LwM2M Client supporting Software Management exposes to the LwM2M Server the [ Software Management Object ][Software Management Object]. The [ Software Management Object ][Software Management Object] only allows to install/uninstall a software. To allow the activation/deactivation of a Software Component the LwM2M Client must support [ Software Component Object ][Software Component Object]. Software Management mechanism \u00b6 The Software Management mechanism is split in two sub-processes : The Package Installation, manages all the operations performed to install a software (Download, Check, Install, Uninstall). The Software Activation, allows the use of an installed software (Activation, Deactivation) if [ Software Component Object ][Software Component Object] is supported. Package Installation \u00b6 The Package Installation process is a state machine as summarized below: Download software \u00b6 To download a software of a LwM2M Client, the LwM2M Server has two possible methods: The \"pull\" method : The LwM2M Server writes an URI on the LwM2M Client\u2019s Package URI ( /9/x/3 ). The LwM2M Client then downloads the software Package from this URI using an alternate mechanism e.g. FTP or HTTP. : With this method, LwM2M Client can use a User Name ( /9/x/14 ) and a Password ( /9/x/15 ) for identification. The \"push\" method : The LwM2M Server writes the software Package on the LwM2M Client\u2019s Package ( /9/x/2 ). It is advised for the LwM2M Server to start an observation of the LwM2M Client\u2019s resources State ( /9/x/7 ) and Result ( /9/x/9 ) to be informed of the progress of the LwM2M Client. If the LwM2M Client is in Initial state (value of /9/x/7 is 0 ), the LwM2M Server can start the delivery of the software package. This means that the software is not installed and that the system is ready to start a download: \"pull\" method : The LwM2M Server writes the URI of the software Package in LwM2M Client\u2019s Package URI ( /9/x/3 ). \"push\" method : The LwM2M Server writes the content of the software Package in LwM2M Client\u2019s Package ( /9/x/2 ). In both methods, the State ( /9/x/7 ) change to Downloading ( 1 ), meaning the LwM2M Client starts to download the software Package. The Result ( /9/x/9 ) should be also at Downloading ( 1 ). The LwM2M Server now waits for the State ( /9/x/7 ) to change to Delivered ( 3 ), meaning the download completed successfully and the software Package is valid. The Result ( /9/x/9 ) should indicates Successfully Downloaded ( 3 ). Note that the State ( /9/x/7 ) may change to Downloaded ( 2 ), meaning the download completed successfully. In case of error, the State ( /9/x/7 ) becomes Initial ( 0 ) and the reason of the error is indicated by Result ( /9/x/9 ): 50: Not enough flash memory for the new software package. 51: Out of RAM during downloading process. 52: Connection lost during downloading process. 53: Integrity check failure for new downloaded package. 54: Unsupported package type. 56: Invalid URI (only in \"pull\" method). 57: Device defined update error. Install/Uninstall software \u00b6 Once the LwM2M Client is in Delivered state, meaning that it contains the new software Package. The LwM2M Server can start the software installation, by sending an Execute command on Install ( /9/x/4 ): In case of success, the State ( /9/x/7 ) changes to Installed ( 4 ) and the Result ( /9/x/9 ) indicates Successfully Installed ( 2 ). In case of error, the State remains and the Result ( /9/x/9 ) indicates Installation failure ( 58 ). If the LwM2M Client is in Delivered state or Installed state, The LwM2M Server can start the software uninstallation, by sending an Execute command on Uninstall ( /9/x/6 ): In any case, the State ( /9/x/7 ) changes to Initial ( 0 ) and the Result ( /9/x/9 ) indicates Initial value ( 0 ) or Uninstallation failure ( 59 ). Software Activation \u00b6 The Software Activation process is a state machine as summarized below: This state machine is only alive if software is installed, meaning that the State ( /9/x/7 ) has the Installed value ( 4 ). The activation process is only available if at least one [ Software Component Object ][Software Component Object] is link to the [ Software Management Object ][Software Management Object]. This link can be seen with the Software Component Link resource provided ( /9/x/17 ). When the state machine is not alive, its state ( /9/x/12 ) is Inactive state ( false ). To pass in Active state ( true ), the LwM2M Server should send an Execute command on Activate ( /9/x/10 ). To pass in Inactive state ( false ), the LwM2M Server should send an Execute command on Deactivate ( /9/x/11 ). This will activate/deactivate each Software Component linked, if activated resources are provide ( /14/x/3 , /14/x/4 , /14/x/5 ). The state of each Software Component linked can be seen with the activation state resource ( /14/x/5 ). Even if the Software management object activate/deactivate its Software components linked, each Software component object can be activate/deactivate separately with: an Execute command on Activate ( /14/x/3 ) send by the LwM2M Server will set the Software Component state ( /14/x/5 ) to Activate ( true ). an Execute command on Deactivate ( /14/x/4 ) send by the LwM2M Server will set the Software Component state ( /14/x/5 ) to Deactivate ( false ). \\clearpage Software Management using IOWA \u00b6 The iowa_client_enable_software_package_management() API allows an IOWA Client to support the LwM2M Software Management feature. This API allows users to get modifications (create or delete) by LwM2M Server with the \"update callback\". This API requires a delivery callback. It is either a \"download callback\" for the \"pull\" method or a \"write callback\" for the \"push\" method. Of course, the IOWA Client can support both methods by providing two callbacks. The API also requires an \"install callback\". The IOWA stack takes care of the implementation of the [ Software Management Object ][Software Management Object] and its associated state machine. The iowa_client_add_software_package() API must be called to instantiate each Software Management element needed. For a Software Management element, the users-provided callbacks are called as illustrated below: The \"download callback\" is called in case of Write on \"Package URI\" whereas the \"write callback\" is called in case of Write on \"Package\". \"pull\" method : The \"download callback\" should start an independent task to keep the IOWA Client responsive to the LwM2M Server\u2019s requests. This callback inform the IOWA Stack of its success or failure by calling the iowa_client_set_software_package_command_result() API: When packet is downloaded, it should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_DOWNLOADING_SUCCESSFUL result if success or error result. When packet is verified, it should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL result if success or error result. \"push\" method : As the software management package can be received in several chunks, the \"write callback\" may be called several times. However, the data is always provided in sequence with no gaps nor duplicates. This callback inform the IOWA Stack of its success by returning IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL or failure by returning error result. The \"install callback\" is called in case of Execute on \"Install\" when package has been delivered. The \"install callback\" can also be called in case of Execute on \"Uninstall\" when package has been delivered or installed. The \"install callback\" should start an independent task to keep the IOWA Client responsive to the LwM2M Server\u2019s requests. This callback inform the IOWA Stack of its success or failure by calling the iowa_client_set_software_package_command_result() API. To remove a Software Management element, the iowa_client_remove_software_package() API can be called. To remove the entire Software Management feature, the iowa_client_disable_software_package_management() API can be called. Also, the LwM2M Client can update the state of any Software Management element by calling the iowa_client_software_package_update_state() API. To be able to use the Activation process, Software Components must have been provided. \\clearpage Software Component using IOWA \u00b6 The iowa_client_enable_software_component() API allows an IOWA Client to support the LwM2M Software Component feature. This API requires an \"activate callback\". The IOWA stack takes care of the implementation of the [ Software Component Object ][Software Component Object] and its associated state machine linked with the [ Software Management Object ][Software Management Object]. For a Software Component element, the users-provided callback is called as illustrated below: The \"activate callback\" is called in case of Execute on \"Activate\" or \"Deactivate\" when package is installed. If linked with a Software Management Object, the users-provided callback can also be called as illustrated below: For each Software Component linked to the Software Management object, the Software Component's \"activate callback\" is called in case of Execute on \"Activate\" or \"Deactivate\" when Software Management object's package is installed. The iowa_client_add_software_component() API must be called to instantiate each Software Component element needed. This API will return id , to link a Software Component to a Software Management, this id must be passed to iowa_client_add_software_package() API at start. To set the Software Component activation state, the iowa_client_software_component_update_state() API can be called. \\clearpage Below an example in pseudo-code of the Client to support both Software Management methods and Software Component methods without using Multithread: #include \"iowa_software_management.h\" #include \"iowa_software_component.h\" static void prv_downloadCallback ( iowa_sensor_t id , const char * uriP , const char * userNameP , const char * passwordP , void * userDataP , iowa_context_t contextP ) { if ( DOWNLOAD_PACKAGE ( uri , username , password )) { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_DOWNLOADING_SUCCESSFUL ); if ( CHECK_PACKAGE ( userInfoP )) { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL ); return ; } else { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_INTEGRITY_CHECK_FAILURE ); return ; } } // Set the error. Possible value: // - IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_STORAGE // - IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_MEMORY // - IOWA_SW_PKG_UPDATE_RESULT_CONNECTION_LOST // - IOWA_SW_PKG_UPDATE_RESULT_INTEGRITY_CHECK_FAILURE // - IOWA_SW_PKG_UPDATE_RESULT_UNSUPPORTED_TYPE // - IOWA_SW_PKG_UPDATE_RESULT_INVALID_URI // - IOWA_SW_PKG_UPDATE_RESULT_UPDATE_FAILED iowa_client_set_software_package_command_result ( contextP , id , /* ERROR */ ); } static iowa_sw_pkg_result_t prv_writeCallback ( iowa_sensor_t id , iowa_sw_pkg_write_cmd_t cmd , size_t dataLength , uint8_t * dataP , void * userDataP , iowa_context_t contextP ) { switch ( cmd ) { case IOWA_SW_PKG_COMMAND_RESET : if ( RESET_PACKAGE () == true ) { return IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL ; } break ; case IOWA_SW_PKG_COMMAND_WRITE : if ( WRITE_PACKAGE ( dataLength , dataP ) == true ) { return IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL ; } break ; default : // This should not happen break ; } // Set the error. Possible value: // - IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_STORAGE // - IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_MEMORY // - IOWA_SW_PKG_UPDATE_RESULT_CONNECTION_LOST // - IOWA_SW_PKG_UPDATE_RESULT_INTEGRITY_CHECK_FAILURE // - IOWA_SW_PKG_UPDATE_RESULT_UNSUPPORTED_TYPE // - IOWA_SW_PKG_UPDATE_RESULT_UPDATE_FAILED return /* ERROR */ ; } static void prv_installCallback ( iowa_sensor_t id , iowa_sw_pkg_install_cmd_t cmd , void * userDataP , iowa_context_t contextP ) { if ( cmd == IOWA_SW_PKG_COMMAND_INSTALL ) { if ( INSTALL_PACKAGE ( userInfoP ) == false ) { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_INSTALLED_FAILURE ); return ; } } else { if ( UNINSTALL_PACKAGE ( userInfoP ) == false ) { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_UNINSTALLED_FAILURE ); return ; } } iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL ); } static iowa_status_t prv_activateCallback ( iowa_sensor_t id , bool activationState , void * userDataP , iowa_context_t contextP ) { if ( activationState == true ) { if ( ACTIVATE_PACKAGE ( userInfoP ) == false ) { return IOWA_COAP_400_BAD_REQUEST ; } } else { if ( DEACTIVATE_PACKAGE ( userInfoP ) == false ) { return IOWA_COAP_400_BAD_REQUEST ; } } return IOWA_COAP_NO_ERROR ; } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; iowa_sw_pkg_optional_info_t swMgmt ; iowa_sensor_t softMgmtId ; iowa_sensor_t softCmp1Id ; iowa_sensor_t softCmp2Id ; iowa_sw_cmp_info_t swCmp ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); iowa_client_configure ( iowaH , \"IOWA_SW_Client\" , NULL , NULL ); // Enable software management feature iowa_client_enable_software_package_management ( iowaH , NULL , prv_downloadCallback , prv_writeCallback , prv_installCallback , NULL ); // Add software management instance result = iowa_client_add_software_package ( iowaH , \"soft1\" , \"1.0\" , NULL , & softMgmtId ); // Add software management instance result = iowa_client_add_software_package ( iowaH , \"soft2\" , \"1.0\" , NULL , & softMgmtId ); // Enable software component feature iowa_client_enable_software_component ( iowaH , prv_activateCallback , NULL ); // Add software component instance memset ( & swCmp , 0 , sizeof ( iowa_sw_cmp_info_t )); swCmp . identityP = \"cmp1\" ; swCmp . versionP = \"1.1\" ; iowa_client_add_software_component ( iowaH , & swCmp , false , & softCmp1Id ); // Add software component instance memset ( & swCmp , 0 , sizeof ( iowa_sw_cmp_info_t )); swCmp . packP = ( uint8_t * ) \"cmp2\" ; swCmp . packLength = 4 ; iowa_client_add_software_component ( iowaH , & swCmp , true , & softCmp2Id ); // Add software management instance memset ( & swMgmt , 0 , sizeof ( iowa_sw_pkg_optional_info_t )); swMgmt . swComponentLinkCount = 2 ; swMgmt . swComponentLinkP = ( iowa_sensor_t * ) iowa_system_malloc ( swMgmt . swComponentLinkCount * sizeof ( iowa_sensor_t )); swMgmt . swComponentLinkP [ 0 ] = softCmp1Id ; swMgmt . swComponentLinkP [ 1 ] = softCmp2Id ; result = iowa_client_add_software_package ( iowaH , \"soft3\" , \"1.1\" , & swMgmt , & softMgmtId ); iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) if ( swMgmt . swComponentLinkP != NULL ) { iowa_system_free ( swMgmt . swComponentLinkP ); } iowa_client_disable_software_component ( iowaH ); iowa_client_disable_software_package_management ( iowaH ); iowa_client_remove_server ( iowaH , 1234 ); iowa_close ( iowaH ); return 0 ; }","title":"Device Update"},{"location":"DeviceUpdate/#device-update","text":"","title":"Device Update"},{"location":"DeviceUpdate/#firmware-update","text":"In LightweightM2M, the Firmware Update mechanism is used to deliver a Firmware Package to a LwM2M Client. There is no constraint on the format of the Firmware Package. A LwM2M Client supporting Firmware Update exposes to the LwM2M Server the [ Firmware Update Object ][Firmware Update Object]. The Firmware Update mechanism is a state machine as summarized below: To update the firmware of a LwM2M Client, the LwM2M Server first chooses the delivery method to use by reading the LwM2M Client\u2019s Delivery Method ( /5/0/9 ). This resource indicates the delivery methods supported by the LwM2M Client: The \"pull\" method : The LwM2M Server writes an URI on the LwM2M Client\u2019s Package URI ( /5/0/1 ). The LwM2M Client then downloads the Firmware Package from this URI using an alternate mechanism e.g. FTP or HTTP. The \"push\" method : The LwM2M Server writes the Firmware Package on the LwM2M Client\u2019s Package ( /5/0/0 ). It is advised for the LwM2M Server to start an observation of the LwM2M Client\u2019s resources State ( /5/0/3 ) and Result ( /5/0/5 ) to be informed of the progress of the LwM2M Client. Assuming the LwM2M Client is in Idle state (value of /5/0/3 is 0 ), the LwM2M Server starts the delivery of the Firmware Package: \"pull\" method : The LwM2M Server writes the URI of the Firmware Package in LwM2M Client\u2019s Package URI ( /5/0/1 ). : The State ( /5/0/3 ) changes to Downloading ( 1 ), meaning the LwM2M Client starts to download the Firmware Package. : The LwM2M Server now waits for the State to change to Downloaded ( 2 ), meaning the download completed successfully and the Firmware Package is valid. \"push\" method : The LwM2M Server writes the content of the Firmware Package in LwM2M Client\u2019s Package ( /5/0/0 ). At the end of the write, the State ( /5/0/3 ) changes to Downloaded ( 2 ), meaning the Firmware Package is valid. : Note that the State may change to Downloading ( 1 ) during the write if it takes time. In both methods, in case of error, the State ( /5/0/3 ) becomes Idle ( 0 ) and the reason of the error is indicated by Result ( /5/0/5 ): 2: Not enough flash memory for the new firmware package. 3: Out of RAM during downloading process. 4: Connection lost during downloading process. 5: Integrity check failure for new downloaded package. 6: Unsupported package type. 7: Invalid URI 9: Unsupported protocol. Now the LwM2M Client is in Downloaded state, meaning that it contains the new Firmware Package. The LwM2M Server triggers the update by sending an Execute command on Update ( /5/0/2 ). The State ( /5/0/3 ) changes to Updating ( 3 ). In case of error, the State ( /5/0/3 ) reverts to Downloaded ( 2 ) and the Result ( /5/0/5 ) changes to Firmware Update Failed ( 8 ). In case of success, the State ( /5/0/3 ) changes to Idle ( 0 ) and the Result ( /5/0/5 ) changes to Firmware Updated Successfully ( 1 ). Note that the firmware update may require the LwM2M Client to reboot. In this case, after the reboot, the LwM2M Client registers to the LwM2M Server and the previous observations are no longer valid. In this case, the LwM2M Server must read State ( /5/0/3 ) and Result ( /5/0/5 ) to determine if the update was successful. When the LwM2M Client is in Downloaded state, the LwM2M Server may delete the stored Firmware Package by writing a zero-length value to the resource Package ( /5/0/0 ) or Package URI ( /5/0/1 ).","title":"Firmware Update"},{"location":"DeviceUpdate/#firmware-update-using-iowa","text":"The API iowa_client_firmware_update_configure() allows an IOWA Client to support the LwM2M Firmware Update. The compilation flag [ IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT ][IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT] must be set. This API requires a delivery callback. It is either a \"download callback\" for the \"pull\" method or a \"write callback\" for the \"push\" method. Of course, the IOWA Client can support both methods by providing two callbacks. The API also requires an \"update callback\". The IOWA stack takes care of the implementation of the [ Firmware Update Object ][Firmware Update Object] and its associated state machine. The user-provided callbacks are called as illustrated below:","title":"Firmware Update using IOWA"},{"location":"DeviceUpdate/#pull-method","text":"The \"download callback\" and the \"update callback\" should start an independent task to keep the IOWA Client responsive to the LwM2M Server\u2019s requests. Both these callbacks inform the IOWA Stack of their success or failure by calling the API iowa_client_firmware_update_set_status() .","title":"\"Pull\" method"},{"location":"DeviceUpdate/#push-method","text":"The \"write callback\" is called with the Firmware Package received from the Server. As the Firmware Package is usually bigger than the network MTU, it is advised to enable the [ IOWA_COAP_BLOCK_MINIMAL_SUPPORT ][Additional flags] compilation flag. Then the Firmware Package can be received in several chunks. In this case, the \"write callback\" is called several times. However, the data is always provided in sequence with no gaps nor duplicates. Additionally, the flag [ IOWA_FIRMWARE_UPDATE_MAX_BLOCK_INTERVAL ][IOWA_FIRMWARE_UPDATE_MAX_BLOCK_INTERVAL] can be set to define the maximum time in seconds to wait between block reception. If this delay expires, the Firmware Update state machine resets to the Idle state with a Connection Lost error.\\ If this flag is not set, IOWA will wait indefinitely for the next block. This is useful for device with intermittent connectivity. Below an example in pseudo-code of the Client to support both Firmware Update methods without using Multithread: #include \"iowa_client.h\" static void prv_downloadCallback ( char * uri , void * userData , iowa_context_t contextP ) { if ( DOWNLOAD_PACKAGE ( uri )) { iowa_client_firmware_update_set_status ( contextP , IOWA_FW_STATUS_SUCCESSFUL ); } else { // Set the error. Possible value: // - IOWA_FW_STATUS_OUT_OF_STORAGE // - IOWA_FW_STATUS_OUT_OF_MEMORY // - IOWA_FW_STATUS_CONNECTION_LOST // - IOWA_FW_STATUS_INVALID_URI // - IOWA_FW_STATUS_UNSUPPORTED_PROTOCOL iowa_client_firmware_update_set_status ( contextP , /* ERROR */ ); } } static iowa_fw_status_t prv_writeCallback ( iowa_fw_write_cmd_t cmd , size_t dataLength , uint8_t * data , void * userData , iowa_context_t contextP ) { iowa_fw_status_t status ; status = IOWA_FW_STATUS_SUCCESSFUL ; switch ( cmd ) { case IOWA_FW_PACKAGE_RESET : // Reset the package break ; case IOWA_FW_PACKAGE_WRITE : if ( WRITE_PACKAGE ( dataLength , data ) == false ) { // Set the error. Possible value: // - IOWA_FW_STATUS_OUT_OF_STORAGE // - IOWA_FW_STATUS_OUT_OF_MEMORY // - IOWA_FW_STATUS_INTEGRITY_CHECK_FAILURE // - IOWA_FW_STATUS_UNSUPPORTED_TYPE status = /* ERROR */ ; } break ; default : // This should not happen break ; } return status ; } static void prv_updateCallback ( void * userData , iowa_context_t contextP ) { if ( UPDATE_PACKAGE ()) { iowa_client_firmware_update_set_status ( contextP , IOWA_FW_STATUS_SUCCESSFUL ); } else { iowa_client_firmware_update_set_status ( contextP , IOWA_FW_STATUS_UPDATE_FAILED ); } } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); iowa_client_configure ( iowaH , \"IOWA_FU_Client\" , NULL , NULL ); iowa_client_firmware_update_configure ( iowaH , NULL , NULL , prv_downloadCallback , prv_writeCallback , prv_updateCallback , NULL ); iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_server ( iowaH , 1234 ); iowa_close ( iowaH ); return 0 ; }","title":"\"Push\" method"},{"location":"DeviceUpdate/#software-management","text":"In LightweightM2M, the Software Management mechanism is used to install software package and/or activate Software Components to a LwM2M Client. A LwM2M Client supporting Software Management exposes to the LwM2M Server the [ Software Management Object ][Software Management Object]. The [ Software Management Object ][Software Management Object] only allows to install/uninstall a software. To allow the activation/deactivation of a Software Component the LwM2M Client must support [ Software Component Object ][Software Component Object].","title":"Software Management"},{"location":"DeviceUpdate/#software-management-mechanism","text":"The Software Management mechanism is split in two sub-processes : The Package Installation, manages all the operations performed to install a software (Download, Check, Install, Uninstall). The Software Activation, allows the use of an installed software (Activation, Deactivation) if [ Software Component Object ][Software Component Object] is supported.","title":"Software Management mechanism"},{"location":"DeviceUpdate/#package-installation","text":"The Package Installation process is a state machine as summarized below:","title":"Package Installation"},{"location":"DeviceUpdate/#download-software","text":"To download a software of a LwM2M Client, the LwM2M Server has two possible methods: The \"pull\" method : The LwM2M Server writes an URI on the LwM2M Client\u2019s Package URI ( /9/x/3 ). The LwM2M Client then downloads the software Package from this URI using an alternate mechanism e.g. FTP or HTTP. : With this method, LwM2M Client can use a User Name ( /9/x/14 ) and a Password ( /9/x/15 ) for identification. The \"push\" method : The LwM2M Server writes the software Package on the LwM2M Client\u2019s Package ( /9/x/2 ). It is advised for the LwM2M Server to start an observation of the LwM2M Client\u2019s resources State ( /9/x/7 ) and Result ( /9/x/9 ) to be informed of the progress of the LwM2M Client. If the LwM2M Client is in Initial state (value of /9/x/7 is 0 ), the LwM2M Server can start the delivery of the software package. This means that the software is not installed and that the system is ready to start a download: \"pull\" method : The LwM2M Server writes the URI of the software Package in LwM2M Client\u2019s Package URI ( /9/x/3 ). \"push\" method : The LwM2M Server writes the content of the software Package in LwM2M Client\u2019s Package ( /9/x/2 ). In both methods, the State ( /9/x/7 ) change to Downloading ( 1 ), meaning the LwM2M Client starts to download the software Package. The Result ( /9/x/9 ) should be also at Downloading ( 1 ). The LwM2M Server now waits for the State ( /9/x/7 ) to change to Delivered ( 3 ), meaning the download completed successfully and the software Package is valid. The Result ( /9/x/9 ) should indicates Successfully Downloaded ( 3 ). Note that the State ( /9/x/7 ) may change to Downloaded ( 2 ), meaning the download completed successfully. In case of error, the State ( /9/x/7 ) becomes Initial ( 0 ) and the reason of the error is indicated by Result ( /9/x/9 ): 50: Not enough flash memory for the new software package. 51: Out of RAM during downloading process. 52: Connection lost during downloading process. 53: Integrity check failure for new downloaded package. 54: Unsupported package type. 56: Invalid URI (only in \"pull\" method). 57: Device defined update error.","title":"Download software"},{"location":"DeviceUpdate/#installuninstall-software","text":"Once the LwM2M Client is in Delivered state, meaning that it contains the new software Package. The LwM2M Server can start the software installation, by sending an Execute command on Install ( /9/x/4 ): In case of success, the State ( /9/x/7 ) changes to Installed ( 4 ) and the Result ( /9/x/9 ) indicates Successfully Installed ( 2 ). In case of error, the State remains and the Result ( /9/x/9 ) indicates Installation failure ( 58 ). If the LwM2M Client is in Delivered state or Installed state, The LwM2M Server can start the software uninstallation, by sending an Execute command on Uninstall ( /9/x/6 ): In any case, the State ( /9/x/7 ) changes to Initial ( 0 ) and the Result ( /9/x/9 ) indicates Initial value ( 0 ) or Uninstallation failure ( 59 ).","title":"Install/Uninstall software"},{"location":"DeviceUpdate/#software-activation","text":"The Software Activation process is a state machine as summarized below: This state machine is only alive if software is installed, meaning that the State ( /9/x/7 ) has the Installed value ( 4 ). The activation process is only available if at least one [ Software Component Object ][Software Component Object] is link to the [ Software Management Object ][Software Management Object]. This link can be seen with the Software Component Link resource provided ( /9/x/17 ). When the state machine is not alive, its state ( /9/x/12 ) is Inactive state ( false ). To pass in Active state ( true ), the LwM2M Server should send an Execute command on Activate ( /9/x/10 ). To pass in Inactive state ( false ), the LwM2M Server should send an Execute command on Deactivate ( /9/x/11 ). This will activate/deactivate each Software Component linked, if activated resources are provide ( /14/x/3 , /14/x/4 , /14/x/5 ). The state of each Software Component linked can be seen with the activation state resource ( /14/x/5 ). Even if the Software management object activate/deactivate its Software components linked, each Software component object can be activate/deactivate separately with: an Execute command on Activate ( /14/x/3 ) send by the LwM2M Server will set the Software Component state ( /14/x/5 ) to Activate ( true ). an Execute command on Deactivate ( /14/x/4 ) send by the LwM2M Server will set the Software Component state ( /14/x/5 ) to Deactivate ( false ). \\clearpage","title":"Software Activation"},{"location":"DeviceUpdate/#software-management-using-iowa","text":"The iowa_client_enable_software_package_management() API allows an IOWA Client to support the LwM2M Software Management feature. This API allows users to get modifications (create or delete) by LwM2M Server with the \"update callback\". This API requires a delivery callback. It is either a \"download callback\" for the \"pull\" method or a \"write callback\" for the \"push\" method. Of course, the IOWA Client can support both methods by providing two callbacks. The API also requires an \"install callback\". The IOWA stack takes care of the implementation of the [ Software Management Object ][Software Management Object] and its associated state machine. The iowa_client_add_software_package() API must be called to instantiate each Software Management element needed. For a Software Management element, the users-provided callbacks are called as illustrated below: The \"download callback\" is called in case of Write on \"Package URI\" whereas the \"write callback\" is called in case of Write on \"Package\". \"pull\" method : The \"download callback\" should start an independent task to keep the IOWA Client responsive to the LwM2M Server\u2019s requests. This callback inform the IOWA Stack of its success or failure by calling the iowa_client_set_software_package_command_result() API: When packet is downloaded, it should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_DOWNLOADING_SUCCESSFUL result if success or error result. When packet is verified, it should call iowa_client_set_software_package_command_result() with IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL result if success or error result. \"push\" method : As the software management package can be received in several chunks, the \"write callback\" may be called several times. However, the data is always provided in sequence with no gaps nor duplicates. This callback inform the IOWA Stack of its success by returning IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL or failure by returning error result. The \"install callback\" is called in case of Execute on \"Install\" when package has been delivered. The \"install callback\" can also be called in case of Execute on \"Uninstall\" when package has been delivered or installed. The \"install callback\" should start an independent task to keep the IOWA Client responsive to the LwM2M Server\u2019s requests. This callback inform the IOWA Stack of its success or failure by calling the iowa_client_set_software_package_command_result() API. To remove a Software Management element, the iowa_client_remove_software_package() API can be called. To remove the entire Software Management feature, the iowa_client_disable_software_package_management() API can be called. Also, the LwM2M Client can update the state of any Software Management element by calling the iowa_client_software_package_update_state() API. To be able to use the Activation process, Software Components must have been provided. \\clearpage","title":"Software Management using IOWA"},{"location":"DeviceUpdate/#software-component-using-iowa","text":"The iowa_client_enable_software_component() API allows an IOWA Client to support the LwM2M Software Component feature. This API requires an \"activate callback\". The IOWA stack takes care of the implementation of the [ Software Component Object ][Software Component Object] and its associated state machine linked with the [ Software Management Object ][Software Management Object]. For a Software Component element, the users-provided callback is called as illustrated below: The \"activate callback\" is called in case of Execute on \"Activate\" or \"Deactivate\" when package is installed. If linked with a Software Management Object, the users-provided callback can also be called as illustrated below: For each Software Component linked to the Software Management object, the Software Component's \"activate callback\" is called in case of Execute on \"Activate\" or \"Deactivate\" when Software Management object's package is installed. The iowa_client_add_software_component() API must be called to instantiate each Software Component element needed. This API will return id , to link a Software Component to a Software Management, this id must be passed to iowa_client_add_software_package() API at start. To set the Software Component activation state, the iowa_client_software_component_update_state() API can be called. \\clearpage Below an example in pseudo-code of the Client to support both Software Management methods and Software Component methods without using Multithread: #include \"iowa_software_management.h\" #include \"iowa_software_component.h\" static void prv_downloadCallback ( iowa_sensor_t id , const char * uriP , const char * userNameP , const char * passwordP , void * userDataP , iowa_context_t contextP ) { if ( DOWNLOAD_PACKAGE ( uri , username , password )) { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_DOWNLOADING_SUCCESSFUL ); if ( CHECK_PACKAGE ( userInfoP )) { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL ); return ; } else { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_INTEGRITY_CHECK_FAILURE ); return ; } } // Set the error. Possible value: // - IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_STORAGE // - IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_MEMORY // - IOWA_SW_PKG_UPDATE_RESULT_CONNECTION_LOST // - IOWA_SW_PKG_UPDATE_RESULT_INTEGRITY_CHECK_FAILURE // - IOWA_SW_PKG_UPDATE_RESULT_UNSUPPORTED_TYPE // - IOWA_SW_PKG_UPDATE_RESULT_INVALID_URI // - IOWA_SW_PKG_UPDATE_RESULT_UPDATE_FAILED iowa_client_set_software_package_command_result ( contextP , id , /* ERROR */ ); } static iowa_sw_pkg_result_t prv_writeCallback ( iowa_sensor_t id , iowa_sw_pkg_write_cmd_t cmd , size_t dataLength , uint8_t * dataP , void * userDataP , iowa_context_t contextP ) { switch ( cmd ) { case IOWA_SW_PKG_COMMAND_RESET : if ( RESET_PACKAGE () == true ) { return IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL ; } break ; case IOWA_SW_PKG_COMMAND_WRITE : if ( WRITE_PACKAGE ( dataLength , dataP ) == true ) { return IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL ; } break ; default : // This should not happen break ; } // Set the error. Possible value: // - IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_STORAGE // - IOWA_SW_PKG_UPDATE_RESULT_OUT_OF_MEMORY // - IOWA_SW_PKG_UPDATE_RESULT_CONNECTION_LOST // - IOWA_SW_PKG_UPDATE_RESULT_INTEGRITY_CHECK_FAILURE // - IOWA_SW_PKG_UPDATE_RESULT_UNSUPPORTED_TYPE // - IOWA_SW_PKG_UPDATE_RESULT_UPDATE_FAILED return /* ERROR */ ; } static void prv_installCallback ( iowa_sensor_t id , iowa_sw_pkg_install_cmd_t cmd , void * userDataP , iowa_context_t contextP ) { if ( cmd == IOWA_SW_PKG_COMMAND_INSTALL ) { if ( INSTALL_PACKAGE ( userInfoP ) == false ) { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_INSTALLED_FAILURE ); return ; } } else { if ( UNINSTALL_PACKAGE ( userInfoP ) == false ) { iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_UNINSTALLED_FAILURE ); return ; } } iowa_client_set_software_package_command_result ( contextP , id , IOWA_SW_PKG_UPDATE_RESULT_SUCCESSFUL ); } static iowa_status_t prv_activateCallback ( iowa_sensor_t id , bool activationState , void * userDataP , iowa_context_t contextP ) { if ( activationState == true ) { if ( ACTIVATE_PACKAGE ( userInfoP ) == false ) { return IOWA_COAP_400_BAD_REQUEST ; } } else { if ( DEACTIVATE_PACKAGE ( userInfoP ) == false ) { return IOWA_COAP_400_BAD_REQUEST ; } } return IOWA_COAP_NO_ERROR ; } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; iowa_sw_pkg_optional_info_t swMgmt ; iowa_sensor_t softMgmtId ; iowa_sensor_t softCmp1Id ; iowa_sensor_t softCmp2Id ; iowa_sw_cmp_info_t swCmp ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); iowa_client_configure ( iowaH , \"IOWA_SW_Client\" , NULL , NULL ); // Enable software management feature iowa_client_enable_software_package_management ( iowaH , NULL , prv_downloadCallback , prv_writeCallback , prv_installCallback , NULL ); // Add software management instance result = iowa_client_add_software_package ( iowaH , \"soft1\" , \"1.0\" , NULL , & softMgmtId ); // Add software management instance result = iowa_client_add_software_package ( iowaH , \"soft2\" , \"1.0\" , NULL , & softMgmtId ); // Enable software component feature iowa_client_enable_software_component ( iowaH , prv_activateCallback , NULL ); // Add software component instance memset ( & swCmp , 0 , sizeof ( iowa_sw_cmp_info_t )); swCmp . identityP = \"cmp1\" ; swCmp . versionP = \"1.1\" ; iowa_client_add_software_component ( iowaH , & swCmp , false , & softCmp1Id ); // Add software component instance memset ( & swCmp , 0 , sizeof ( iowa_sw_cmp_info_t )); swCmp . packP = ( uint8_t * ) \"cmp2\" ; swCmp . packLength = 4 ; iowa_client_add_software_component ( iowaH , & swCmp , true , & softCmp2Id ); // Add software management instance memset ( & swMgmt , 0 , sizeof ( iowa_sw_pkg_optional_info_t )); swMgmt . swComponentLinkCount = 2 ; swMgmt . swComponentLinkP = ( iowa_sensor_t * ) iowa_system_malloc ( swMgmt . swComponentLinkCount * sizeof ( iowa_sensor_t )); swMgmt . swComponentLinkP [ 0 ] = softCmp1Id ; swMgmt . swComponentLinkP [ 1 ] = softCmp2Id ; result = iowa_client_add_software_package ( iowaH , \"soft3\" , \"1.1\" , & swMgmt , & softMgmtId ); iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) if ( swMgmt . swComponentLinkP != NULL ) { iowa_system_free ( swMgmt . swComponentLinkP ); } iowa_client_disable_software_component ( iowaH ); iowa_client_disable_software_package_management ( iowaH ); iowa_client_remove_server ( iowaH , 1234 ); iowa_close ( iowaH ); return 0 ; }","title":"Software Component using IOWA"},{"location":"EvaluationKit/","text":"IOWA Evaluation Kit \u00b6 Content \u00b6 doc : The IOWA APIs reference document. externals : Open source code used by IOWA. include : The IOWA header files. lib : The IOWA prebuilt libraries. samples : Sample applications. Samples \u00b6 IOWA SDK comes with several sample applications: samples/client : A sample LwM2M Client using IOWA. This client features two IPSO Objects. samples/client_1_1 : A sample LwM2M 1.1 Client over TCP using IOWA. This client features two IPSO Objects. When values are updated, the client performs a data push operation with the IPSO Voltage Object values. samples/custom_object_client : A sample LwM2M Client using IOWA. This client implements a custom LwM2M Object. samples/fw_update_client : A sample LwM2M Client using IOWA with (simulated) Firmware Update capability. samples/bootstrap_client : A sample LwM2M Client using IOWA. This client is configured with only a LwM2M Bootstrap Server. samples/user_security_client : A sample LwM2M Client using IOWA but implementing its security layer. samples/server : A sample LwM2M Server using IOWA. This server listens for client registrations on UDP ports 5683 and 5684 (for DTLS connections). When a LwM2M Client registers, the Server reads the Device Object of the Client and, if possible, sets observations on the IPSO Temperature Object Instances. samples/server_1_1 : A sample LwM2M 1.1 Server using IOWA. This server listens for client registrations on TCP ports 5683 and 5684 (for TLS connections). When a LwM2M Client registers, the Server makes a Read-Composite on the Device and Server Objects of the Client and, if possible, sets observations on the IPSO Temperature Object Instances. samples/bootstrap_server : A sample LwM2M Bootstrap Server using IOWA. This bootstrap server listens for client bootstrap requests on UDP ports 5783 and 5784 (for DTLS connections). When receiving a Bootstrap Request from a LwM2M Client, it provisions a LwM2M Server Account with URL \"coap://127.0.0.1:5683\". Compilation \u00b6 Prerequisites: An x86-64 computer with a Linux distribution installed. The make utility and a C compiler. Go to each sample folder and type the command 'make'. This builds each of the sample programs. Testing \u00b6 Without Security \u00b6 Launch the previously built 'server'. Launch the previously built 'client' on the same computer. With PSK security \u00b6 Launch the 'server' previously built. Edit the samples/client/main.c file to go from: // Add the information of a LwM2M Server to connect to result = iowa_client_add_server ( iowaH , SERVER_SHORT_ID , SERVER_URI , 300 , 0 , IOWA_SEC_NONE ); // or if you want to use a secure connection // result = iowa_client_add_server(iowaH, SERVER_SHORT_ID, SERVER_SECURE_URI, 300, 0, IOWA_SEC_PRE_SHARED_KEY); to: // Add the information of a LwM2M Server to connect to // result = iowa_client_add_server(iowaH, SERVER_SHORT_ID, SERVER_URI, 300, 0, IOWA_SEC_NONE); // or if you want to use a secure connection result = iowa_client_add_server ( iowaH , SERVER_SHORT_ID , SERVER_SECURE_URI , 300 , 0 , IOWA_SEC_PRE_SHARED_KEY ); Rebuild and launch 'client'.","title":"Evaluation Kit"},{"location":"EvaluationKit/#iowa-evaluation-kit","text":"","title":"IOWA Evaluation Kit"},{"location":"EvaluationKit/#content","text":"doc : The IOWA APIs reference document. externals : Open source code used by IOWA. include : The IOWA header files. lib : The IOWA prebuilt libraries. samples : Sample applications.","title":"Content"},{"location":"EvaluationKit/#samples","text":"IOWA SDK comes with several sample applications: samples/client : A sample LwM2M Client using IOWA. This client features two IPSO Objects. samples/client_1_1 : A sample LwM2M 1.1 Client over TCP using IOWA. This client features two IPSO Objects. When values are updated, the client performs a data push operation with the IPSO Voltage Object values. samples/custom_object_client : A sample LwM2M Client using IOWA. This client implements a custom LwM2M Object. samples/fw_update_client : A sample LwM2M Client using IOWA with (simulated) Firmware Update capability. samples/bootstrap_client : A sample LwM2M Client using IOWA. This client is configured with only a LwM2M Bootstrap Server. samples/user_security_client : A sample LwM2M Client using IOWA but implementing its security layer. samples/server : A sample LwM2M Server using IOWA. This server listens for client registrations on UDP ports 5683 and 5684 (for DTLS connections). When a LwM2M Client registers, the Server reads the Device Object of the Client and, if possible, sets observations on the IPSO Temperature Object Instances. samples/server_1_1 : A sample LwM2M 1.1 Server using IOWA. This server listens for client registrations on TCP ports 5683 and 5684 (for TLS connections). When a LwM2M Client registers, the Server makes a Read-Composite on the Device and Server Objects of the Client and, if possible, sets observations on the IPSO Temperature Object Instances. samples/bootstrap_server : A sample LwM2M Bootstrap Server using IOWA. This bootstrap server listens for client bootstrap requests on UDP ports 5783 and 5784 (for DTLS connections). When receiving a Bootstrap Request from a LwM2M Client, it provisions a LwM2M Server Account with URL \"coap://127.0.0.1:5683\".","title":"Samples"},{"location":"EvaluationKit/#compilation","text":"Prerequisites: An x86-64 computer with a Linux distribution installed. The make utility and a C compiler. Go to each sample folder and type the command 'make'. This builds each of the sample programs.","title":"Compilation"},{"location":"EvaluationKit/#testing","text":"","title":"Testing"},{"location":"EvaluationKit/#without-security","text":"Launch the previously built 'server'. Launch the previously built 'client' on the same computer.","title":"Without Security"},{"location":"EvaluationKit/#with-psk-security","text":"Launch the 'server' previously built. Edit the samples/client/main.c file to go from: // Add the information of a LwM2M Server to connect to result = iowa_client_add_server ( iowaH , SERVER_SHORT_ID , SERVER_URI , 300 , 0 , IOWA_SEC_NONE ); // or if you want to use a secure connection // result = iowa_client_add_server(iowaH, SERVER_SHORT_ID, SERVER_SECURE_URI, 300, 0, IOWA_SEC_PRE_SHARED_KEY); to: // Add the information of a LwM2M Server to connect to // result = iowa_client_add_server(iowaH, SERVER_SHORT_ID, SERVER_URI, 300, 0, IOWA_SEC_NONE); // or if you want to use a secure connection result = iowa_client_add_server ( iowaH , SERVER_SHORT_ID , SERVER_SECURE_URI , 300 , 0 , IOWA_SEC_PRE_SHARED_KEY ); Rebuild and launch 'client'.","title":"With PSK security"},{"location":"License/","text":"\\renewcommand{\\abstractname}{License} \\begin{abstract} Any user of the software is presumed to have read his license before using it and to have accepted its terms. By using this software, you acknowledge that you are fully aware that its use is strictly regulated by the license agreement to which it is subject by SAS IOTEROP. The license associated with this version of the software is an evaluation license allowing only internal exploration and prototyping. Any commercial use of the software is strictly subject to the prior obtaining of a different and specific license (commercial license), the terms and conditions of which are defined by SAS IOTEROP. Any use of the software not expressly authorized by SAS IOTEROP may constitute a counterfeit punishable under French and international laws directly engaging the responsibility of its author (Article L335-3 of the French Intellectual Property Code - Berne Convention). \\end{abstract}","title":"License"},{"location":"LoRaWAN/","text":"IOWA over LoRaWAN \u00b6 LoRaWAN is a protocol designed for low power systems and long range communication, to be used by the Internet of Things industry. The LoRaWAN Network architecture can be decomposed into: Endpoint: Low power device such as a sensor device, Gateway: Concentrator which forwards the radio packet received from the Endpoints to the Network Server on alternative protocol (WiFi, Ethernet, Cellular, etc), Network Server: Forwards the received data to the relevant Application Servers and handles the network management such as over-the-air activation, data de-duplication, dynamic frame routing, adaptive rate control, traffic management and administration, Application Server: Interpret the data sent by an Endpoint. When using LwM2M over LoRaWAN, the LoRaWAN Endpoint is always the LwM2M Client and the LwM2M Server is deployed on a LoRaWAN Application Server. Using Lightweight M2M over a LoRaWAN transport requires some adaptation to the CoAP layer as described in the LwM2M 1.1 Transport Technical Specification. IOWA implements these adaptations and the LoRaWAN endpoint can be of any LoRaWAN classes. From the LoRaWAN Endpoint \u00b6 Messages are sent as LoRaWAN confirmed-data messages. When the Endpoint wakes up, it opens a RX window by sending a LoRaWAN packet. If the Endpoint application has no data scheduled for transmission, it can send an empty LoRaWAN unconfirmed-data message instead. Some LoRaWAN implementations do not allow to send empty messages. In such a case, the application can instead call the iowa_client_send_heartbeat API. This API generates a CoAP Empty message which would be silently ignored by the LwM2M Server. \\clearpage endpoint pseudo-code: #include \"iowa_client.h\" #include \"iowa_ipso.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; iowa_device_info_t devInfo ; iowa_sensor_t sensorId ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); devInfo . manufacturer = \"IOTEROP\" ; devInfo . deviceType = \"Example device\" ; devInfo . modelNumber = \"1\" ; devInfo . serialNumber = NULL ; devInfo . hardwareVersion = NULL ; devInfo . softwareVersion = NULL ; iowa_client_configure ( iowaH , \"IOWA_Sample_Client\" , devInfo , NULL ); iowa_client_IPSO_add_sensor ( iowaH , IOWA_IPSO_VOLTAGE , 12.0 , \"V\" , \"Test DC\" , 0.0 , 0.0 , & sensorId ); iowa_client_add_server ( iowaH , 1234 , \"lorawan://12\" , 0 , 0 , IOWA_SEC_NONE ); START_MEASURING_TASKS (); /****************** * \"Main loop\" */ do { // Run for 10 seconds result = iowa_step ( iowaH , 10 ); // Prepare to stand by for 10 minutes result = iowa_flush_before_pause ( iowaH , 600 , NULL ); STAND_BY ( 600 ); // wake-up SEND_EMPTY_LORAWAN_MSG (); } while ( result == IOWA_COAP_NO_ERROR ); STOP_MEASURING_TASKS (); iowa_client_IPSO_remove_sensor ( iowaH , sensorId ); iowa_close ( iowaH ); return 0 ; } When sending a message, as said earlier, the data has to be sent as confirmed-data message. The only exception to this rule is the heartbeat message that should be sent as unconfirmed-data message. The iowa_system_connection_send can determine if the data should be sent as a confirmed-data or unconfirmed-data message by using the macro IOWA_IS_HEARTBEAT_MESSAGE . int iowa_system_connection_send ( void * connP , uint8_t * buffer , size_t length , void * userData ) { if ( IOWA_IS_HEARTBEAT_MESSAGE ( buffer , length )) { return SEND_UNCONFIRMED_DATA ( connP , buffer , length ); } else { return SEND_CONFIRMED_DATA ( connP , buffer , length ); } } From the LoRaWAN Application Server \u00b6 Messages are sent as LoRaWAN confirmed-data messages. The LoRaWAN Network Server takes care of the message delivery to the endpoint. If the LwM2M Server has to be closed, iowa_system_connection_close should remove any pending message for the endpoint from the Network Server message queue.","title":"IOWA over LoRaWAN"},{"location":"LoRaWAN/#iowa-over-lorawan","text":"LoRaWAN is a protocol designed for low power systems and long range communication, to be used by the Internet of Things industry. The LoRaWAN Network architecture can be decomposed into: Endpoint: Low power device such as a sensor device, Gateway: Concentrator which forwards the radio packet received from the Endpoints to the Network Server on alternative protocol (WiFi, Ethernet, Cellular, etc), Network Server: Forwards the received data to the relevant Application Servers and handles the network management such as over-the-air activation, data de-duplication, dynamic frame routing, adaptive rate control, traffic management and administration, Application Server: Interpret the data sent by an Endpoint. When using LwM2M over LoRaWAN, the LoRaWAN Endpoint is always the LwM2M Client and the LwM2M Server is deployed on a LoRaWAN Application Server. Using Lightweight M2M over a LoRaWAN transport requires some adaptation to the CoAP layer as described in the LwM2M 1.1 Transport Technical Specification. IOWA implements these adaptations and the LoRaWAN endpoint can be of any LoRaWAN classes.","title":"IOWA over LoRaWAN"},{"location":"LoRaWAN/#from-the-lorawan-endpoint","text":"Messages are sent as LoRaWAN confirmed-data messages. When the Endpoint wakes up, it opens a RX window by sending a LoRaWAN packet. If the Endpoint application has no data scheduled for transmission, it can send an empty LoRaWAN unconfirmed-data message instead. Some LoRaWAN implementations do not allow to send empty messages. In such a case, the application can instead call the iowa_client_send_heartbeat API. This API generates a CoAP Empty message which would be silently ignored by the LwM2M Server. \\clearpage endpoint pseudo-code: #include \"iowa_client.h\" #include \"iowa_ipso.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; iowa_device_info_t devInfo ; iowa_sensor_t sensorId ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); devInfo . manufacturer = \"IOTEROP\" ; devInfo . deviceType = \"Example device\" ; devInfo . modelNumber = \"1\" ; devInfo . serialNumber = NULL ; devInfo . hardwareVersion = NULL ; devInfo . softwareVersion = NULL ; iowa_client_configure ( iowaH , \"IOWA_Sample_Client\" , devInfo , NULL ); iowa_client_IPSO_add_sensor ( iowaH , IOWA_IPSO_VOLTAGE , 12.0 , \"V\" , \"Test DC\" , 0.0 , 0.0 , & sensorId ); iowa_client_add_server ( iowaH , 1234 , \"lorawan://12\" , 0 , 0 , IOWA_SEC_NONE ); START_MEASURING_TASKS (); /****************** * \"Main loop\" */ do { // Run for 10 seconds result = iowa_step ( iowaH , 10 ); // Prepare to stand by for 10 minutes result = iowa_flush_before_pause ( iowaH , 600 , NULL ); STAND_BY ( 600 ); // wake-up SEND_EMPTY_LORAWAN_MSG (); } while ( result == IOWA_COAP_NO_ERROR ); STOP_MEASURING_TASKS (); iowa_client_IPSO_remove_sensor ( iowaH , sensorId ); iowa_close ( iowaH ); return 0 ; } When sending a message, as said earlier, the data has to be sent as confirmed-data message. The only exception to this rule is the heartbeat message that should be sent as unconfirmed-data message. The iowa_system_connection_send can determine if the data should be sent as a confirmed-data or unconfirmed-data message by using the macro IOWA_IS_HEARTBEAT_MESSAGE . int iowa_system_connection_send ( void * connP , uint8_t * buffer , size_t length , void * userData ) { if ( IOWA_IS_HEARTBEAT_MESSAGE ( buffer , length )) { return SEND_UNCONFIRMED_DATA ( connP , buffer , length ); } else { return SEND_CONFIRMED_DATA ( connP , buffer , length ); } }","title":"From the LoRaWAN Endpoint"},{"location":"LoRaWAN/#from-the-lorawan-application-server","text":"Messages are sent as LoRaWAN confirmed-data messages. The LoRaWAN Network Server takes care of the message delivery to the endpoint. If the LwM2M Server has to be closed, iowa_system_connection_close should remove any pending message for the endpoint from the Network Server message queue.","title":"From the LoRaWAN Application Server"},{"location":"LoggerAPI/","text":"\\clearpage Logger Component \u00b6 The functions explained below are defined inside the file include/iowa_logger.h . Presentation \u00b6 To use your logger layer, you have to set the define [ IOWA_LOGGER_USER ][IOWA_LOGGER_USER] and implement the following functions. void iowa_log ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message ); void iowa_log_arg ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , ...); void iowa_log_buffer ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , const uint8_t * buffer , size_t bufferLength ); void iowa_log_arg_buffer ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , const uint8_t * buffer , size_t bufferLength , ...); \\clearpage Functions \u00b6 iowa_log \u00b6 Prototype \u00b6 void iowa_log ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message ); Description \u00b6 iowa_log() writes a log message to the output. Arguments \u00b6 part : Log part. level : Log level. functionName : Name of the function from where the Log has been called. line : Line from where the Log has been called. message : String to display. Return Value \u00b6 None. Header File \u00b6 iowa_logger.h \\clearpage iowa_log_arg \u00b6 Prototype \u00b6 void iowa_log_arg ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , ...); Description \u00b6 iowa_log_arg() writes a log message to the output with specifier arguments. Arguments \u00b6 part : Log part. level : Log level. functionName : Name of the function from where the Log has been called. line : Line from where the Log has been called. message : String to display. ... : Format specifiers which are replaced by the values specified in additional arguments. Return Value \u00b6 None. Header File \u00b6 iowa_logger.h \\clearpage iowa_log_buffer \u00b6 Prototype \u00b6 void iowa_log_buffer ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , const uint8_t * buffer , size_t bufferLength ); Description \u00b6 iowa_log_buffer() writes a buffer with a log message to the output. Arguments \u00b6 part : Log part. level : Log level. functionName : Name of the function from where the Log has been called. line : Line from where the Log has been called. message : String to display. buffer : Buffer. bufferLength : Buffer size. Return Value \u00b6 None. Header File \u00b6 iowa_logger.h \\clearpage iowa_log_arg_buffer \u00b6 Prototype \u00b6 void iowa_log_arg_buffer ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , const uint8_t * buffer , size_t bufferLength , ...); Description \u00b6 iowa_log_arg_buffer() writes a buffer with a log message to the output with specifier arguments. Arguments \u00b6 part : Log part. level : Log level. functionName : Name of the function from where the Log has been called. line : Line from where the Log has been called. message : String to display. buffer : Buffer. bufferLength : Buffer size. ... : Format specifiers which are replaced by the values specified in additional arguments. Return Value \u00b6 None. Header File \u00b6 iowa_logger.h","title":"LoggerAPI"},{"location":"LoggerAPI/#logger-component","text":"The functions explained below are defined inside the file include/iowa_logger.h .","title":"Logger Component"},{"location":"LoggerAPI/#presentation","text":"To use your logger layer, you have to set the define [ IOWA_LOGGER_USER ][IOWA_LOGGER_USER] and implement the following functions. void iowa_log ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message ); void iowa_log_arg ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , ...); void iowa_log_buffer ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , const uint8_t * buffer , size_t bufferLength ); void iowa_log_arg_buffer ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , const uint8_t * buffer , size_t bufferLength , ...); \\clearpage","title":"Presentation"},{"location":"LoggerAPI/#functions","text":"","title":"Functions"},{"location":"LoggerAPI/#iowa_log","text":"","title":"iowa_log"},{"location":"LoggerAPI/#prototype","text":"void iowa_log ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message );","title":"Prototype"},{"location":"LoggerAPI/#description","text":"iowa_log() writes a log message to the output.","title":"Description"},{"location":"LoggerAPI/#arguments","text":"part : Log part. level : Log level. functionName : Name of the function from where the Log has been called. line : Line from where the Log has been called. message : String to display.","title":"Arguments"},{"location":"LoggerAPI/#return-value","text":"None.","title":"Return Value"},{"location":"LoggerAPI/#header-file","text":"iowa_logger.h \\clearpage","title":"Header File"},{"location":"LoggerAPI/#iowa_log_arg","text":"","title":"iowa_log_arg"},{"location":"LoggerAPI/#prototype_1","text":"void iowa_log_arg ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , ...);","title":"Prototype"},{"location":"LoggerAPI/#description_1","text":"iowa_log_arg() writes a log message to the output with specifier arguments.","title":"Description"},{"location":"LoggerAPI/#arguments_1","text":"part : Log part. level : Log level. functionName : Name of the function from where the Log has been called. line : Line from where the Log has been called. message : String to display. ... : Format specifiers which are replaced by the values specified in additional arguments.","title":"Arguments"},{"location":"LoggerAPI/#return-value_1","text":"None.","title":"Return Value"},{"location":"LoggerAPI/#header-file_1","text":"iowa_logger.h \\clearpage","title":"Header File"},{"location":"LoggerAPI/#iowa_log_buffer","text":"","title":"iowa_log_buffer"},{"location":"LoggerAPI/#prototype_2","text":"void iowa_log_buffer ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , const uint8_t * buffer , size_t bufferLength );","title":"Prototype"},{"location":"LoggerAPI/#description_2","text":"iowa_log_buffer() writes a buffer with a log message to the output.","title":"Description"},{"location":"LoggerAPI/#arguments_2","text":"part : Log part. level : Log level. functionName : Name of the function from where the Log has been called. line : Line from where the Log has been called. message : String to display. buffer : Buffer. bufferLength : Buffer size.","title":"Arguments"},{"location":"LoggerAPI/#return-value_2","text":"None.","title":"Return Value"},{"location":"LoggerAPI/#header-file_2","text":"iowa_logger.h \\clearpage","title":"Header File"},{"location":"LoggerAPI/#iowa_log_arg_buffer","text":"","title":"iowa_log_arg_buffer"},{"location":"LoggerAPI/#prototype_3","text":"void iowa_log_arg_buffer ( uint8_t part , uint8_t level , const char * functionName , unsigned int line , const char * message , const uint8_t * buffer , size_t bufferLength , ...);","title":"Prototype"},{"location":"LoggerAPI/#description_3","text":"iowa_log_arg_buffer() writes a buffer with a log message to the output with specifier arguments.","title":"Description"},{"location":"LoggerAPI/#arguments_3","text":"part : Log part. level : Log level. functionName : Name of the function from where the Log has been called. line : Line from where the Log has been called. message : String to display. buffer : Buffer. bufferLength : Buffer size. ... : Format specifiers which are replaced by the values specified in additional arguments.","title":"Arguments"},{"location":"LoggerAPI/#return-value_3","text":"None.","title":"Return Value"},{"location":"LoggerAPI/#header-file_3","text":"iowa_logger.h","title":"Header File"},{"location":"LwM2MOverview/","text":"LwM2M Overview \u00b6 The Lightweight Machine To Machine designed by the Open Mobile Alliance is a device management protocol for the Internet of Things (IoT). LwM2M Concepts \u00b6 LwM2M Client/Device \u00b6 The LwM2M Client/Device is the entity being managed by the LwM2M Server. The LwM2M Client presents resources for the LwM2M Server to manipulate. LwM2M Server \u00b6 The LwM2M Server is the entity managing the LwM2M Devices. It can Read, Write, Execute, Create or Delete the Devices resources. The LwM2M Server URI can have one of the following formats: \"coap://{hostname}[:{port}]\" for unsecure UDP transport \"coaps://{hostname}[:{port}]\" for secure UDP transport (using DTLS) \"coap+tcp://{hostname}[:{port}]\" for unsecure TCP transport \"coaps+tcp://{hostname}[:{port}]\" for secure TCP transport (using TLS) \"sms://{msisdn number}\" for SMS binding in binary mode \"lorawan://{FPort}\" for LoRaWAN binding with FPort between 1 and 255 For UDP and TCP transports, if {port} is not present, the default port is used: 5683 for communication without security 5684 for secure communication LwM2M Bootstrap Server \u00b6 The LwM2M Bootstrap Server is a special [LwM2M Server][LwM2M Server]. It is the only Server allowed to provision or delete Server Accounts on the LwM2M Devices. It can Read (LwM2M 1.1), Write, Create and Delete the Devices resources. LwM2M Resource \u00b6 A LwM2M Resource is a data item presented by the LwM2M Device. A resource has a data type, a list of allowed operations and a unique URI. Data types are defined in Lightweight M2M as follows: signed integer, unsigned integer, float, boolean, UTF-8 string, core link string, opaque binary, Unix time, reference to a LwM2M Object. A resource can also be an array of the mentioned data types. Operations on resources are Read, Write and Execute. LwM2M Objects \u00b6 The LwM2M Objects are a group of Device resources essential for some Device features such as firmware update, connectivity monitoring, physical sensor, etc. Standardized LwM2M Objects contain mandatory resources to support and optional resources to implement. A LwM2M Device can have several instances of the same LwM2M Object. All the Device resources are part of a LwM2M Object. LwM2M Object Instance \u00b6 Some LwM2M Objects are defined as multi-instance objects, meaning that a LwM2M Device can have several instances of the same LwM2M Object. These instances are identified by a numerical instance ID. When a LwM2M Object is defined as a single-instance, the instance ID is always 0. LwM2M URI \u00b6 Resources and Objects have well-known IDs. The URI to a LwM2M resource is in the form: Object_ID [\"/\" Object_Instance_ID [\"/\" Resource_ID [\"/\" Resource_Instance_ID]]] An URI can address an object, an object instance, a resource or a resource instance (i.e. an element when the resource is an array). Server Account \u00b6 A Server Account is a set of data enabling a LwM2M Device to connect to a LwM2M Server. It includes the Server URI and the Security Keys to use. Bootstrap \u00b6 A Bootstrap is the process by which the Device retrieves the Server Accounts. The information can come from factory settings, a SmartCard, or a LwM2M Bootstrap Server. Registration \u00b6 A LwM2M Server can only manage Devices registered with it. When registering with the Bootstrap Server, the Device communicates only its unique ID. When registering with the LwM2M Server, the Device can communicate: its unique ID, its lifetime, the list of LwM2M Objects implemented on the Device, its MSISDN, whether the Device requires Queue Mode or not. Observation \u00b6 The LwM2M Server can subscribe to one or several readable Device resources. When the value of the resource changes, the Device sends a Notification message to the Server containing the new value of the resource. Lifetime \u00b6 The Lifetime is the validity period of a LwM2M Device registration to the LwM2M Server. When this lifetime expires, the Server should no longer try to manage the Device. The Device sends Registration Update messages to the Server to renew its registration validity period. Queue Mode \u00b6 Devices may go in stand-by mode and thus not be reachable by the LwM2M Servers at any time. To cope with this, the Device requests the Server to operate in Queue Mode. In this mode, the Device will initiate the communication with the Server (when sending a Notification or a Registration Update message). In the meantime, the Server is expected to queue its requests (hence the name). SMS Trigger \u00b6 A SMS Trigger is a special SMS sent to the Device. Upon reception of this SMS, the Device will either register to the Server or send a Registration Update message. LwM2M Operations Overview \u00b6 Bootstrap \u00b6 When an endpoint is registered to a LwM2M Bootstrap Server, it can be managed by performing LwM2M operations on the endpoint's resources. The LwM2M operations are: Bootstrap Finish, Bootstrap Read, Bootstrap Write, Bootstrap Delete, Bootstrap Discover. Bootstrap Request \u00b6 The first action of LwM2M Client is to connect to the LwM2M Bootstrap Server and ask a Bootstrap Request. The Bootstrap Request message contains an endpoint\u2019s unique ID. Bootstrap Finish \u00b6 A Bootstrap Finish operation is sent by the LwM2M Bootstrap Server. Upon reception of this operation, the LwM2M Client will perform a Bootstrap Consistency check to verify the Bootstrap information received from the LwM2M Bootstrap Server is valid. This means at least one LwM2M server is configured on the LwM2M Client. Bootstrap Read \u00b6 In LwM2M 1.1 or later, a Bootstrap Read operation can target the LwM2M Objects Access Control List or Server, or their LwM2M Object Instances. The endpoint returns data encoded in either TLV, JSON, SenML CBOR, or SenML JSON. Bootstrap Write \u00b6 A Bootstrap Write operation targets a LwM2M Object Instance. It contains data encoded in either TLV or JSON. The payload does not need to contain values for all the Object's resources. In LwM2M 1.1 or in later version, it contains data encoded in either SenML CBOR or SenML JSON. Bootstrap Delete \u00b6 A Bootstrap Delete operation can target the root path, a LwM2M Object or a LwM2M Instance Object. Bootstrap Discover \u00b6 A Bootstrap Discover operation can target the root path or a LwM2M Object. The endpoint returns only the list of Objects and Object Instances with some attributes: LwM2M Enabler version (\"lwm2m=\"), Short Server ID (\"ssid=\"), and LwM2M Server URI (\"uri=\"). Registration \u00b6 Initial Registration \u00b6 The first action of LwM2M Client is to register to the LwM2M Server. The registration message contains an endpoint\u2019s unique ID and information about its capabilities (in the form of LwM2M Objects). The registration message also contains a lifetime parameter. When this lifetime expires, the LwM2M Server cancels the LwM2M Client registration. The LwM2M Server replies with a \"location\". This location is a handle to the registration. The endpoint uses this handle to update or cancel its registration. Registration Update \u00b6 To keep its registration active or in case the list of LwM2M Objects is modified, the endpoint sends a Registration Update message. Upon reception of this message, the LwM2M Server resets its internal lifetime timer. De-registration \u00b6 To cancel its registration, the LwM2M Client sends a De-registration message. The LwM2M Server may also automatically cancel an endpoint's registration if the registration lifetime expires. Device Management and Service Enablement \u00b6 When an endpoint is registered to a LwM2M Server, it can be managed by performing LwM2M operations on the endpoint's resources. The LwM2M operations are: Read, Write, Execute, Discover, Create, Delete, Read composite, Write composite. Read \u00b6 A Read operation can target a LwM2M Object, a LwM2M Object Instance or a LwM2M Resource. The endpoint returns data encoded in either TLV or JSON. For a single resource, a text encoding is possible. In LwM2M 1.1 or later, the endpoint returns data encoded in either SenML CBOR or SenML JSON. Write \u00b6 A Write operation targets a LwM2M Object Instance. It contains data encoded in either TLV or JSON. The payload does not need to contain values for all the Object's resources. In LwM2M 1.1 or in later version, it contains data encoded in either SenML CBOR or SenML JSON. Execute \u00b6 An Execute operation can only target a LwM2M Resource. Discover \u00b6 A Discover operation can target a LwM2M Object, a LwM2M Object Instance or a LwM2M Resource. Create \u00b6 A Create operation can target a LwM2M Object. It creates a new Object Instance. Delete \u00b6 A Delete operation can target a LwM2M Object Instance. It deletes an Object Instance. Read composite \u00b6 In LwM2M 1.1 or in later version, a Read composite operation can selectively Read a number of Resources, and/or Resource Instances of different Objects in a single request. The endpoint returns data encoded in either SenML CBOR or SenML JSON. Write composite \u00b6 In LwM2M 1.1 or in later version, a Write composite operation can update values of a number of different Resources across different Instances of one or more Objects in a single request. It contains data encoded in either SenML CBOR or SenML JSON. Information Reporting \u00b6 When a LwM2M Client is registered to a LwM2M Server, its resources can be observed. Whenever the value of the resource changes, the LwM2M Client sends a notification to the LwM2M Server. Moreover in LwM2M 1.1, the Client can send data to the LwM2M Server without initial solicitation. The LwM2M operations are: Observation, Observation composite, Cancel Observation, Write attributes, Send. Observation \u00b6 An observation can target a LwM2M Object, a LwM2M Object Instance or a LwM2M Resource. Observe composite \u00b6 In LwM2M 1.1 or in later version, a Observe composite operation can initiate observations or selectively read a group of Object, Object Instance, Resources, and/or Resource Instances of different Objects in a single request. The endpoint returns data encoded in either SenML CBOR or SenML JSON. Notification \u00b6 When an observed resource's value changes, the endpoint sends a notification message to the LwM2M Server. Cancel Observation \u00b6 The LwM2M Server can cancel an on-going observation. Write attributes \u00b6 The LwM2M Server can set the parameters of an observation. The following attributes are: Name Level Description pmin Object, Object Instance, Resource The minimum period in seconds to wait between notifications. pmax Object, Object Instance, Resource The maximum period in seconds to wait between notifications. gt Numerical Resource An upper threshold. A notification is sent when the resource value crosses this threshold. lt Numerical Resource A lower threshold. A notification is sent when the resource value crosses this threshold. st Numerical Resource A minimum difference in a resource value for a notification to be sent. epmin Object, Object Instance, Resource The minimum sample time in seconds for the observed sensor in LwM2M 1.1 or in later version. epmax Object, Object Instance, Resource The maximum sample time in seconds for the observed sensor in LwM2M 1.1 or in later version. Setting an attribute is in the form Name \"=\" value with some constraints: lt value < gt value lt value + 2 * st value < gt value If pmax < pmin , pmax is ignored epmax > epmin Clearing an attribute is in the form Name . Examples \u00b6 Receiving a notification every minute at most even if the observed URI did not change: \"pmax=60\" . Receiving only one notification per hour even if the observed URI changed several times per minute: \"pmin=3600\" . Receiving exactly one notification every sixty seconds: \"pmin=59&pmax=60\" . Receiving a notification when the resource value exceeds 95 or falls below 10, and when the resource value returns below 95 or above 10: \"lt=10&gt=95\" . Clearing the previously set minimum period and setting a maximum period of five minutes: \"pmin&pmax=300\" . Send \u00b6 In LwM2M 1.1 or in later version, a Send operation is used by the LwM2M Client to send data to the LwM2M Server without explicit request by that Server. It contains data encoded in either SenML CBOR or SenML JSON. Later in the documentation, the Send operation is called a Data Push. Standardized LwM2M Objects \u00b6 The list of publics LwM2M Objects is available at the OMNA Registry: http://www.openmobilealliance.org/wp/OMNA/LwM2M/LwM2MRegistry.html Security Object \u00b6 LwM2M Registry for Object 0 This object provides the keying material of a LwM2M Client appropriate to access a specified LwM2M Server. One Object Instance should address a LwM2M Bootstrap-Server. ID Resource Name Access Type Mandatory Type Description 0 LwM2M Server URI Yes String Uniquely identifies the LwM2M Server or LwM2M Bootstrap-Server. The format of the CoAP URI is defined in Section 6 of RFC 7252. 1 Bootstrap-Server Yes Boolean Determines if the current instance concerns a LwM2M Bootstrap-Server (true) or a standard LwM2M Server (false). 2 Security Mode Yes Integer Determines which UDP payload security mode is used. 3 Public Key or Identity Yes Opaque Stores the LwM2M Client\u2019s Certificate (Certificate mode), public key (RPK mode) or PSK Identity (PSK mode). 4 Server Public Key Yes Opaque Stores the LwM2M Server\u2019s or LwM2M Bootstrap-Server\u2019s Certificate (Certificate mode), public key (RPK mode). 5 Secret Key Yes Opaque Stores the secret key or private key of the security mode. 6 SMS Security Mode No Integer Determines which SMS security mode is used. 7 SMS Binding Key Parameters No Opaque Stores the KIc, KID, SPI and TAR. 8 SMS Binding Secret Key(s) No Opaque Stores the values of the key(s) for the SMS binding. 9 LwM2M Server SMS Number No String MSISDN used by the LwM2M Client to send messages to the LwM2M Server via the SMS binding. 10 Short Server ID No Integer This identifier uniquely identifies each LwM2M Server configured for the LwM2M Client. 11 Client Hold Off Time No Integer Relevant information for a Bootstrap-Server only. 12 Bootstrap-Server Account Timeout No Integer The LwM2M Client MUST purge the LwM2M Bootstrap-Server Account after the timeout value given by this resource. The lowest timeout value is 1. 13 Matching Type No Unsigned Integer The Matching Type Resource specifies how the certificate or raw public key in in the Server Public Key is presented. 14 SNI No String This resource holds the value of the Server Name Indication (SNI) value to be used during the TLS handshake. 15 Certificate Usage No Unsigned Integer The Certificate Usage Resource specifies the semantic of the certificate. 16 DTLS/TLS Ciphersuite No Unsigned Integer It instructs the TLS/DTLS client to propose the indicated ciphersuite(s) in the ClientHello of the handshake 17 OSCORE Security Mode No Object link It provides a link to the OSCORE Object Instance. Server Object \u00b6 LwM2M Registry for Object 1 This object provides the data related to a LwM2M Server. A Bootstrap-Server has no such an Object Instance associated to it. ID Resource Name Access Type Mandatory Type Description 0 Short Server ID R Yes Integer Used as link to associate server Object Instance. 1 Lifetime RW Yes Integer Specify the lifetime of the registration in seconds. 2 Default Minimum Period RW No Integer The default value the LwM2M Client should use for the Minimum Period of an Observation in the absence of this parameter being included in an Observation. 3 Default Maximum Period RW No Integer The default value the LwM2M Client should use for the Maximum Period of an Observation in the absence of this parameter being included in an Observation. 4 Disable E No If this Resource is executed, this LwM2M Server Object is disabled for a certain period defined in the Disabled Timeout Resource. 5 Disable Timeout RW No Integer A period to disable the Server. 6 Notification Storing When Disabled or Offline RW Yes Boolean If true, the LwM2M Client stores \"Notify\" operations to the LwM2M Server while the LwM2M Server account is disabled or the LwM2M Client is offline. 7 Binding RW Yes String This Resource defines the transport binding configured for the LwM2M Client. 8 Registration Update Trigger E Yes If this Resource is executed the LwM2M Client MUST perform an \"Update\" operation with this LwM2M Server using that transport for the Current Binding Mode. 9 Bootstrap-Request Trigger E No If this Resource is executed the LwM2M Client MUST initiate a \"Client Initiated Bootstrap\" procedure in using the LwM2M Bootstrap-Server Account. 10 APN Link RW No Object link It provides a link to the APN connection profile Object Instance (OMNA registered Object ID:11) to be used to communicate with this server. 11 TLS-DTLS Alert Code R No Unsigned Integer It contains the most recent TLS / DTLS alert message received from the LwM2M Server. 12 Last Bootstrapped R No Time It represents the last time that the bootstrap server updated this LwM2M Server Account. 13 Registration Priority Order No Unsigned Integer The LwM2M Client sequences the LwM2M Server registrations in increasing order of this value. 14 Initial Registration Delay Timer No Unsigned Integer The delay before registration is attempted for this LwM2M Server based upon the completion of registration of the previous LwM2M Server in the registration order. 15 Registration Failure Block No Boolean Prevent or not the registration on the next LwM2M Server when the registration fails to connect with this LwM2M server. 16 Bootstrap on Registration Failure No Boolean Initiate a Bootstrap Request or not when the registration fails to connect with this LwM2M server. 17 Communication Retry Count No Unsigned Integer The number of successive communication attempts before which a communication sequence is considered as failed. 18 Communication Retry Timer No Unsigned Integer The delay between successive communication attempts in a communication sequence. 19 Communication Sequence Delay Timer No Unsigned Integer The delay between successive communication sequences. 20 Communication Sequence Retry Count No Unsigned Integer The number of successive communication sequences before which a registration attempt is considered as failed. 21 Trigger RW No Boolean Using the Trigger Resource a LwM2M Client can indicate whether it is reachable over SMS (value set to 'true') or not (value set to 'false'). 22 Preferred Transport RW No String When the LwM2M client supports multiple transports, it MAY use this transport to initiate a connection. 23 Mute Send RW No Boolean De-activated the LwM2M Client Send command capability. Access Control List Object \u00b6 LwM2M Registry for Object 2 This object is used to check whether the LwM2M Server has access right for performing an operation. ID Resource Name Access Type Mandatory Type Description 0 Object ID R Yes Integer Used as link to associate Object which the access right is applicable. 1 Object Instance ID R Yes Integer Used as link to associate Object Instance which the access right is applicable. 2 ACL RW No Integer Set the access right for the corresponding LwM2M Servers. 3 Access Control Owner RW Yes Integer Short Server ID of a LwM2M Server. Only this LwM2M Server can manage the Resources of this Object Instance. Device Object \u00b6 LwM2M Registry for Object 3 This object contains the device information: model, manufacturer, serial number, power source type, battery level, etc... It also contains a resource allowing the Server to reboot the Device. ID Resource Name Access Type Mandatory Type Description 0 Manufacturer R No String Human readable manufacturer name 1 Model Number R No String A model identifier (manufacturer specified string) 2 Serial Number R No String Serial Number 3 Firmware Version R No String Current firmware version of the Device. 4 Reboot E Yes none Reboot the LwM2M Device. 5 Factory Reset E No none Perform factory reset of the LwM2M Device to make the LwM2M Device to go through initial deployment sequence where provisioning and bootstrap sequence is performed. 6 Available Power Sources R No Integer array Available power sources of the Device. 7 Power Source Voltage R No Integer array Present voltage for each Available Power Sources. 8 Power Source Current R No Integer array Present current for each Available Power Sources. 9 Battery Level R No Integer Contains the current battery level as a percentage. 10 Memory Free R No Integer Estimated current available amount of storage space in the Device (expressed in kilobytes). 11 Error Code R Yes Integer array List of errors experienced by the Device. 12 Reset Error Code E No none Delete all error codes in the previous resource. 13 Current Time R/W No Time Current UNIX time of the LwM2M Client. 14 UTC Offset R/W No String Indicates the UTC offset currently in effect for this LwM2M Device. 15 Timezone R/W No String Indicates in which time zone the LwM2M Device is located. 16 Supported Bindings R Yes String Indicates which transports are supported by the Device. 17 Device Type R No String Type of the device (manufacturer specified string). 18 Hardware Version R No String Current hardware version of the device. 19 Software Version R No String Current software version of the device. 20 Battery Status R No Integer Status of the Device battery (normal, charging, etc...) 21 Memory Total R No Integer Total amount of storage space in the Device (expressed in kilobytes). 22 ExtDevInfo R No Object link Reference to a vendor specific object containing device information. Connectivity Monitoring Object \u00b6 LwM2M Registry for Object 4 This object provides high-level information on the current network type, signal strength, IP address, etc\u2026 ID Resource Name Access Type Mandatory Type Description 0 Network Bearer R Yes Integer The network bearer used for the current LwM2M communication session. 1 Available Network Bearer R Yes Integer array List of current available network bearer. 2 Radio Signal Strength R Yes Integer The average value of the received signal strength. 3 Link Quality R No Integer The received link quality. 4 IP Addresses R Yes String array The IP addresses assigned to the connectivity interface. 5 Router IP Addresses R No String array The IP addresses of the next-hop IP routers. 6 Link Utilization R No Integer The average utilization of the link in %. 7 APN R No String array Access Point Names in case Network Bearer Resource is a Cellular Network. 8 Cell ID R No Integer Serving Cell ID in case Network Bearer Resource is a Cellular Network. 9 SMNC R No Integer Serving Mobile Network Code. 10 SMCC R No Integer Serving Mobile Country Code. 11 SignalSNR R No Integer Signal to Interference plus Noise Ratio SINR is the ratio of the strength of the received signal to the strength of the received interference signal. 12 LAC R No Integer Location Area Code in case Network Bearer Resource is a Cellular Network. Firmware Update Object \u00b6 LwM2M Registry for Object 5 This object allows to update the firmware of the device. The firmware package can either be pushed by the Server to the Device or the Device can download it using the provided URI. ID Resource Name Access Type Mandatory Type Description 0 Package W Yes Opaque The firmware package pushed by the Server. 1 Package URI R/W Yes String The URI from where the Device can download the firmware package. 2 Update E Yes none Updates the Device firmware by using the firmware package. 3 State R Yes Integer Indicates current state with respect to this firmware update. 5 Update Result R Yes Integer Contains the result of downloading or updating the firmware. 6 PkgName R No String The name of the Firmware Package. 7 PkgVersion R No String The version of the Firmware package. 8 Firmware Update Protocol Support R No Integer The download protocols the Device implements. 9 Firmware Update Delivery Method R Yes Integer The delivery methods the Device supports. Location Object \u00b6 LwM2M Registry for Object 6 This object contains information on the device position and speed. ID Resource Name Access Type Mandatory Type Description 0 Latitude R Yes Float The decimal notation of latitude. 1 Longitude R Yes Float The decimal notation of longitude. 2 Altitude R No Float The decimal notation of altitude in meters above sea level. 3 Radius R No Float The size in meters of a circular area around a point of geometry. 4 Velocity R No Opaque The velocity in the Device. 5 Timestamp R No Time The timestamp of when the location measurement was performed. 6 Speed R No Float The speed of the Device in meters per second. Connectivity Statistics Object \u00b6 LwM2M Registry for Object 7 This object collects statistics on the network usage. ID Resource Name Access Type Mandatory Type Description 0 SMS Tx Counter R No Integer The total number of SMS successfully transmitted during the collection period. 1 SMS Rx Counter R No Integer The total number of SMS successfully received during the collection period. 2 Tx Data R No Integer The total amount of IP data transmitted during the collection period. 3 Rx Data R No Integer The total amount of IP data received during the collection period. 4 Max Message Size R No Integer The maximum IP message size that is used during the collection period. 5 Average Message Size R No Integer The average IP message size that is used during the collection period. 6 Start E Yes none Start to collect information. 7 Stop E Yes none Stop collecting information. 8 Collection Period R/W No Integer The default collection period in seconds. Software Management Object \u00b6 LwM2M Registry for Object 9 This object allows to update the software of the device. The software package can either be pushed by the Server to the Device or the Device can download it using the provided URI. ID Resource Name Access Type Mandatory Type Description 0 PkgName R Yes String Name of the software package. 1 PkgVersion R Yes String Version of the software package. 2 Package W No Opaque The software package pushed by the Server. 3 Package URI W No String The URI from where the Device can download the software package. 4 Install E Yes none Install the software package. 5 Checkpoint R No Objlink Link to a Checkpoint object which allows to specify conditions/dependencies for a software update. 6 Uninstall E Yes none Uninstall the software package. 7 Update State R/W No Boolean Indicates current state with respect to this software update. 8 Update Supported Object R Yes Integer Indicates if the LwM2M Client MUST inform the registered LwM2M Servers of Objects and Object Instances parameter by sending an Update or Registration message after the software update operation. 9 Update Result R Yes Integer Contains the result of downloading or updating the software. 10 Activate E Yes none Activate the previously installed software package. 11 Deactivate E Yes none Deactivate the previously installed software package. 12 Activation State R Yes Boolean Indicate the current activation state of the software. 13 User Name W No String User name for access to software Update Package in pull mode. 14 Password W No String Password for access to software Update Package in pull mode. 15 Software Component Link R No Objlink Reference to SW Components downloaded and installed in scope of the present SW Update Package. Cellular Connectivity Object \u00b6 LwM2M Registry for Object 10 This object is used to configure the cellular connectivity of the Device. ID Resource Name Access Type Mandatory Type Description 11 Activated Profile Names R Yes String array Links to instances of the \"APN connection profile\" object. 0 SMSC address R/W No String E.164 address of SMSC. 1 Disable radio period R/W No Integer Time period for which the device shall disconnect from cellular radio. 2 Module activation code R/W No String AT command to activate the module. 3 Vendor specific extensions R No Object Link Link to a vendor specific object. 4 PSM Timer R/W No Integer Power saving mode timer. 5 Active Timer R/W No Integer Active timer = T3324 as defined in [3GPP-TS_24.008]. 6 Serving PLMN Rate control R No Integer Maximum the number of allowed uplink PDU transmissions per 6 minute interval. 7 eDRX parameters for Iu mode R/W No Opaque Extended DRX parameters (Paging Time Window and eDRX value) for Iu mode. 8 eDRX parameters for WB-S1 mode R/W No Opaque Extended DRX parameters (Paging Time Window and eDRX value) for WB-S1 mode. 9 eDRX parameters for NB-S1 mode R/W No Opaque Extended DRX parameters (Paging Time Window and eDRX value) for NB-S1 mode. 10 eDRX parameters for A/Gb mode R/W No Opaque Extended DRX parameters (Paging Time Window and eDRX value) for A/Gb mode. APN Connection Profile Object \u00b6 LwM2M Registry for Object 11 This object specifies resources to enable a device to connect to an APN. ID Resource Name Access Type Mandatory Type Description 0 Profile name R/W Yes String Human-readable identifier. 1 APN R/W No String Presented to network during connection to PDN. 2 Auto select APN by device R/W No Boolean Enables the device to choose an APN according to a device specific algorithm. 3 Enable status R/W No Boolean Connection is activated or not. 4 Authentication Type R/W Yes Integer . 5 User Name R/W No String . 6 Secret R/W No String . 7 Reconnect Schedule R/W No String Comma separated list of retry delay values in seconds. 8 Validity (MCC, MNC) R/W No String array Coma separated mobile country code, then mobile network code. 9 Connection establishment time R No Time array UTC time of connection request. 10 Connection establishment result R No Integer array . 11 Connection establishment reject cause R No Integer array Reject cause, see [3GPP-TS_24.008, 3GPP-TS_24.301]. 12 Connection end time R No Time array UTC time of connection end. 13 TotalBytesSent R No Integer array Rolling counter for total number of bytes sent via this interface since last device reset. 14 TotalBytesReceived R No Integer Rolling counter for total number of bytes received via this interface since last device reset. 15 IP address R/W No String array IP addresses. 16 Prefix length R/W No String array Associated with IPv6 addresses. 17 Subnet mask R/W No String array Subnet masks. 18 Gateway R/W No String array Gateways. 19 Primary DNS address R/W No String array Primary DNS addresses. 20 Secondary DNS address R/W No String array Secondary DNS addresses. 21 QCI R No Integer Quality of service Class Identifier. 22 Vendor specific extensions R No Objlnk Links to a vendor specific object. 23 TotalPacketsSent R No Integer Rolling counter for total number of packets sent via this interface since last device reset. 24 PDN Type R/W No Integer . 25 APN Rate Control R No Integer Determines the number of allowed uplink PDU transmissions per time interval per APN. Bearer selection Object \u00b6 LwM2M Registry for Object 13 This object specifies resources to enable a device to choose a PLMN/network on which to attach/register and what type of bearer to then connect. ID Resource Name Access Type Mandatory Type Description 0 Preferred Communications Bearer R/W No Integer array Used in network selection and, if applicable, in subsequent mobility management procedures. 1 Acceptable RSSI (GSM) R/W No Integer Provides guide to the application when performing manual network selection. 2 Acceptable RSCP (UMTS) R/W No Integer Provides guide to the application when performing manual network selection. 3 Acceptable RSRP (LTE) R/W No Integer Provides guide to the application when performing manual network selection. 4 Acceptable RSSI (1xEV-DO) R/W No Integer Provides guide to the application when performing manual network selection. 5 Cell lock list R/W No String Comma separated list of allowed Global Cell Identities. 6 Operator list R/W No String Comma separated list of MCC+MNC of operators, in priority order. 7 Operator list mode R/W No Boolean Indicates whether resource \"operator list\" represents the allowed operator list (white list), or, the preferred operator list. 8 List of available PLMNs R No String Allows server to see results of network scan. 9 Vendor specific extensions R No Object link Links to a vendor specific object. 10 Acceptable RSRP (NB-IoT) R/W No Integer Provides guide to the application when performing manual network selection. 11 Higher Priority PLMN Search Timer R/W No Integer Interval between periodic searches for higher priority PLMN. 12 Attach without PDN connection R/W No Boolean . Software Component Object \u00b6 LwM2M Registry for Object 14 This object provides the resources needed to activate/deactivate software components on the device. ID Resource Name Access Type Mandatory Type Description 0 Component Identity R No String Name or identifier of the software component. 1 Component Pack R No Opaque Software components is stored in this resource. 2 Component Version R No String Version of the software component. 3 Activate E No none Activate the installed software component. 4 Deactivate E No none Deactivate the installed software component. 5 Activation State R No Boolean Indicate the current activation state of the software. LwM2M OSCORE \u00b6 LwM2M Registry for Object 21 This object provides the resources needed to activate/deactivate software components on the device. ID Resource Name Access Type Mandatory Type Description 0 OSCORE Master Secret Yes String Store the pre-shared key used in LwM2M Client and LwM2M Server/Bootstrap-Server, called the Master Secret. 1 OSCORE Sender ID Yes String Store an OSCORE identifier for the LwM2M Client called the Sender ID. 2 OSCORE Recipient ID Yes String Store an OSCORE identifier for the LwM2M Client called the Recipient ID. 3 OSCORE AEAD Algorithm No Integer Store the encoding of the AEAD Algorithm as defined in Table 10 of RFC 8152. The AEAD is used by OSCORE for encryption and integrity protection of CoAP message fields. 4 OSCORE HMAC Algorithm No Integer Store the encoding of the HMAC Algorithm used in the HKDF. The encoding of HMAC algorithms are defined in Table 7 of RFC 8152. The HKDF is used to derive the security context used by OSCORE. 5 OSCORE Master Salt No String Store a non-secret random value called the Master Salt. The Master Salt is used to derive the security context used by OSCORE.","title":"Overview"},{"location":"LwM2MOverview/#lwm2m-overview","text":"The Lightweight Machine To Machine designed by the Open Mobile Alliance is a device management protocol for the Internet of Things (IoT).","title":"LwM2M Overview"},{"location":"LwM2MOverview/#lwm2m-concepts","text":"","title":"LwM2M Concepts"},{"location":"LwM2MOverview/#lwm2m-clientdevice","text":"The LwM2M Client/Device is the entity being managed by the LwM2M Server. The LwM2M Client presents resources for the LwM2M Server to manipulate.","title":"LwM2M Client/Device"},{"location":"LwM2MOverview/#lwm2m-server","text":"The LwM2M Server is the entity managing the LwM2M Devices. It can Read, Write, Execute, Create or Delete the Devices resources. The LwM2M Server URI can have one of the following formats: \"coap://{hostname}[:{port}]\" for unsecure UDP transport \"coaps://{hostname}[:{port}]\" for secure UDP transport (using DTLS) \"coap+tcp://{hostname}[:{port}]\" for unsecure TCP transport \"coaps+tcp://{hostname}[:{port}]\" for secure TCP transport (using TLS) \"sms://{msisdn number}\" for SMS binding in binary mode \"lorawan://{FPort}\" for LoRaWAN binding with FPort between 1 and 255 For UDP and TCP transports, if {port} is not present, the default port is used: 5683 for communication without security 5684 for secure communication","title":"LwM2M Server"},{"location":"LwM2MOverview/#lwm2m-bootstrap-server","text":"The LwM2M Bootstrap Server is a special [LwM2M Server][LwM2M Server]. It is the only Server allowed to provision or delete Server Accounts on the LwM2M Devices. It can Read (LwM2M 1.1), Write, Create and Delete the Devices resources.","title":"LwM2M Bootstrap Server"},{"location":"LwM2MOverview/#lwm2m-resource","text":"A LwM2M Resource is a data item presented by the LwM2M Device. A resource has a data type, a list of allowed operations and a unique URI. Data types are defined in Lightweight M2M as follows: signed integer, unsigned integer, float, boolean, UTF-8 string, core link string, opaque binary, Unix time, reference to a LwM2M Object. A resource can also be an array of the mentioned data types. Operations on resources are Read, Write and Execute.","title":"LwM2M Resource"},{"location":"LwM2MOverview/#lwm2m-objects","text":"The LwM2M Objects are a group of Device resources essential for some Device features such as firmware update, connectivity monitoring, physical sensor, etc. Standardized LwM2M Objects contain mandatory resources to support and optional resources to implement. A LwM2M Device can have several instances of the same LwM2M Object. All the Device resources are part of a LwM2M Object.","title":"LwM2M Objects"},{"location":"LwM2MOverview/#lwm2m-object-instance","text":"Some LwM2M Objects are defined as multi-instance objects, meaning that a LwM2M Device can have several instances of the same LwM2M Object. These instances are identified by a numerical instance ID. When a LwM2M Object is defined as a single-instance, the instance ID is always 0.","title":"LwM2M Object Instance"},{"location":"LwM2MOverview/#lwm2m-uri","text":"Resources and Objects have well-known IDs. The URI to a LwM2M resource is in the form: Object_ID [\"/\" Object_Instance_ID [\"/\" Resource_ID [\"/\" Resource_Instance_ID]]] An URI can address an object, an object instance, a resource or a resource instance (i.e. an element when the resource is an array).","title":"LwM2M URI"},{"location":"LwM2MOverview/#server-account","text":"A Server Account is a set of data enabling a LwM2M Device to connect to a LwM2M Server. It includes the Server URI and the Security Keys to use.","title":"Server Account"},{"location":"LwM2MOverview/#bootstrap","text":"A Bootstrap is the process by which the Device retrieves the Server Accounts. The information can come from factory settings, a SmartCard, or a LwM2M Bootstrap Server.","title":"Bootstrap"},{"location":"LwM2MOverview/#registration","text":"A LwM2M Server can only manage Devices registered with it. When registering with the Bootstrap Server, the Device communicates only its unique ID. When registering with the LwM2M Server, the Device can communicate: its unique ID, its lifetime, the list of LwM2M Objects implemented on the Device, its MSISDN, whether the Device requires Queue Mode or not.","title":"Registration"},{"location":"LwM2MOverview/#observation","text":"The LwM2M Server can subscribe to one or several readable Device resources. When the value of the resource changes, the Device sends a Notification message to the Server containing the new value of the resource.","title":"Observation"},{"location":"LwM2MOverview/#lifetime","text":"The Lifetime is the validity period of a LwM2M Device registration to the LwM2M Server. When this lifetime expires, the Server should no longer try to manage the Device. The Device sends Registration Update messages to the Server to renew its registration validity period.","title":"Lifetime"},{"location":"LwM2MOverview/#queue-mode","text":"Devices may go in stand-by mode and thus not be reachable by the LwM2M Servers at any time. To cope with this, the Device requests the Server to operate in Queue Mode. In this mode, the Device will initiate the communication with the Server (when sending a Notification or a Registration Update message). In the meantime, the Server is expected to queue its requests (hence the name).","title":"Queue Mode"},{"location":"LwM2MOverview/#sms-trigger","text":"A SMS Trigger is a special SMS sent to the Device. Upon reception of this SMS, the Device will either register to the Server or send a Registration Update message.","title":"SMS Trigger"},{"location":"LwM2MOverview/#lwm2m-operations-overview","text":"","title":"LwM2M Operations Overview"},{"location":"LwM2MOverview/#bootstrap_1","text":"When an endpoint is registered to a LwM2M Bootstrap Server, it can be managed by performing LwM2M operations on the endpoint's resources. The LwM2M operations are: Bootstrap Finish, Bootstrap Read, Bootstrap Write, Bootstrap Delete, Bootstrap Discover.","title":"Bootstrap"},{"location":"LwM2MOverview/#bootstrap-request","text":"The first action of LwM2M Client is to connect to the LwM2M Bootstrap Server and ask a Bootstrap Request. The Bootstrap Request message contains an endpoint\u2019s unique ID.","title":"Bootstrap Request"},{"location":"LwM2MOverview/#bootstrap-finish","text":"A Bootstrap Finish operation is sent by the LwM2M Bootstrap Server. Upon reception of this operation, the LwM2M Client will perform a Bootstrap Consistency check to verify the Bootstrap information received from the LwM2M Bootstrap Server is valid. This means at least one LwM2M server is configured on the LwM2M Client.","title":"Bootstrap Finish"},{"location":"LwM2MOverview/#bootstrap-read","text":"In LwM2M 1.1 or later, a Bootstrap Read operation can target the LwM2M Objects Access Control List or Server, or their LwM2M Object Instances. The endpoint returns data encoded in either TLV, JSON, SenML CBOR, or SenML JSON.","title":"Bootstrap Read"},{"location":"LwM2MOverview/#bootstrap-write","text":"A Bootstrap Write operation targets a LwM2M Object Instance. It contains data encoded in either TLV or JSON. The payload does not need to contain values for all the Object's resources. In LwM2M 1.1 or in later version, it contains data encoded in either SenML CBOR or SenML JSON.","title":"Bootstrap Write"},{"location":"LwM2MOverview/#bootstrap-delete","text":"A Bootstrap Delete operation can target the root path, a LwM2M Object or a LwM2M Instance Object.","title":"Bootstrap Delete"},{"location":"LwM2MOverview/#bootstrap-discover","text":"A Bootstrap Discover operation can target the root path or a LwM2M Object. The endpoint returns only the list of Objects and Object Instances with some attributes: LwM2M Enabler version (\"lwm2m=\"), Short Server ID (\"ssid=\"), and LwM2M Server URI (\"uri=\").","title":"Bootstrap Discover"},{"location":"LwM2MOverview/#registration_1","text":"","title":"Registration"},{"location":"LwM2MOverview/#initial-registration","text":"The first action of LwM2M Client is to register to the LwM2M Server. The registration message contains an endpoint\u2019s unique ID and information about its capabilities (in the form of LwM2M Objects). The registration message also contains a lifetime parameter. When this lifetime expires, the LwM2M Server cancels the LwM2M Client registration. The LwM2M Server replies with a \"location\". This location is a handle to the registration. The endpoint uses this handle to update or cancel its registration.","title":"Initial Registration"},{"location":"LwM2MOverview/#registration-update","text":"To keep its registration active or in case the list of LwM2M Objects is modified, the endpoint sends a Registration Update message. Upon reception of this message, the LwM2M Server resets its internal lifetime timer.","title":"Registration Update"},{"location":"LwM2MOverview/#de-registration","text":"To cancel its registration, the LwM2M Client sends a De-registration message. The LwM2M Server may also automatically cancel an endpoint's registration if the registration lifetime expires.","title":"De-registration"},{"location":"LwM2MOverview/#device-management-and-service-enablement","text":"When an endpoint is registered to a LwM2M Server, it can be managed by performing LwM2M operations on the endpoint's resources. The LwM2M operations are: Read, Write, Execute, Discover, Create, Delete, Read composite, Write composite.","title":"Device Management and Service Enablement"},{"location":"LwM2MOverview/#read","text":"A Read operation can target a LwM2M Object, a LwM2M Object Instance or a LwM2M Resource. The endpoint returns data encoded in either TLV or JSON. For a single resource, a text encoding is possible. In LwM2M 1.1 or later, the endpoint returns data encoded in either SenML CBOR or SenML JSON.","title":"Read"},{"location":"LwM2MOverview/#write","text":"A Write operation targets a LwM2M Object Instance. It contains data encoded in either TLV or JSON. The payload does not need to contain values for all the Object's resources. In LwM2M 1.1 or in later version, it contains data encoded in either SenML CBOR or SenML JSON.","title":"Write"},{"location":"LwM2MOverview/#execute","text":"An Execute operation can only target a LwM2M Resource.","title":"Execute"},{"location":"LwM2MOverview/#discover","text":"A Discover operation can target a LwM2M Object, a LwM2M Object Instance or a LwM2M Resource.","title":"Discover"},{"location":"LwM2MOverview/#create","text":"A Create operation can target a LwM2M Object. It creates a new Object Instance.","title":"Create"},{"location":"LwM2MOverview/#delete","text":"A Delete operation can target a LwM2M Object Instance. It deletes an Object Instance.","title":"Delete"},{"location":"LwM2MOverview/#read-composite","text":"In LwM2M 1.1 or in later version, a Read composite operation can selectively Read a number of Resources, and/or Resource Instances of different Objects in a single request. The endpoint returns data encoded in either SenML CBOR or SenML JSON.","title":"Read composite"},{"location":"LwM2MOverview/#write-composite","text":"In LwM2M 1.1 or in later version, a Write composite operation can update values of a number of different Resources across different Instances of one or more Objects in a single request. It contains data encoded in either SenML CBOR or SenML JSON.","title":"Write composite"},{"location":"LwM2MOverview/#information-reporting","text":"When a LwM2M Client is registered to a LwM2M Server, its resources can be observed. Whenever the value of the resource changes, the LwM2M Client sends a notification to the LwM2M Server. Moreover in LwM2M 1.1, the Client can send data to the LwM2M Server without initial solicitation. The LwM2M operations are: Observation, Observation composite, Cancel Observation, Write attributes, Send.","title":"Information Reporting"},{"location":"LwM2MOverview/#observation_1","text":"An observation can target a LwM2M Object, a LwM2M Object Instance or a LwM2M Resource.","title":"Observation"},{"location":"LwM2MOverview/#observe-composite","text":"In LwM2M 1.1 or in later version, a Observe composite operation can initiate observations or selectively read a group of Object, Object Instance, Resources, and/or Resource Instances of different Objects in a single request. The endpoint returns data encoded in either SenML CBOR or SenML JSON.","title":"Observe composite"},{"location":"LwM2MOverview/#notification","text":"When an observed resource's value changes, the endpoint sends a notification message to the LwM2M Server.","title":"Notification"},{"location":"LwM2MOverview/#cancel-observation","text":"The LwM2M Server can cancel an on-going observation.","title":"Cancel Observation"},{"location":"LwM2MOverview/#write-attributes","text":"The LwM2M Server can set the parameters of an observation. The following attributes are: Name Level Description pmin Object, Object Instance, Resource The minimum period in seconds to wait between notifications. pmax Object, Object Instance, Resource The maximum period in seconds to wait between notifications. gt Numerical Resource An upper threshold. A notification is sent when the resource value crosses this threshold. lt Numerical Resource A lower threshold. A notification is sent when the resource value crosses this threshold. st Numerical Resource A minimum difference in a resource value for a notification to be sent. epmin Object, Object Instance, Resource The minimum sample time in seconds for the observed sensor in LwM2M 1.1 or in later version. epmax Object, Object Instance, Resource The maximum sample time in seconds for the observed sensor in LwM2M 1.1 or in later version. Setting an attribute is in the form Name \"=\" value with some constraints: lt value < gt value lt value + 2 * st value < gt value If pmax < pmin , pmax is ignored epmax > epmin Clearing an attribute is in the form Name .","title":"Write attributes"},{"location":"LwM2MOverview/#examples","text":"Receiving a notification every minute at most even if the observed URI did not change: \"pmax=60\" . Receiving only one notification per hour even if the observed URI changed several times per minute: \"pmin=3600\" . Receiving exactly one notification every sixty seconds: \"pmin=59&pmax=60\" . Receiving a notification when the resource value exceeds 95 or falls below 10, and when the resource value returns below 95 or above 10: \"lt=10&gt=95\" . Clearing the previously set minimum period and setting a maximum period of five minutes: \"pmin&pmax=300\" .","title":"Examples"},{"location":"LwM2MOverview/#send","text":"In LwM2M 1.1 or in later version, a Send operation is used by the LwM2M Client to send data to the LwM2M Server without explicit request by that Server. It contains data encoded in either SenML CBOR or SenML JSON. Later in the documentation, the Send operation is called a Data Push.","title":"Send"},{"location":"LwM2MOverview/#standardized-lwm2m-objects","text":"The list of publics LwM2M Objects is available at the OMNA Registry: http://www.openmobilealliance.org/wp/OMNA/LwM2M/LwM2MRegistry.html","title":"Standardized LwM2M Objects"},{"location":"LwM2MOverview/#security-object","text":"LwM2M Registry for Object 0 This object provides the keying material of a LwM2M Client appropriate to access a specified LwM2M Server. One Object Instance should address a LwM2M Bootstrap-Server. ID Resource Name Access Type Mandatory Type Description 0 LwM2M Server URI Yes String Uniquely identifies the LwM2M Server or LwM2M Bootstrap-Server. The format of the CoAP URI is defined in Section 6 of RFC 7252. 1 Bootstrap-Server Yes Boolean Determines if the current instance concerns a LwM2M Bootstrap-Server (true) or a standard LwM2M Server (false). 2 Security Mode Yes Integer Determines which UDP payload security mode is used. 3 Public Key or Identity Yes Opaque Stores the LwM2M Client\u2019s Certificate (Certificate mode), public key (RPK mode) or PSK Identity (PSK mode). 4 Server Public Key Yes Opaque Stores the LwM2M Server\u2019s or LwM2M Bootstrap-Server\u2019s Certificate (Certificate mode), public key (RPK mode). 5 Secret Key Yes Opaque Stores the secret key or private key of the security mode. 6 SMS Security Mode No Integer Determines which SMS security mode is used. 7 SMS Binding Key Parameters No Opaque Stores the KIc, KID, SPI and TAR. 8 SMS Binding Secret Key(s) No Opaque Stores the values of the key(s) for the SMS binding. 9 LwM2M Server SMS Number No String MSISDN used by the LwM2M Client to send messages to the LwM2M Server via the SMS binding. 10 Short Server ID No Integer This identifier uniquely identifies each LwM2M Server configured for the LwM2M Client. 11 Client Hold Off Time No Integer Relevant information for a Bootstrap-Server only. 12 Bootstrap-Server Account Timeout No Integer The LwM2M Client MUST purge the LwM2M Bootstrap-Server Account after the timeout value given by this resource. The lowest timeout value is 1. 13 Matching Type No Unsigned Integer The Matching Type Resource specifies how the certificate or raw public key in in the Server Public Key is presented. 14 SNI No String This resource holds the value of the Server Name Indication (SNI) value to be used during the TLS handshake. 15 Certificate Usage No Unsigned Integer The Certificate Usage Resource specifies the semantic of the certificate. 16 DTLS/TLS Ciphersuite No Unsigned Integer It instructs the TLS/DTLS client to propose the indicated ciphersuite(s) in the ClientHello of the handshake 17 OSCORE Security Mode No Object link It provides a link to the OSCORE Object Instance.","title":"Security Object"},{"location":"LwM2MOverview/#server-object","text":"LwM2M Registry for Object 1 This object provides the data related to a LwM2M Server. A Bootstrap-Server has no such an Object Instance associated to it. ID Resource Name Access Type Mandatory Type Description 0 Short Server ID R Yes Integer Used as link to associate server Object Instance. 1 Lifetime RW Yes Integer Specify the lifetime of the registration in seconds. 2 Default Minimum Period RW No Integer The default value the LwM2M Client should use for the Minimum Period of an Observation in the absence of this parameter being included in an Observation. 3 Default Maximum Period RW No Integer The default value the LwM2M Client should use for the Maximum Period of an Observation in the absence of this parameter being included in an Observation. 4 Disable E No If this Resource is executed, this LwM2M Server Object is disabled for a certain period defined in the Disabled Timeout Resource. 5 Disable Timeout RW No Integer A period to disable the Server. 6 Notification Storing When Disabled or Offline RW Yes Boolean If true, the LwM2M Client stores \"Notify\" operations to the LwM2M Server while the LwM2M Server account is disabled or the LwM2M Client is offline. 7 Binding RW Yes String This Resource defines the transport binding configured for the LwM2M Client. 8 Registration Update Trigger E Yes If this Resource is executed the LwM2M Client MUST perform an \"Update\" operation with this LwM2M Server using that transport for the Current Binding Mode. 9 Bootstrap-Request Trigger E No If this Resource is executed the LwM2M Client MUST initiate a \"Client Initiated Bootstrap\" procedure in using the LwM2M Bootstrap-Server Account. 10 APN Link RW No Object link It provides a link to the APN connection profile Object Instance (OMNA registered Object ID:11) to be used to communicate with this server. 11 TLS-DTLS Alert Code R No Unsigned Integer It contains the most recent TLS / DTLS alert message received from the LwM2M Server. 12 Last Bootstrapped R No Time It represents the last time that the bootstrap server updated this LwM2M Server Account. 13 Registration Priority Order No Unsigned Integer The LwM2M Client sequences the LwM2M Server registrations in increasing order of this value. 14 Initial Registration Delay Timer No Unsigned Integer The delay before registration is attempted for this LwM2M Server based upon the completion of registration of the previous LwM2M Server in the registration order. 15 Registration Failure Block No Boolean Prevent or not the registration on the next LwM2M Server when the registration fails to connect with this LwM2M server. 16 Bootstrap on Registration Failure No Boolean Initiate a Bootstrap Request or not when the registration fails to connect with this LwM2M server. 17 Communication Retry Count No Unsigned Integer The number of successive communication attempts before which a communication sequence is considered as failed. 18 Communication Retry Timer No Unsigned Integer The delay between successive communication attempts in a communication sequence. 19 Communication Sequence Delay Timer No Unsigned Integer The delay between successive communication sequences. 20 Communication Sequence Retry Count No Unsigned Integer The number of successive communication sequences before which a registration attempt is considered as failed. 21 Trigger RW No Boolean Using the Trigger Resource a LwM2M Client can indicate whether it is reachable over SMS (value set to 'true') or not (value set to 'false'). 22 Preferred Transport RW No String When the LwM2M client supports multiple transports, it MAY use this transport to initiate a connection. 23 Mute Send RW No Boolean De-activated the LwM2M Client Send command capability.","title":"Server Object"},{"location":"LwM2MOverview/#access-control-list-object","text":"LwM2M Registry for Object 2 This object is used to check whether the LwM2M Server has access right for performing an operation. ID Resource Name Access Type Mandatory Type Description 0 Object ID R Yes Integer Used as link to associate Object which the access right is applicable. 1 Object Instance ID R Yes Integer Used as link to associate Object Instance which the access right is applicable. 2 ACL RW No Integer Set the access right for the corresponding LwM2M Servers. 3 Access Control Owner RW Yes Integer Short Server ID of a LwM2M Server. Only this LwM2M Server can manage the Resources of this Object Instance.","title":"Access Control List Object"},{"location":"LwM2MOverview/#device-object","text":"LwM2M Registry for Object 3 This object contains the device information: model, manufacturer, serial number, power source type, battery level, etc... It also contains a resource allowing the Server to reboot the Device. ID Resource Name Access Type Mandatory Type Description 0 Manufacturer R No String Human readable manufacturer name 1 Model Number R No String A model identifier (manufacturer specified string) 2 Serial Number R No String Serial Number 3 Firmware Version R No String Current firmware version of the Device. 4 Reboot E Yes none Reboot the LwM2M Device. 5 Factory Reset E No none Perform factory reset of the LwM2M Device to make the LwM2M Device to go through initial deployment sequence where provisioning and bootstrap sequence is performed. 6 Available Power Sources R No Integer array Available power sources of the Device. 7 Power Source Voltage R No Integer array Present voltage for each Available Power Sources. 8 Power Source Current R No Integer array Present current for each Available Power Sources. 9 Battery Level R No Integer Contains the current battery level as a percentage. 10 Memory Free R No Integer Estimated current available amount of storage space in the Device (expressed in kilobytes). 11 Error Code R Yes Integer array List of errors experienced by the Device. 12 Reset Error Code E No none Delete all error codes in the previous resource. 13 Current Time R/W No Time Current UNIX time of the LwM2M Client. 14 UTC Offset R/W No String Indicates the UTC offset currently in effect for this LwM2M Device. 15 Timezone R/W No String Indicates in which time zone the LwM2M Device is located. 16 Supported Bindings R Yes String Indicates which transports are supported by the Device. 17 Device Type R No String Type of the device (manufacturer specified string). 18 Hardware Version R No String Current hardware version of the device. 19 Software Version R No String Current software version of the device. 20 Battery Status R No Integer Status of the Device battery (normal, charging, etc...) 21 Memory Total R No Integer Total amount of storage space in the Device (expressed in kilobytes). 22 ExtDevInfo R No Object link Reference to a vendor specific object containing device information.","title":"Device Object"},{"location":"LwM2MOverview/#connectivity-monitoring-object","text":"LwM2M Registry for Object 4 This object provides high-level information on the current network type, signal strength, IP address, etc\u2026 ID Resource Name Access Type Mandatory Type Description 0 Network Bearer R Yes Integer The network bearer used for the current LwM2M communication session. 1 Available Network Bearer R Yes Integer array List of current available network bearer. 2 Radio Signal Strength R Yes Integer The average value of the received signal strength. 3 Link Quality R No Integer The received link quality. 4 IP Addresses R Yes String array The IP addresses assigned to the connectivity interface. 5 Router IP Addresses R No String array The IP addresses of the next-hop IP routers. 6 Link Utilization R No Integer The average utilization of the link in %. 7 APN R No String array Access Point Names in case Network Bearer Resource is a Cellular Network. 8 Cell ID R No Integer Serving Cell ID in case Network Bearer Resource is a Cellular Network. 9 SMNC R No Integer Serving Mobile Network Code. 10 SMCC R No Integer Serving Mobile Country Code. 11 SignalSNR R No Integer Signal to Interference plus Noise Ratio SINR is the ratio of the strength of the received signal to the strength of the received interference signal. 12 LAC R No Integer Location Area Code in case Network Bearer Resource is a Cellular Network.","title":"Connectivity Monitoring Object"},{"location":"LwM2MOverview/#firmware-update-object","text":"LwM2M Registry for Object 5 This object allows to update the firmware of the device. The firmware package can either be pushed by the Server to the Device or the Device can download it using the provided URI. ID Resource Name Access Type Mandatory Type Description 0 Package W Yes Opaque The firmware package pushed by the Server. 1 Package URI R/W Yes String The URI from where the Device can download the firmware package. 2 Update E Yes none Updates the Device firmware by using the firmware package. 3 State R Yes Integer Indicates current state with respect to this firmware update. 5 Update Result R Yes Integer Contains the result of downloading or updating the firmware. 6 PkgName R No String The name of the Firmware Package. 7 PkgVersion R No String The version of the Firmware package. 8 Firmware Update Protocol Support R No Integer The download protocols the Device implements. 9 Firmware Update Delivery Method R Yes Integer The delivery methods the Device supports.","title":"Firmware Update Object"},{"location":"LwM2MOverview/#location-object","text":"LwM2M Registry for Object 6 This object contains information on the device position and speed. ID Resource Name Access Type Mandatory Type Description 0 Latitude R Yes Float The decimal notation of latitude. 1 Longitude R Yes Float The decimal notation of longitude. 2 Altitude R No Float The decimal notation of altitude in meters above sea level. 3 Radius R No Float The size in meters of a circular area around a point of geometry. 4 Velocity R No Opaque The velocity in the Device. 5 Timestamp R No Time The timestamp of when the location measurement was performed. 6 Speed R No Float The speed of the Device in meters per second.","title":"Location Object"},{"location":"LwM2MOverview/#connectivity-statistics-object","text":"LwM2M Registry for Object 7 This object collects statistics on the network usage. ID Resource Name Access Type Mandatory Type Description 0 SMS Tx Counter R No Integer The total number of SMS successfully transmitted during the collection period. 1 SMS Rx Counter R No Integer The total number of SMS successfully received during the collection period. 2 Tx Data R No Integer The total amount of IP data transmitted during the collection period. 3 Rx Data R No Integer The total amount of IP data received during the collection period. 4 Max Message Size R No Integer The maximum IP message size that is used during the collection period. 5 Average Message Size R No Integer The average IP message size that is used during the collection period. 6 Start E Yes none Start to collect information. 7 Stop E Yes none Stop collecting information. 8 Collection Period R/W No Integer The default collection period in seconds.","title":"Connectivity Statistics Object"},{"location":"LwM2MOverview/#software-management-object","text":"LwM2M Registry for Object 9 This object allows to update the software of the device. The software package can either be pushed by the Server to the Device or the Device can download it using the provided URI. ID Resource Name Access Type Mandatory Type Description 0 PkgName R Yes String Name of the software package. 1 PkgVersion R Yes String Version of the software package. 2 Package W No Opaque The software package pushed by the Server. 3 Package URI W No String The URI from where the Device can download the software package. 4 Install E Yes none Install the software package. 5 Checkpoint R No Objlink Link to a Checkpoint object which allows to specify conditions/dependencies for a software update. 6 Uninstall E Yes none Uninstall the software package. 7 Update State R/W No Boolean Indicates current state with respect to this software update. 8 Update Supported Object R Yes Integer Indicates if the LwM2M Client MUST inform the registered LwM2M Servers of Objects and Object Instances parameter by sending an Update or Registration message after the software update operation. 9 Update Result R Yes Integer Contains the result of downloading or updating the software. 10 Activate E Yes none Activate the previously installed software package. 11 Deactivate E Yes none Deactivate the previously installed software package. 12 Activation State R Yes Boolean Indicate the current activation state of the software. 13 User Name W No String User name for access to software Update Package in pull mode. 14 Password W No String Password for access to software Update Package in pull mode. 15 Software Component Link R No Objlink Reference to SW Components downloaded and installed in scope of the present SW Update Package.","title":"Software Management Object"},{"location":"LwM2MOverview/#cellular-connectivity-object","text":"LwM2M Registry for Object 10 This object is used to configure the cellular connectivity of the Device. ID Resource Name Access Type Mandatory Type Description 11 Activated Profile Names R Yes String array Links to instances of the \"APN connection profile\" object. 0 SMSC address R/W No String E.164 address of SMSC. 1 Disable radio period R/W No Integer Time period for which the device shall disconnect from cellular radio. 2 Module activation code R/W No String AT command to activate the module. 3 Vendor specific extensions R No Object Link Link to a vendor specific object. 4 PSM Timer R/W No Integer Power saving mode timer. 5 Active Timer R/W No Integer Active timer = T3324 as defined in [3GPP-TS_24.008]. 6 Serving PLMN Rate control R No Integer Maximum the number of allowed uplink PDU transmissions per 6 minute interval. 7 eDRX parameters for Iu mode R/W No Opaque Extended DRX parameters (Paging Time Window and eDRX value) for Iu mode. 8 eDRX parameters for WB-S1 mode R/W No Opaque Extended DRX parameters (Paging Time Window and eDRX value) for WB-S1 mode. 9 eDRX parameters for NB-S1 mode R/W No Opaque Extended DRX parameters (Paging Time Window and eDRX value) for NB-S1 mode. 10 eDRX parameters for A/Gb mode R/W No Opaque Extended DRX parameters (Paging Time Window and eDRX value) for A/Gb mode.","title":"Cellular Connectivity Object"},{"location":"LwM2MOverview/#apn-connection-profile-object","text":"LwM2M Registry for Object 11 This object specifies resources to enable a device to connect to an APN. ID Resource Name Access Type Mandatory Type Description 0 Profile name R/W Yes String Human-readable identifier. 1 APN R/W No String Presented to network during connection to PDN. 2 Auto select APN by device R/W No Boolean Enables the device to choose an APN according to a device specific algorithm. 3 Enable status R/W No Boolean Connection is activated or not. 4 Authentication Type R/W Yes Integer . 5 User Name R/W No String . 6 Secret R/W No String . 7 Reconnect Schedule R/W No String Comma separated list of retry delay values in seconds. 8 Validity (MCC, MNC) R/W No String array Coma separated mobile country code, then mobile network code. 9 Connection establishment time R No Time array UTC time of connection request. 10 Connection establishment result R No Integer array . 11 Connection establishment reject cause R No Integer array Reject cause, see [3GPP-TS_24.008, 3GPP-TS_24.301]. 12 Connection end time R No Time array UTC time of connection end. 13 TotalBytesSent R No Integer array Rolling counter for total number of bytes sent via this interface since last device reset. 14 TotalBytesReceived R No Integer Rolling counter for total number of bytes received via this interface since last device reset. 15 IP address R/W No String array IP addresses. 16 Prefix length R/W No String array Associated with IPv6 addresses. 17 Subnet mask R/W No String array Subnet masks. 18 Gateway R/W No String array Gateways. 19 Primary DNS address R/W No String array Primary DNS addresses. 20 Secondary DNS address R/W No String array Secondary DNS addresses. 21 QCI R No Integer Quality of service Class Identifier. 22 Vendor specific extensions R No Objlnk Links to a vendor specific object. 23 TotalPacketsSent R No Integer Rolling counter for total number of packets sent via this interface since last device reset. 24 PDN Type R/W No Integer . 25 APN Rate Control R No Integer Determines the number of allowed uplink PDU transmissions per time interval per APN.","title":"APN Connection Profile Object"},{"location":"LwM2MOverview/#bearer-selection-object","text":"LwM2M Registry for Object 13 This object specifies resources to enable a device to choose a PLMN/network on which to attach/register and what type of bearer to then connect. ID Resource Name Access Type Mandatory Type Description 0 Preferred Communications Bearer R/W No Integer array Used in network selection and, if applicable, in subsequent mobility management procedures. 1 Acceptable RSSI (GSM) R/W No Integer Provides guide to the application when performing manual network selection. 2 Acceptable RSCP (UMTS) R/W No Integer Provides guide to the application when performing manual network selection. 3 Acceptable RSRP (LTE) R/W No Integer Provides guide to the application when performing manual network selection. 4 Acceptable RSSI (1xEV-DO) R/W No Integer Provides guide to the application when performing manual network selection. 5 Cell lock list R/W No String Comma separated list of allowed Global Cell Identities. 6 Operator list R/W No String Comma separated list of MCC+MNC of operators, in priority order. 7 Operator list mode R/W No Boolean Indicates whether resource \"operator list\" represents the allowed operator list (white list), or, the preferred operator list. 8 List of available PLMNs R No String Allows server to see results of network scan. 9 Vendor specific extensions R No Object link Links to a vendor specific object. 10 Acceptable RSRP (NB-IoT) R/W No Integer Provides guide to the application when performing manual network selection. 11 Higher Priority PLMN Search Timer R/W No Integer Interval between periodic searches for higher priority PLMN. 12 Attach without PDN connection R/W No Boolean .","title":"Bearer selection Object"},{"location":"LwM2MOverview/#software-component-object","text":"LwM2M Registry for Object 14 This object provides the resources needed to activate/deactivate software components on the device. ID Resource Name Access Type Mandatory Type Description 0 Component Identity R No String Name or identifier of the software component. 1 Component Pack R No Opaque Software components is stored in this resource. 2 Component Version R No String Version of the software component. 3 Activate E No none Activate the installed software component. 4 Deactivate E No none Deactivate the installed software component. 5 Activation State R No Boolean Indicate the current activation state of the software.","title":"Software Component Object"},{"location":"LwM2MOverview/#lwm2m-oscore","text":"LwM2M Registry for Object 21 This object provides the resources needed to activate/deactivate software components on the device. ID Resource Name Access Type Mandatory Type Description 0 OSCORE Master Secret Yes String Store the pre-shared key used in LwM2M Client and LwM2M Server/Bootstrap-Server, called the Master Secret. 1 OSCORE Sender ID Yes String Store an OSCORE identifier for the LwM2M Client called the Sender ID. 2 OSCORE Recipient ID Yes String Store an OSCORE identifier for the LwM2M Client called the Recipient ID. 3 OSCORE AEAD Algorithm No Integer Store the encoding of the AEAD Algorithm as defined in Table 10 of RFC 8152. The AEAD is used by OSCORE for encryption and integrity protection of CoAP message fields. 4 OSCORE HMAC Algorithm No Integer Store the encoding of the HMAC Algorithm used in the HKDF. The encoding of HMAC algorithms are defined in Table 7 of RFC 8152. The HKDF is used to derive the security context used by OSCORE. 5 OSCORE Master Salt No String Store a non-secret random value called the Master Salt. The Master Salt is used to derive the security context used by OSCORE.","title":"LwM2M OSCORE"},{"location":"Multithread/","text":"IOWA Multithread Environment \u00b6 Presentation \u00b6 The thread safety is enabled through the flag IOWA_THREAD_SUPPORT . Without this flag, IOWA APIs cannot be called from different threads. IOWA_THREAD_SUPPORT enables this feature by introducing a global mutex for the IOWA functions. Three platform functions must be additionally implemented to support the thread safety: iowa_system_connection_interrupt_select() iowa_system_mutex_lock() iowa_system_mutex_unlock() Code Example \u00b6 A global architecture is introduced. This architecture is not intended to be exactly followed. More than one architecture is achievable and depends primarily on the use case. Let's say here, IOWA is running on a RTOS system. This RTOS system will create a main thread. In addition to this thread, for our use case, two other threads will be created: The first will be used to initialize IOWA and run the iowa_step() function. The second will be used to update the value of an IPSO object. About these threads: IOWA thread: Memory size (stack allocation): 512 bytes (recommended) Priority: High Update thread: Memory size (stack allocation): 256 bytes (recommended) Priority: Low Next is a sample pseudo-code implementation of these tasks: #include \"iowa_client.h\" typedef struct { iowa_context_t iowaH ; iowa_sensor_t sensorId ; int pipeArray [ 2 ]; } user_struct_t ; void iowa_task ( void * userData ) { user_struct_t * dataP ; iowa_device_info_t devInfo ; /****************** * Initialization */ dataP = ( user_struct_t * ) userData ; dataP -> iowaH = iowa_init ( dataP ); devInfo . manufacturer = \"IOTEROP\" ; devInfo . deviceType = \"Example device\" ; devInfo . modelNumber = \"1\" ; devInfo . serialNumber = NULL ; devInfo . hardwareVersion = NULL ; devInfo . softwareVersion = NULL ; devInfo . optFlags = 0 ; iowa_client_configure ( dataP -> iowaH , \"IOWA_Sample_MT_Client\" , devInfo , NULL ); iowa_client_IPSO_add_sensor ( dataP -> iowaH , IOWA_IPSO_VOLTAGE , 12.0 , \"V\" , \"Test DC\" , 0.0 , 0.0 , & ( dataP -> sensorId )); iowa_client_add_server ( dataP -> iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ iowa_step ( dataP -> iowaH , -1 ); // Run indefinitely /****************** * Close */ iowa_client_IPSO_remove_sensor ( dataP -> iowaH , dataP -> sensorId ); iowa_client_remove_server ( dataP -> iowaH , 1234 ); iowa_close ( dataP -> iowaH ); } void update_task ( void * userData ) { user_struct_t * dataP ; WAIT_IOWA_INIT (); // Can be done through a semaphore dataP = ( user_struct_t * ) userData ; /****************** * \"Main loop\" */ while ( 1 ) { float sensorValue ; sensorValue = READ_VOLTAGE (); iowa_client_IPSO_update_value ( dataP -> iowaH , dataP -> sensorId , sensorValue ); SLEEP ( 1 ); } } int main ( int argc , char * argv []) { user_struct_t data ; RTOS_INIT (); CREATE_THREAD ( iowa_task , 512 , & data , 2 ); CREATE_THREAD ( update_task , 256 , & data , 1 ); /****************** * \"Main loop\" */ while ( 1 ) { // Do nothing } return 0 ; } If for any reason, the iowa_step() function has to be stopped, the iowa_stop() API can be called to force the step to finish by calling the iowa_system_connection_interrupt_select() platform function. If iowa_step() function is called with a negative value, iowa_system_connection_select() will be called with a long timeout. To prevent the iowa_step() function from waiting until the timeout is reached, the iowa_system_connection_select() function must react and exit when the iowa_system_connection_interrupt_select() is called. A way to implement this behaviour is to create a local pipe: One side, named read , of the pipe will be used by iowa_system_connection_select() to listen on an interrupt select event. The other side, named write , of the pipe will be used by iowa_system_connection_interrupt_select() to send an interrupt select event. Below an example of these platform functions with pseudo-code: #define READ_PIPE 0 #define WRITE_PIPE 1 int iowa_system_connection_select ( void ** connArray , size_t connCount , int32_t timeout , void * userData ) { fd_set readfds ; int result ; user_struct_t * dataP ; dataP = ( user_struct_t * ) userData ; SET ( dataP -> pipeArray [ READ_PIPE ], & readfds ); for ( i = 0 ; i < connCount ; i ++ ) { SET ( get_connection_sock ( connArray [ i ]), & readfds ); } result = SELECT ( timeout ); if ( result > 0 ) { for ( i = 0 ; i < connCount ; i ++ ) { if ( ! IS_SET ( get_connection_sock ( connArray [ i ]), & readfds )) { connArray [ i ] = NULL ; } } if ( IS_SET ( dataP -> pipeArray [ READ_PIPE ], & readfds )) { // Remove data written by iowa_system_connection_interrupt_select() READ ( dataP -> pipeArray [ READ_PIPE ]); } } return result ; } void iowa_system_connection_interrupt_select ( void * userData ) { user_struct_t * dataP ; dataP = ( user_struct_t * ) userData ; WRITE ( dataP -> pipeArray [ WRITE_PIPE ], \"NOISE\" ); } void iowa_system_mutex_lock ( void * userData ) { MUTEX_LOCK (); } void iowa_system_mutex_unlock ( void * userData ) { MUTEX_UNLOCK (); }","title":"IOWA Multithread Environment"},{"location":"Multithread/#iowa-multithread-environment","text":"","title":"IOWA Multithread Environment"},{"location":"Multithread/#presentation","text":"The thread safety is enabled through the flag IOWA_THREAD_SUPPORT . Without this flag, IOWA APIs cannot be called from different threads. IOWA_THREAD_SUPPORT enables this feature by introducing a global mutex for the IOWA functions. Three platform functions must be additionally implemented to support the thread safety: iowa_system_connection_interrupt_select() iowa_system_mutex_lock() iowa_system_mutex_unlock()","title":"Presentation"},{"location":"Multithread/#code-example","text":"A global architecture is introduced. This architecture is not intended to be exactly followed. More than one architecture is achievable and depends primarily on the use case. Let's say here, IOWA is running on a RTOS system. This RTOS system will create a main thread. In addition to this thread, for our use case, two other threads will be created: The first will be used to initialize IOWA and run the iowa_step() function. The second will be used to update the value of an IPSO object. About these threads: IOWA thread: Memory size (stack allocation): 512 bytes (recommended) Priority: High Update thread: Memory size (stack allocation): 256 bytes (recommended) Priority: Low Next is a sample pseudo-code implementation of these tasks: #include \"iowa_client.h\" typedef struct { iowa_context_t iowaH ; iowa_sensor_t sensorId ; int pipeArray [ 2 ]; } user_struct_t ; void iowa_task ( void * userData ) { user_struct_t * dataP ; iowa_device_info_t devInfo ; /****************** * Initialization */ dataP = ( user_struct_t * ) userData ; dataP -> iowaH = iowa_init ( dataP ); devInfo . manufacturer = \"IOTEROP\" ; devInfo . deviceType = \"Example device\" ; devInfo . modelNumber = \"1\" ; devInfo . serialNumber = NULL ; devInfo . hardwareVersion = NULL ; devInfo . softwareVersion = NULL ; devInfo . optFlags = 0 ; iowa_client_configure ( dataP -> iowaH , \"IOWA_Sample_MT_Client\" , devInfo , NULL ); iowa_client_IPSO_add_sensor ( dataP -> iowaH , IOWA_IPSO_VOLTAGE , 12.0 , \"V\" , \"Test DC\" , 0.0 , 0.0 , & ( dataP -> sensorId )); iowa_client_add_server ( dataP -> iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ iowa_step ( dataP -> iowaH , -1 ); // Run indefinitely /****************** * Close */ iowa_client_IPSO_remove_sensor ( dataP -> iowaH , dataP -> sensorId ); iowa_client_remove_server ( dataP -> iowaH , 1234 ); iowa_close ( dataP -> iowaH ); } void update_task ( void * userData ) { user_struct_t * dataP ; WAIT_IOWA_INIT (); // Can be done through a semaphore dataP = ( user_struct_t * ) userData ; /****************** * \"Main loop\" */ while ( 1 ) { float sensorValue ; sensorValue = READ_VOLTAGE (); iowa_client_IPSO_update_value ( dataP -> iowaH , dataP -> sensorId , sensorValue ); SLEEP ( 1 ); } } int main ( int argc , char * argv []) { user_struct_t data ; RTOS_INIT (); CREATE_THREAD ( iowa_task , 512 , & data , 2 ); CREATE_THREAD ( update_task , 256 , & data , 1 ); /****************** * \"Main loop\" */ while ( 1 ) { // Do nothing } return 0 ; } If for any reason, the iowa_step() function has to be stopped, the iowa_stop() API can be called to force the step to finish by calling the iowa_system_connection_interrupt_select() platform function. If iowa_step() function is called with a negative value, iowa_system_connection_select() will be called with a long timeout. To prevent the iowa_step() function from waiting until the timeout is reached, the iowa_system_connection_select() function must react and exit when the iowa_system_connection_interrupt_select() is called. A way to implement this behaviour is to create a local pipe: One side, named read , of the pipe will be used by iowa_system_connection_select() to listen on an interrupt select event. The other side, named write , of the pipe will be used by iowa_system_connection_interrupt_select() to send an interrupt select event. Below an example of these platform functions with pseudo-code: #define READ_PIPE 0 #define WRITE_PIPE 1 int iowa_system_connection_select ( void ** connArray , size_t connCount , int32_t timeout , void * userData ) { fd_set readfds ; int result ; user_struct_t * dataP ; dataP = ( user_struct_t * ) userData ; SET ( dataP -> pipeArray [ READ_PIPE ], & readfds ); for ( i = 0 ; i < connCount ; i ++ ) { SET ( get_connection_sock ( connArray [ i ]), & readfds ); } result = SELECT ( timeout ); if ( result > 0 ) { for ( i = 0 ; i < connCount ; i ++ ) { if ( ! IS_SET ( get_connection_sock ( connArray [ i ]), & readfds )) { connArray [ i ] = NULL ; } } if ( IS_SET ( dataP -> pipeArray [ READ_PIPE ], & readfds )) { // Remove data written by iowa_system_connection_interrupt_select() READ ( dataP -> pipeArray [ READ_PIPE ]); } } return result ; } void iowa_system_connection_interrupt_select ( void * userData ) { user_struct_t * dataP ; dataP = ( user_struct_t * ) userData ; WRITE ( dataP -> pipeArray [ WRITE_PIPE ], \"NOISE\" ); } void iowa_system_mutex_lock ( void * userData ) { MUTEX_LOCK (); } void iowa_system_mutex_unlock ( void * userData ) { MUTEX_UNLOCK (); }","title":"Code Example"},{"location":"Network/","text":"IOWA Network environment \u00b6 Network reliability \u00b6 Behind the transport \u00b6 Network reliability is a real issue when a system is deployed in an environment. Some networks can be reliable, when others do not guarantee the transmission of a message from one side to another. IOWA supports the following transports: User Datagram Protocol (aka UDP) Transmission Control Protocol (aka TCP) LoRaWAN Short Message Service (aka SMS) For each transport, a set of constants is defined to maximize the chances that message is received. These constants can be simplified into two parts: a retransmission counter and an initial timeout. The retransmission counter is the number of attempts to send until the communication is considered as failed. The initial timeout is the number of second to wait for a response before resending the message. The algorithm is as follows: when the initial timeout is triggered and the retransmission counter is less than the maximum retransmission number, the message is retransmitted, the retransmission counter is incremented, and the timeout is doubled. If the retransmission counter reaches the maximum retransmission number on a timeout, then the attempt to transmit the message is canceled and the application process is notified of the failure. On the other hand, if the endpoint receives a response in time, transmission is considered successful. In IOWA, it means: On server side: when an operation is performed, such as for a LwM2M Server a Read operation, if the message is not received by the client, the callback iowa_result_callback_t will be called with status sets to IOWA_COAP_503_SERVICE_UNAVAILABLE. On client side: if a Confirmable message is not acknowledged by the LwM2M Server such as the registration message, the registration update message, or a confirmable notification, the connection is considered lost. In case of registration or registration update, the callback iowa_event_callback_t will be called with eventP->eventType sets to IOWA_EVENT_REG_FAILED and the function iowa_step will exit by returning IOWA_COAP_503_SERVICE_UNAVAILABLE. On the other hand, if a confirmable notification is not acknowledged, the LwM2M Client deactivates the Server Account until the connection is reestablished, that is, an Acknowledge is received on a Confirmable message. On both side: if the Platform layer returns a negative value on iowa_system_connection_send , iowa_system_connection_recv or iowa_system_connection_select , the connection will be considered lost and iowa_step will exit by returning IOWA_COAP_503_SERVICE_UNAVAILABLE. SMS specific behaviors \u00b6 MSISDN Fallback \u00b6 There is a MSISDN fallback for the Client when the connection can't be established on a Registration message or a Registration Update message is not acknowledged. This fallback can be activated with the define [ IOWA_SMS_SUPPORT ][Transports] and by providing the LwM2M Server MSISDN number with iowa_client_set_server_msisdn . In that case, if the LwM2M Client cannot reach a LwM2M Server, IOWA will close the current connection before opening a new SMS connection to try to register with this transport. On this second attempt, if the LwM2M Client has again no response from the LwM2M Server, iowa_step will exit by returning IOWA_COAP_503_SERVICE_UNAVAILABLE. Registration Update Trigger message \u00b6 On the LwM2M Server side when an operation is not acknowledged by the LwM2M Client, the Server can generate a Registration Update Trigger message with iowa_server_create_registration_update_trigger_message . This message has to be sent by SMS to the Client. For this purpose, the Client must at least on its Registration message give its MSISDN number. This MSISDN number can be provided to IOWA when calling iowa_client_configure and setting infoP->msisdn . Last but not least, the Client has to listen on incoming SMS messages. If a message is received out of bound, the Client has to call iowa_client_new_incoming_connection . If the message received is a Registration Update Trigger, IOWA will automatically sends a Registration Update using the Client preferred binding. Network reachability \u00b6 The LwM2M Server should always be present. But this is not the case for the LwM2M Client. There are multiple reasons for a LwM2M Client not to be available. A LwM2M Server can deactivate the connection with a LwM2M Client for a certain period. This mechanism can be triggered by executing the resource Disable (ID: 4) of the [ Server Object ][Server Object]. The LwM2M Server Account will be disabled for a certain period defined in the Disabled Timeout Resource (ID: 5). After receiving the Execute operation, LwM2M Client must perform the deregistration process, and underlying network connection between the LwM2M Client and LwM2M Server must be disconnected to disable the LwM2M Server account. After the above process, the LwM2M Client must not send any message to the Server and ignore all the messages from the LwM2M Server for the period. Once the disabled timeout expires, the client restarts the registration process to reconnect to the LwM2M Server. In LwM2M, there is a mechanism called Queue Mode which offers functionality for a LwM2M Client to inform the LwM2M Server that it may be disconnected for an extended period and when it becomes reachable again. When the LwM2M Client is not reachable, the LwM2M Server does not immediately send downlink requests, but instead waits until the LwM2M Client becomes reachable again. Flow \u00b6 A typical Queue Mode sequence follows the steps listed below: The LwM2M Client registers to the LwM2M Server and requests the LwM2M Server to run in Queue mode. The LwM2M Client should use the CoAP constant MAX_TRANSMIT_WAIT (93 seconds) to set a timer for how long it shall stay awake after sending a message to the LwM2M Server. After the timeout expires without any messages from the LwM2M Server, the LwM2M Client enters sleep mode. At some point in time the LwM2M Client wakes up again and transmits a registration update message. Note: During the time the LwM2M Client has been sleeping the IP address assigned to it may have been released and/or existing NAT bindings may have been released. If this is the case, then the client needs to re-run the TLS/DTLS handshake with the LwM2M Server since an IP address and/or port number change will destroy the existing security context. When the LwM2M Server receives a message from the Client, it determines if any messages need to be sent to the LwM2M Client, as instructed by the Application Server. IOWA API \u00b6 IOWA introduces two APIs to handle the Queue Mode: iowa_flush_before_pause and iowa_client_send_heartbeat . iowa_flush_before_pause is used to inform the LwM2M stack that the device will pause. iowa_flush_before_pause() performs all the pending and required operations of the LwM2M stack engine before returning. It means that if the registration lifetime expires during the device sleep, IOWA will send a registration update before returning from this function. When waking up, the LwM2M Client is connected again to the LwM2M Server. This function also returns a parameter delayP to indicate when the next scheduled IOWA operation is. iowa_client_send_heartbeat is used to send an heartbeat message to a LwM2M Server. Depending of the transport, the heartbeat sent can be a CoAP Empty message on LoRaWAN, or a registration update message for others transports. Below an example in pseudo-code to use these APIs: #include \"iowa_client.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); iowa_client_configure ( iowaH , \"IOWA_Sample_QM_Client\" , NULL , NULL ); iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ do { uint32_t iowaDelay ; // Run for 93 seconds result = iowa_step ( iowaH , 93 ); // Prepare to stand by for 60 minutes result = iowa_flush_before_pause ( iowaH , 3600 , & iowaDelay ); if ( iowaDelay < 3600 ) { STAND_BY ( iowaDelay ); } else { STAND_BY ( 3600 ); iowa_client_send_heartbeat ( iowaH , 1234 ); } } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_server ( iowaH , 1234 ); iowa_close ( iowaH ); return 0 ; } In the above example, after calling iowa_flush_before_pause , there are two possibilities: iowaDelay is inferior to the requested stand by time. It means that on next iowa_step call, IOWA will send to the Server a message such as notification, registration update, etc. So, the Server will notice the device wake up and send back any buffered requests. Or, iowaDelay is equal to the requested stand by time. In that case, IOWA has nothing to send on next iowa_step() turn. To inform the Server that the device is awake, iowa_client_send_heartbeat needs to be called.","title":"IOWA Network environment"},{"location":"Network/#iowa-network-environment","text":"","title":"IOWA Network environment"},{"location":"Network/#network-reliability","text":"","title":"Network reliability"},{"location":"Network/#behind-the-transport","text":"Network reliability is a real issue when a system is deployed in an environment. Some networks can be reliable, when others do not guarantee the transmission of a message from one side to another. IOWA supports the following transports: User Datagram Protocol (aka UDP) Transmission Control Protocol (aka TCP) LoRaWAN Short Message Service (aka SMS) For each transport, a set of constants is defined to maximize the chances that message is received. These constants can be simplified into two parts: a retransmission counter and an initial timeout. The retransmission counter is the number of attempts to send until the communication is considered as failed. The initial timeout is the number of second to wait for a response before resending the message. The algorithm is as follows: when the initial timeout is triggered and the retransmission counter is less than the maximum retransmission number, the message is retransmitted, the retransmission counter is incremented, and the timeout is doubled. If the retransmission counter reaches the maximum retransmission number on a timeout, then the attempt to transmit the message is canceled and the application process is notified of the failure. On the other hand, if the endpoint receives a response in time, transmission is considered successful. In IOWA, it means: On server side: when an operation is performed, such as for a LwM2M Server a Read operation, if the message is not received by the client, the callback iowa_result_callback_t will be called with status sets to IOWA_COAP_503_SERVICE_UNAVAILABLE. On client side: if a Confirmable message is not acknowledged by the LwM2M Server such as the registration message, the registration update message, or a confirmable notification, the connection is considered lost. In case of registration or registration update, the callback iowa_event_callback_t will be called with eventP->eventType sets to IOWA_EVENT_REG_FAILED and the function iowa_step will exit by returning IOWA_COAP_503_SERVICE_UNAVAILABLE. On the other hand, if a confirmable notification is not acknowledged, the LwM2M Client deactivates the Server Account until the connection is reestablished, that is, an Acknowledge is received on a Confirmable message. On both side: if the Platform layer returns a negative value on iowa_system_connection_send , iowa_system_connection_recv or iowa_system_connection_select , the connection will be considered lost and iowa_step will exit by returning IOWA_COAP_503_SERVICE_UNAVAILABLE.","title":"Behind the transport"},{"location":"Network/#sms-specific-behaviors","text":"","title":"SMS specific behaviors"},{"location":"Network/#msisdn-fallback","text":"There is a MSISDN fallback for the Client when the connection can't be established on a Registration message or a Registration Update message is not acknowledged. This fallback can be activated with the define [ IOWA_SMS_SUPPORT ][Transports] and by providing the LwM2M Server MSISDN number with iowa_client_set_server_msisdn . In that case, if the LwM2M Client cannot reach a LwM2M Server, IOWA will close the current connection before opening a new SMS connection to try to register with this transport. On this second attempt, if the LwM2M Client has again no response from the LwM2M Server, iowa_step will exit by returning IOWA_COAP_503_SERVICE_UNAVAILABLE.","title":"MSISDN Fallback"},{"location":"Network/#registration-update-trigger-message","text":"On the LwM2M Server side when an operation is not acknowledged by the LwM2M Client, the Server can generate a Registration Update Trigger message with iowa_server_create_registration_update_trigger_message . This message has to be sent by SMS to the Client. For this purpose, the Client must at least on its Registration message give its MSISDN number. This MSISDN number can be provided to IOWA when calling iowa_client_configure and setting infoP->msisdn . Last but not least, the Client has to listen on incoming SMS messages. If a message is received out of bound, the Client has to call iowa_client_new_incoming_connection . If the message received is a Registration Update Trigger, IOWA will automatically sends a Registration Update using the Client preferred binding.","title":"Registration Update Trigger message"},{"location":"Network/#network-reachability","text":"The LwM2M Server should always be present. But this is not the case for the LwM2M Client. There are multiple reasons for a LwM2M Client not to be available. A LwM2M Server can deactivate the connection with a LwM2M Client for a certain period. This mechanism can be triggered by executing the resource Disable (ID: 4) of the [ Server Object ][Server Object]. The LwM2M Server Account will be disabled for a certain period defined in the Disabled Timeout Resource (ID: 5). After receiving the Execute operation, LwM2M Client must perform the deregistration process, and underlying network connection between the LwM2M Client and LwM2M Server must be disconnected to disable the LwM2M Server account. After the above process, the LwM2M Client must not send any message to the Server and ignore all the messages from the LwM2M Server for the period. Once the disabled timeout expires, the client restarts the registration process to reconnect to the LwM2M Server. In LwM2M, there is a mechanism called Queue Mode which offers functionality for a LwM2M Client to inform the LwM2M Server that it may be disconnected for an extended period and when it becomes reachable again. When the LwM2M Client is not reachable, the LwM2M Server does not immediately send downlink requests, but instead waits until the LwM2M Client becomes reachable again.","title":"Network reachability"},{"location":"Network/#flow","text":"A typical Queue Mode sequence follows the steps listed below: The LwM2M Client registers to the LwM2M Server and requests the LwM2M Server to run in Queue mode. The LwM2M Client should use the CoAP constant MAX_TRANSMIT_WAIT (93 seconds) to set a timer for how long it shall stay awake after sending a message to the LwM2M Server. After the timeout expires without any messages from the LwM2M Server, the LwM2M Client enters sleep mode. At some point in time the LwM2M Client wakes up again and transmits a registration update message. Note: During the time the LwM2M Client has been sleeping the IP address assigned to it may have been released and/or existing NAT bindings may have been released. If this is the case, then the client needs to re-run the TLS/DTLS handshake with the LwM2M Server since an IP address and/or port number change will destroy the existing security context. When the LwM2M Server receives a message from the Client, it determines if any messages need to be sent to the LwM2M Client, as instructed by the Application Server.","title":"Flow"},{"location":"Network/#iowa-api","text":"IOWA introduces two APIs to handle the Queue Mode: iowa_flush_before_pause and iowa_client_send_heartbeat . iowa_flush_before_pause is used to inform the LwM2M stack that the device will pause. iowa_flush_before_pause() performs all the pending and required operations of the LwM2M stack engine before returning. It means that if the registration lifetime expires during the device sleep, IOWA will send a registration update before returning from this function. When waking up, the LwM2M Client is connected again to the LwM2M Server. This function also returns a parameter delayP to indicate when the next scheduled IOWA operation is. iowa_client_send_heartbeat is used to send an heartbeat message to a LwM2M Server. Depending of the transport, the heartbeat sent can be a CoAP Empty message on LoRaWAN, or a registration update message for others transports. Below an example in pseudo-code to use these APIs: #include \"iowa_client.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; /****************** * Initialization */ iowaH = iowa_init ( NULL ); iowa_client_configure ( iowaH , \"IOWA_Sample_QM_Client\" , NULL , NULL ); iowa_client_add_server ( iowaH , 1234 , \"coap://localhost:5683\" , 0 , 0 , IOWA_SEC_NONE ); /****************** * \"Main loop\" */ do { uint32_t iowaDelay ; // Run for 93 seconds result = iowa_step ( iowaH , 93 ); // Prepare to stand by for 60 minutes result = iowa_flush_before_pause ( iowaH , 3600 , & iowaDelay ); if ( iowaDelay < 3600 ) { STAND_BY ( iowaDelay ); } else { STAND_BY ( 3600 ); iowa_client_send_heartbeat ( iowaH , 1234 ); } } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_server ( iowaH , 1234 ); iowa_close ( iowaH ); return 0 ; } In the above example, after calling iowa_flush_before_pause , there are two possibilities: iowaDelay is inferior to the requested stand by time. It means that on next iowa_step call, IOWA will send to the Server a message such as notification, registration update, etc. So, the Server will notice the device wake up and send back any buffered requests. Or, iowaDelay is equal to the requested stand by time. In that case, IOWA has nothing to send on next iowa_step() turn. To inform the Server that the device is awake, iowa_client_send_heartbeat needs to be called.","title":"IOWA API"},{"location":"OpenSourceLicenses/","text":"\\clearpage \\appendix \\pagenumbering{roman} Appendix A \u00b6 IOWA reuses code from various open source projects. wakaama is copyrighted by Intel Corporation and others and reused under the Eclipse Distribution License 1.0. Copyright (c) 2013, 2014 Intel Corporation Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Intel Corporation nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Eclipse Distribution License - v 1.0 Copyright (c) 2007, Eclipse Foundation, Inc. and its licensors. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Eclipse Foundation, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. mbed TLS is copyrighted by ARM Limited under the Apache License, Version 2.0. tinydtls is copyrighted by Olaf Bergmann and others and reused under the Eclipse Distribution License 1.0. Copyright (c) 2011, 2012, 2013, 2014, 2015, 2016 Olaf Bergmann (TZI) and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0 which accompanies this distribution. The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse Distribution License is available at http://www.eclipse.org/org/documents/edl-v10.php. Contributors: * Olaf Bergmann - initial API and implementation * Hauke Mehrtens - memory optimization, ECC integration OMA LwM2M objects are copyrighted by Open Mobile Alliance. Copyright 2017 Open Mobile Alliance All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. The above license is used as a license under copyright only. Please reference the OMA IPR Policy for patent licensing terms: http://www.openmobilealliance.org/ipr.html AT Command LwM2M object is copyrighted by Cisco. BSD 3-Clause License Copyright (c) 2017, Cisco All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"OpenSource Licenses"},{"location":"OpenSourceLicenses/#appendix-a","text":"IOWA reuses code from various open source projects. wakaama is copyrighted by Intel Corporation and others and reused under the Eclipse Distribution License 1.0. Copyright (c) 2013, 2014 Intel Corporation Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Intel Corporation nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Eclipse Distribution License - v 1.0 Copyright (c) 2007, Eclipse Foundation, Inc. and its licensors. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Eclipse Foundation, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. mbed TLS is copyrighted by ARM Limited under the Apache License, Version 2.0. tinydtls is copyrighted by Olaf Bergmann and others and reused under the Eclipse Distribution License 1.0. Copyright (c) 2011, 2012, 2013, 2014, 2015, 2016 Olaf Bergmann (TZI) and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0 which accompanies this distribution. The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse Distribution License is available at http://www.eclipse.org/org/documents/edl-v10.php. Contributors: * Olaf Bergmann - initial API and implementation * Hauke Mehrtens - memory optimization, ECC integration OMA LwM2M objects are copyrighted by Open Mobile Alliance. Copyright 2017 Open Mobile Alliance All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. The above license is used as a license under copyright only. Please reference the OMA IPR Policy for patent licensing terms: http://www.openmobilealliance.org/ipr.html AT Command LwM2M object is copyrighted by Cisco. BSD 3-Clause License Copyright (c) 2017, Cisco All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Appendix A"},{"location":"Porting/","text":"Porting IOWA \u00b6 IOWA has been designed to be easily ported to a new platform. All functions contained in the [ System Abstraction Layer ][System Abstraction Layer] are specific to a platform: Allocating / Freeing memory, Getting the time, Rebooting, Sending / Receiving network messages, Storing and retrieving the security keys, And, so on. FreeRTOS will be used here to explain the porting of IOWA on a platform. FreeRTOS configuration \u00b6 FreeRTOS has multiple levels to handle the memory allocation: Heap 1: The basic memory allocation, does not permit a free, Heap 2: Permits memory to be freed, but without coalescence adjacent free blocks, Heap 3: Works in the same way as malloc and free and handles thread safety, Heap 4: Includes the coalescence adjacent free blocks, Heap 5: Adds the ability to span the heap across multiple non-adjacent memory areas. Since IOWA needs to allocate and deallocate memory, the heap 2 is the minimum requirement. But the recommended heap to use with IOWA is heap 4. Moreover, the recommended configuration of FreeRTOSConfig.h is (not all the defines are provided): #define configUSE_16_BIT_TICKS 0 #define configUSE_MUTEXES 1 #define configSUPPORT_STATIC_ALLOCATION 0 #define configSUPPORT_DYNAMIC_ALLOCATION 1 #define configTOTAL_HEAP_SIZE ((size_t)14000) #define configAPPLICATION_ALLOCATED_HEAP 0 #define INCLUDE_vTaskDelay 1 First step \u00b6 To begin, create an empty FreeRTOS project with just the main task to start the scheduler: #include \"FreeRTOS.h\" #include \"task.h\" #include \"semphr.h\" #define INFINITE_LOOP() while (1); int main ( void ) { // Start the scheduler vTaskStartScheduler (); // We should never get here as control is now taken by the scheduler INFINITE_LOOP (); } Generally, IOWA needs two threads to have a working LwM2M Client, but depending of the use case, more threads can be added: The first thread is dedicated to run IOWA and let it handle the LwM2M / CoAP stacks, The other threads are dedicated for the system tasks: measurement, actuator, etc. You can refer to the part of the documentation [ IOWA Multithread Environment ][IOWA Multithread Environment] to have additional information about how IOWA behaves in a multithread environment. Platform abstraction \u00b6 Before continuing the IOWA platform functions have to be implemented: typedef struct { SemaphoreHandle_t globalMutex ; } platform_user_data_t ; void initPlatform ( platform_user_data_t * platformUserDataP ) { platformUserDataP -> globalMutex = xSemaphoreCreateMutex (); xSemaphoreGive ( platformUserDataP -> globalMutex ); } void * iowa_system_malloc ( size_t size ) { return pvPortMalloc ( size ); } void iowa_system_free ( void * pointer ) { vPortFree ( pointer ); } int32_t iowa_system_gettime ( void ) { // Platform dependant } void iowa_system_reboot ( void * userData ) { // Platform dependant or can be a stub function } void iowa_system_trace ( const char * format , va_list varArgs ) { // Platform dependant or can be a stub function } void * iowa_system_connection_open ( iowa_connection_type_t type , char * hostname , char * port , void * userData ) { // Platform dependant } void iowa_system_connection_close ( void * connP , void * userData ) { // Platform dependant } int iowa_system_connection_send ( void * connP , uint8_t * buffer , size_t length , void * userData ) { // Platform dependant } int iowa_system_connection_recv ( void * connP , uint8_t * buffer , size_t length , void * userData ) { // Platform dependant } int iowa_system_connection_select ( void ** connArray , size_t connCount , int32_t timeout , void * userData ) { // Platform dependant } void iowa_system_connection_interrupt_select ( void * userData ) { // Platform dependant } void iowa_system_mutex_lock ( void * userData ) { platform_user_data_t * platformUserDataP ; platformUserDataP = ( platform_user_data_t * ) userData ; xSemaphoreTake ( platformUserDataP -> globalMutex , portMAX_DELAY ); } void iowa_system_mutex_unlock ( void * userData ) { platform_user_data_t * platformUserDataP ; platformUserDataP = ( platform_user_data_t * ) userData ; xSemaphoreGive ( platformUserDataP -> globalMutex ); } Tasks management \u00b6 We can now update the main function to create our two tasks: typedef struct { SemaphoreHandle_t initMutex ; iowa_context_t contextP ; iowa_sensor_t tempSensorId ; } iowa_user_data_t ; void iowa_task ( void const * argument ) { // Task dedicated for IOWA operations iowa_user_data_t * iowaUserDataP ; platform_user_data_t platformUserData ; iowa_status_t result ; initPlatform ( & platformUserData ); iowaUserDataP = ( iowa_user_data_t * ) argument ; // Initialize the IOWA context iowaUserDataP -> contextP = iowa_init ( platformUserData ); if ( iowaUserDataP -> contextP == NULL ) { INFINITE_LOOP (); } // Initialize the Client context result = iowa_client_configure ( iowaUserDataP -> contextP , \"IOWA_Client_FreeRTOS\" , NULL , NULL ); if ( result != IOWA_COAP_NO_ERROR ) { INFINITE_LOOP (); } // Add a server result = iowa_client_add_server ( iowaUserDataP -> contextP , 1234 , \"coap://127.0.0.1:5683\" , 3600 , 0 , IOWA_SEC_NONE ); if ( result != IOWA_COAP_NO_ERROR ) { INFINITE_LOOP (); } // Add a sensor object result = iowa_client_IPSO_add_sensor ( iowaUserDataP -> contextP , IOWA_IPSO_TEMPERATURE , 24 , \"Cel\" , NULL , -20.0 , 50.0 , & ( iowaUserDataP -> tempSensorId )); if ( result != IOWA_COAP_NO_ERROR ) { INFINITE_LOOP (); } xSemaphoreGive ( iowaUserData -> initMutex ); // Synchronization // Start the IOWA step ( void ) iowa_step ( iowaUserDataP -> contextP , -1 ); // We should never get here as control is now taken by IOWA INFINITE_LOOP (); } void system_task ( void const * argument ) { // Task dedicated for system operations iowa_user_data_t * iowaUserDataP ; iowaUserDataP = ( iowa_user_data_t * ) argument ; xSemaphoreTake ( iowaUserData -> initMutex , portMAX_DELAY ); // Synchronization while ( 1 ) { float newValue ; newValue = GET_TEMPERATURE_VALUE (); ( void ) iowa_client_IPSO_update_value ( iowaUserDataP -> contextP , iowaUserDataP -> tempSensorId , newValue ); vTaskDelay ( 5000 ); } } int main ( void ) { iowa_user_data_t iowaUserData ; // Create the init semaphore iowaUserData -> initMutex = xSemaphoreCreateMutex (); // Create the tasks for IOWA xTaskCreate (( TaskFunction_t ) iowa_task , \"iowa\" , 512 , & iowaUserData , tskIDLE_PRIORITY + 2 , NULL ); xTaskCreate (( TaskFunction_t ) system_task , \"system\" , 256 , & iowaUserData , tskIDLE_PRIORITY + 1 , NULL ); // Start the scheduler vTaskStartScheduler (); // We should never get here as control is now taken by the scheduler while ( 1 ); // Infinite loop } Error handling \u00b6 Now everything is working, error handling have to put in place in case something went wrong: Failed to initialize the IOWA stack, Failed to connect to a LwM2M Server, And, so on. IOWA can report events to the Application to inform about internal states such as connection to a LwM2M, new observation started or removed, etc. These events are reported through the callback iowa_event_callback_t , this callback is given when calling the API iowa_client_configure() : void eventCb ( iowa_event_t * eventP , void * userData , iowa_context_t contextP ) { switch ( eventP -> eventType ) { case IOWA_EVENT_REG_FAILED : // Remove then re-add the Server in case the Client wasn't able to reach it iowa_client_remove_server ( contextP , 1234 ); iowa_client_add_server ( contextP , 1234 , \"coap://127.0.0.1:5683\" , 3600 , 0 , IOWA_SEC_NONE ); break ; default : // Do nothing for the other events break ; } } void iowa_task ( void const * argument ) { ... result = iowa_client_configure ( iowaUserDataP -> contextP , \"IOWA_Client_FreeRTOS\" , NULL , eventCb ); ... }","title":"Porting IOWA"},{"location":"Porting/#porting-iowa","text":"IOWA has been designed to be easily ported to a new platform. All functions contained in the [ System Abstraction Layer ][System Abstraction Layer] are specific to a platform: Allocating / Freeing memory, Getting the time, Rebooting, Sending / Receiving network messages, Storing and retrieving the security keys, And, so on. FreeRTOS will be used here to explain the porting of IOWA on a platform.","title":"Porting IOWA"},{"location":"Porting/#freertos-configuration","text":"FreeRTOS has multiple levels to handle the memory allocation: Heap 1: The basic memory allocation, does not permit a free, Heap 2: Permits memory to be freed, but without coalescence adjacent free blocks, Heap 3: Works in the same way as malloc and free and handles thread safety, Heap 4: Includes the coalescence adjacent free blocks, Heap 5: Adds the ability to span the heap across multiple non-adjacent memory areas. Since IOWA needs to allocate and deallocate memory, the heap 2 is the minimum requirement. But the recommended heap to use with IOWA is heap 4. Moreover, the recommended configuration of FreeRTOSConfig.h is (not all the defines are provided): #define configUSE_16_BIT_TICKS 0 #define configUSE_MUTEXES 1 #define configSUPPORT_STATIC_ALLOCATION 0 #define configSUPPORT_DYNAMIC_ALLOCATION 1 #define configTOTAL_HEAP_SIZE ((size_t)14000) #define configAPPLICATION_ALLOCATED_HEAP 0 #define INCLUDE_vTaskDelay 1","title":"FreeRTOS configuration"},{"location":"Porting/#first-step","text":"To begin, create an empty FreeRTOS project with just the main task to start the scheduler: #include \"FreeRTOS.h\" #include \"task.h\" #include \"semphr.h\" #define INFINITE_LOOP() while (1); int main ( void ) { // Start the scheduler vTaskStartScheduler (); // We should never get here as control is now taken by the scheduler INFINITE_LOOP (); } Generally, IOWA needs two threads to have a working LwM2M Client, but depending of the use case, more threads can be added: The first thread is dedicated to run IOWA and let it handle the LwM2M / CoAP stacks, The other threads are dedicated for the system tasks: measurement, actuator, etc. You can refer to the part of the documentation [ IOWA Multithread Environment ][IOWA Multithread Environment] to have additional information about how IOWA behaves in a multithread environment.","title":"First step"},{"location":"Porting/#platform-abstraction","text":"Before continuing the IOWA platform functions have to be implemented: typedef struct { SemaphoreHandle_t globalMutex ; } platform_user_data_t ; void initPlatform ( platform_user_data_t * platformUserDataP ) { platformUserDataP -> globalMutex = xSemaphoreCreateMutex (); xSemaphoreGive ( platformUserDataP -> globalMutex ); } void * iowa_system_malloc ( size_t size ) { return pvPortMalloc ( size ); } void iowa_system_free ( void * pointer ) { vPortFree ( pointer ); } int32_t iowa_system_gettime ( void ) { // Platform dependant } void iowa_system_reboot ( void * userData ) { // Platform dependant or can be a stub function } void iowa_system_trace ( const char * format , va_list varArgs ) { // Platform dependant or can be a stub function } void * iowa_system_connection_open ( iowa_connection_type_t type , char * hostname , char * port , void * userData ) { // Platform dependant } void iowa_system_connection_close ( void * connP , void * userData ) { // Platform dependant } int iowa_system_connection_send ( void * connP , uint8_t * buffer , size_t length , void * userData ) { // Platform dependant } int iowa_system_connection_recv ( void * connP , uint8_t * buffer , size_t length , void * userData ) { // Platform dependant } int iowa_system_connection_select ( void ** connArray , size_t connCount , int32_t timeout , void * userData ) { // Platform dependant } void iowa_system_connection_interrupt_select ( void * userData ) { // Platform dependant } void iowa_system_mutex_lock ( void * userData ) { platform_user_data_t * platformUserDataP ; platformUserDataP = ( platform_user_data_t * ) userData ; xSemaphoreTake ( platformUserDataP -> globalMutex , portMAX_DELAY ); } void iowa_system_mutex_unlock ( void * userData ) { platform_user_data_t * platformUserDataP ; platformUserDataP = ( platform_user_data_t * ) userData ; xSemaphoreGive ( platformUserDataP -> globalMutex ); }","title":"Platform abstraction"},{"location":"Porting/#tasks-management","text":"We can now update the main function to create our two tasks: typedef struct { SemaphoreHandle_t initMutex ; iowa_context_t contextP ; iowa_sensor_t tempSensorId ; } iowa_user_data_t ; void iowa_task ( void const * argument ) { // Task dedicated for IOWA operations iowa_user_data_t * iowaUserDataP ; platform_user_data_t platformUserData ; iowa_status_t result ; initPlatform ( & platformUserData ); iowaUserDataP = ( iowa_user_data_t * ) argument ; // Initialize the IOWA context iowaUserDataP -> contextP = iowa_init ( platformUserData ); if ( iowaUserDataP -> contextP == NULL ) { INFINITE_LOOP (); } // Initialize the Client context result = iowa_client_configure ( iowaUserDataP -> contextP , \"IOWA_Client_FreeRTOS\" , NULL , NULL ); if ( result != IOWA_COAP_NO_ERROR ) { INFINITE_LOOP (); } // Add a server result = iowa_client_add_server ( iowaUserDataP -> contextP , 1234 , \"coap://127.0.0.1:5683\" , 3600 , 0 , IOWA_SEC_NONE ); if ( result != IOWA_COAP_NO_ERROR ) { INFINITE_LOOP (); } // Add a sensor object result = iowa_client_IPSO_add_sensor ( iowaUserDataP -> contextP , IOWA_IPSO_TEMPERATURE , 24 , \"Cel\" , NULL , -20.0 , 50.0 , & ( iowaUserDataP -> tempSensorId )); if ( result != IOWA_COAP_NO_ERROR ) { INFINITE_LOOP (); } xSemaphoreGive ( iowaUserData -> initMutex ); // Synchronization // Start the IOWA step ( void ) iowa_step ( iowaUserDataP -> contextP , -1 ); // We should never get here as control is now taken by IOWA INFINITE_LOOP (); } void system_task ( void const * argument ) { // Task dedicated for system operations iowa_user_data_t * iowaUserDataP ; iowaUserDataP = ( iowa_user_data_t * ) argument ; xSemaphoreTake ( iowaUserData -> initMutex , portMAX_DELAY ); // Synchronization while ( 1 ) { float newValue ; newValue = GET_TEMPERATURE_VALUE (); ( void ) iowa_client_IPSO_update_value ( iowaUserDataP -> contextP , iowaUserDataP -> tempSensorId , newValue ); vTaskDelay ( 5000 ); } } int main ( void ) { iowa_user_data_t iowaUserData ; // Create the init semaphore iowaUserData -> initMutex = xSemaphoreCreateMutex (); // Create the tasks for IOWA xTaskCreate (( TaskFunction_t ) iowa_task , \"iowa\" , 512 , & iowaUserData , tskIDLE_PRIORITY + 2 , NULL ); xTaskCreate (( TaskFunction_t ) system_task , \"system\" , 256 , & iowaUserData , tskIDLE_PRIORITY + 1 , NULL ); // Start the scheduler vTaskStartScheduler (); // We should never get here as control is now taken by the scheduler while ( 1 ); // Infinite loop }","title":"Tasks management"},{"location":"Porting/#error-handling","text":"Now everything is working, error handling have to put in place in case something went wrong: Failed to initialize the IOWA stack, Failed to connect to a LwM2M Server, And, so on. IOWA can report events to the Application to inform about internal states such as connection to a LwM2M, new observation started or removed, etc. These events are reported through the callback iowa_event_callback_t , this callback is given when calling the API iowa_client_configure() : void eventCb ( iowa_event_t * eventP , void * userData , iowa_context_t contextP ) { switch ( eventP -> eventType ) { case IOWA_EVENT_REG_FAILED : // Remove then re-add the Server in case the Client wasn't able to reach it iowa_client_remove_server ( contextP , 1234 ); iowa_client_add_server ( contextP , 1234 , \"coap://127.0.0.1:5683\" , 3600 , 0 , IOWA_SEC_NONE ); break ; default : // Do nothing for the other events break ; } } void iowa_task ( void const * argument ) { ... result = iowa_client_configure ( iowaUserDataP -> contextP , \"IOWA_Client_FreeRTOS\" , NULL , eventCb ); ... }","title":"Error handling"},{"location":"SDK/","text":"IOWA Software Development Kit \u00b6 Content \u00b6 doc : The IOWA APIs reference document. externals : Open source code used by IOWA. include : The IOWA header files. src : The IOWA source code. samples : Sample applications. Samples \u00b6 IOWA SDK comes with several sample applications. Samples Compilation \u00b6 On Linux \u00b6 Prerequisites: An x86-64 computer with a Linux distribution installed, the cmake utility, the make utility and a C compiler. Create a build folder mkdir build Go to this folder cd build Launch cmake in debug mode cmake -DCMAKE_BUILD_TYPE=Debug .. (the last parameter point to the folder containing the CMakeLists.txt file of your target. In this case the one at the root of the repo including all the samples) Build the client and the server make -j 4 ( the -j 4 parameter enables four parallel compilations) After making some modifications to the code, only the step 4 is required. On Windows \u00b6 Using Visual Studio Code \u00b6 Install the Microsoft C++ compiler as explained here: https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=vs-2019 Select the \"Build Tools for Visual Studio 2019\". In the Installer, make sure the following optional features are checked: MSVC v142 - VS 2019 C++ x64/x86 build tools (Note that the version may differ) Windows 10 SDK C++ CMake tools for Windows Install Visual Studio Code from https://code.visualstudio.com/ Launch Visual Studio Code. Go to the \"Extensions\" panel (Ctrl+Shift+X) on the left side. Install the \"C/C++\", \"CMake\", and \"CMake Tools\" extensions Open the folder containing the IOWA Samples (\"File\" menu -> \"Open Folder...\" or \"Ctrl+K Ctrl+O\") Open the CMake panel on the left side. On the top bar of the CMake panel, click on the icon \"Configure All Projects\". When prompted to select a kit, choose one of the Visual Studio Build Tools. On the top bar of the CMake panel, click on the icon \"Build All Projects\". Click on the sample of your choice. Right-click on the application and select \"Run in terminal\" Using Visual Studio with C++ support. \u00b6 Visual Studio version must be at least 2017 for the CMake support. In the Visual Studio menu bar, go to \"File\", \"Open\", \"Folder\". Select the IOWA Samples folder. In the \"Solution Explorer\" windows, right-click on \"CMakeList.txt\" and choose \"Set as Startup Item\". In the Visual Studio menu bar, go to \"Build\", \"Build All\" Testing \u00b6 Without Security \u00b6 Launch the previously built 'server'. Launch the previously built 'client' on the same computer. With PSK security \u00b6 Launch the 'server' previously built. Edit the samples/client/main.c file to go from: // Add the information of a LwM2M Server to connect to result = iowa_client_add_server ( iowaH , SERVER_SHORT_ID , SERVER_URI , 300 , 0 , IOWA_SEC_NONE ); // or if you want to use a secure connection // result = iowa_client_add_server(iowaH, SERVER_SHORT_ID, SERVER_SECURE_URI, 300, 0, IOWA_SEC_PRE_SHARED_KEY); to: // Add the information of a LwM2M Server to connect to // result = iowa_client_add_server(iowaH, SERVER_SHORT_ID, SERVER_URI, 300, 0, IOWA_SEC_NONE); // or if you want to use a secure connection result = iowa_client_add_server ( iowaH , SERVER_SHORT_ID , SERVER_SECURE_URI , 300 , 0 , IOWA_SEC_PRE_SHARED_KEY ); Rebuild and launch 'client'. Build System \u00b6 If you are using cmake as your build system, you can include the file iowa.cmake from the src folder. This file defines several variables: IOWA_HEADERS is the list of all the header files of IOWA, IOWA_SOURCES is the list of all the source files of IOWA, IOWA_INCLUDE_DIR is the path to IOWA header files. Similar to the defines above, iowa.cmake provides additional defines if you only build a IOWA LwM2M Client or a IOWA LwM2M Server: IOWA_CLIENT_HEADERS is the list of all the header files of IOWA Client, IOWA_CLIENT_SOURCES is the list of all the source files of IOWA Client, IOWA_CLIENT_DIR is the path to IOWA Client header files, IOWA_SERVER_HEADERS is the list of all the header files of IOWA Server, IOWA_SERVER_SOURCES is the list of all the source files of IOWA Server, IOWA_SERVER_DIR is the path to IOWA Server header files. Likewise, the folder externals contains the files mbedtls.cmake and tinydtls.cmake which define similar variables to compile mbed TLS or TinyDTLS. Configuration \u00b6 IOWA relies on the compilation flags described below to enable or disable features. These compilation flags can be set in the header file iowa_config.h . Every source file of IOWA includes this header file. To create your product, a template is provided in the include folder. Platform Configuration \u00b6 LWM2M_BIG_ENDIAN and LWM2M_LITTLE_ENDIAN \u00b6 Define one and only one of these two to specify the endianness of your platform. IOWA_BUFFER_SIZE \u00b6 When using a packet switching transport (e.g. UDP), IOWA stores the received data in a static buffer. IOWA_BUFFER_SIZE defines the size in bytes of this static buffer. IOWA_USE_SNPRINTF \u00b6 When using a text content format, IOWA uses snprintf to serialize float which absolute value is greater than INT64_MAX. IOWA Configuration \u00b6 Transports \u00b6 IOWA can support various transports. These transports are enabled by defining the following: IOWA_UDP_SUPPORT : Support for UDP transport. URI scheme is in the form \"coap://\" or \"coaps://\". IOWA_TCP_SUPPORT : Support for TCP transport. URI scheme is in the form \"coap+tcp://\" or \"coaps+tcp://\". IOWA_SMS_SUPPORT : Support for SMS transport. URI scheme is in the form \"coap+sms://\" for text SMS or \"sms://\" for binary SMS. IOWA_LORAWAN_SUPPORT : Support for LoRaWAN transport. URI scheme is in the form \"lorawan://\". Additional flags \u00b6 IOWA_COAP_BLOCK_SUPPORT : Support for full packet fragmentation at CoAP level as defined in RFC 7959 \"Block-Wise Transfers in the Constrained Application Protocol (CoAP)\". IOWA_COAP_BLOCK_MINIMAL_SUPPORT : Support for reassembly of fragmented packets at CoAP level. Automatically defined with IOWA_COAP_BLOCK_SUPPORT . Useful for constrained devices using the \"Push\" method of [Device Update][Device Update]. IOWA_COAP_OSCORE_SUPPORT : Support for security at the CoAP message level using Object Security for Constrained RESTful Environments (RFC 8613). IOWA_SECURITY_LAYER \u00b6 IOWA can use different DTLS/TLS stacks to secure communication between LwM2M Clients and Servers. The possible values for this define are: IOWA_SECURITY_LAYER_NONE : No security features can be used. This is the default value if IOWA_SECURITY_LAYER is not defined. IOWA_SECURITY_LAYER_USER : To provide your security stack. Refer to the [Providing your security implementation][Providing your security implementation] section for details. IOWA_SECURITY_LAYER_MBEDTLS : Use mbed TLS as the DTLS/TLS stack. The sources of mbed TLS are provided in the externals/mbedtls folder. IOWA_SECURITY_LAYER_MBEDTLS_OSCORE_ONLY : Use mbed TLS as the cryptographic stack restricted to OSCORE mode. The sources of mbed TLS are provided in the externals/mbedtls folder. IOWA_SECURITY_LAYER_MBEDTLS_PSK_ONLY : Use mbed TLS as the DTLS/TLS stack restricted to Pre-Shared Key mode. The sources of mbed TLS are provided in the externals/mbedtls folder. IOWA_SECURITY_LAYER_TINYDTLS : Use tinydtls as the DTLS/TLS stack. The sources of tinydtls are provided in the externals/mbedtls folder. Note that tinydtls does not handle certificate based security modes. If security is in use, the platform abstraction functions iowa_system_security_data() and iowa_system_random_vector_generator() must be implemented. Be aware, security increases the ROM/RAM footprints. The mbed TLS or tinyDTLS layer have been configured to keep a good ratio between the ROM/RAM footprints and optimal security. But on constrained devices, the Flash used is small and designed to be optimal (fully used). Thus, if the security layer exceeds the footprints, additional defines can be set depending of the device. These defines are outside of the scope of IOWA. For mbed TLS layer, the following defines can be set in externals/mbedtls/include/mbedtls/config.h : MBEDTLS_AES_ROM_TABLES : Store the pre-computed AES tables in the ROM instead of the RAM. It can reduce RAM usage by ~8kb, but increase ROM usage by ~8kb. MBEDTLS_AES_FEWER_TABLES : Store a smaller pre-computed AES tables in the ROM/RAM. It can reduce the usage by ~6kb, and thus pre-computed AES tables cost only ~2kb. IOWA_LOG_LEVEL and IOWA_LOG_PART \u00b6 These defines configure the traces provided by IOWA. Obviously, having more traces increase the code footprint of IOWA. Note that all traces are provided to the platform abstraction function iowa_system_trace() . IOWA_LOG_LEVEL possible values are: IOWA_LOG_LEVEL_NONE : No traces are generated. This is the default value if IOWA_LOG_LEVEL is not defined. IOWA_LOG_LEVEL_ERROR : Only the most critical errors are reported like calling IOWA APIs with wrong parameters or memory allocation failures. IOWA_LOG_LEVEL_WARNING : Recoverable errors are also reported. IOWA_LOG_LEVEL_INFO : IOWA reports information on major steps of its execution. This is the recommended setting during integration. IOWA_LOG_LEVEL_TRACE : IOWA reports every step of its execution. It is advised to use this value only to provide details when contacting the support. IOWA_LOG_PART is useful to restrict traces to some components of IOWA. It is a combination of the following: IOWA_PART_BASE IOWA APIs and execution. IOWA_PART_COAP the CoAP layer. IOWA_PART_COMM the communication handling. IOWA_PART_DATA the serialization/deserialization payload packet handling. IOWA_PART_LWM2M the Lightweight M2M layer. IOWA_PART_OBJECT the object layer. IOWA_PART_SECURITY the security layer. IOWA_PART_SYSTEM the platform abstraction layer. Additionally, IOWA_PART_ALL is defined as enabling traces of all components. This is the default value if IOWA_LOG_PART is not defined. IOWA_THREAD_SUPPORT \u00b6 When using IOWA in a multithreaded system, defining IOWA_THREAD_SUPPORT enables thread safety in IOWA. This feature requires the platform abstraction functions iowa_system_connection_interrupt_select() , iowa_system_mutex_lock() , and iowa_system_mutex_unlock() to be implemented. IOWA_STORAGE_CONTEXT_SUPPORT \u00b6 IOWA can save and restore its context through the APIs iowa_save_context() , iowa_save_context_snapshot() and iowa_load_context() . This feature requires this compilation flag to be set. This feature allows external data to be saved and restored with the context through callback. Callbacks can be added and deleted through the APIs iowa_backup_register_callback() and iowa_backup_deregister_callback() . This feature requires the platform abstraction functions iowa_system_store_context() and iowa_system_retrieve_context() to be implemented. IOWA_STORAGE_CONTEXT_AUTOMATIC_BACKUP \u00b6 When this flag is set, IOWA would save the LwM2M Client context after every modification by a LwM2M Server or LwM2M Bootstrap Server. This feature does not save the server's runtime information. This is only relevant when IOWA is in Client mode and requires IOWA_STORAGE_CONTEXT_SUPPORT to be set. IOWA_CONFIG_SKIP_SYSTEM_FUNCTION_CHECK \u00b6 This define allows disabling system function checks such as memory allocation. It assumes that system functions can not fail. This define is useful to reduce the code footprint. IOWA_CONFIG_SKIP_ARGS_CHECK \u00b6 This define allows disabling check functions' arguments. It assumes that the functions' arguments are valid. This define is useful to reduce the code footprint. IOWA_LOGGER_USER \u00b6 This define allows implementing your Logger's functions. If not defined, use the IOWA Logger implementation. If this define is set, the platform abstraction functions iowa_log() , iowa_log_arg() , iowa_log_buffer() and iowa_log_arg_buffer() must be implemented. IOWA_PEER_IDENTIFIER_SIZE \u00b6 This is only relevant when IOWA is in Server and/or Bootstrap Server mode. This define is used to set the maximum size of the peer identifier on the network. This is used when the endpoint name is not found in the registration payload and the stack calls iowa_system_connection_get_peer_identifier . LwM2M Configuration \u00b6 LwM2M Role \u00b6 Lightweight M2M defines three possible roles for the elements of a LwM2M system: Client, Server, or Bootstrap Server. You can define the role of your device by defining one of LWM2M_CLIENT_MODE , LWM2M_SERVER_MODE , or LWM2M_BOOTSTRAP_SERVER_MODE . LWM2M_BOOTSTRAP \u00b6 This is only relevant when IOWA is in Client mode. This allows the LwM2M Client to be configured by a LwM2M Bootstrap Server. LwM2M Version \u00b6 LWM2M_VERSION_1_0_REMOVE \u00b6 This disables the default Lightweight M2M version of this stack: LwM2M version 1.0. LWM2M_VERSION_1_1_SUPPORT \u00b6 This enables the support of the LwM2M version 1.1. LwM2M Data Encoding \u00b6 LWM2M_SUPPORT_JSON \u00b6 This enables the support of JSON encoding for LwM2M payload. This support is optional for LwM2M Clients and mandatory for LwM2M Servers. Thus, the feature is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set. Note that JSON is a verbose encoding in LwM2M. Note that JSON encoding is deprecated in LwM2M 1.1. LWM2M_SUPPORT_SENML_JSON \u00b6 This enables the support of SenML JSON encoding for LwM2M 1.1 payload. This support is optional for LwM2M Clients and mandatory for LwM2M Servers: For LwM2M Clients, at least one of the following format must be supported: SenML CBOR or SenML JSON if LWM2M_VERSION_1_1_SUPPORT is set. For LwM2M Servers, the support is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set. Note that SenML JSON is a verbose encoding in LwM2M. LWM2M_SUPPORT_CBOR \u00b6 This enables the support of CBOR encoding for LwM2M 1.1 payloads containing a single resource value. This support is optional for LwM2M Clients and mandatory for LwM2M Servers. This support is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set. LWM2M_SUPPORT_SENML_CBOR \u00b6 This enables the support of SenML CBOR encoding for LwM2M 1.1 payload. This support is optional for LwM2M Clients and mandatory for LwM2M Servers: For LwM2M Clients, at least one of the following format must be supported: SenML CBOR or SenML JSON if LWM2M_VERSION_1_1_SUPPORT is set. For LwM2M Servers, the support is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set. LWM2M_SUPPORT_TLV \u00b6 This enables the support of TLV encoding for LwM2M payload. This support is mandatory in LwM2M 1.0, this means that this feature is automatically set if LWM2M_VERSION_1_0_REMOVE is NOT set. In LwM2M 1.1 and later, this support is optional for LwM2M Clients and mandatory for LwM2M Servers. Thus, the feature is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set if LWM2M_VERSION_1_0_REMOVE is set. Note that TLV encoding is deprecated in LwM2M 1.1. LWM2M_STORAGE_QUEUE_SUPPORT \u00b6 When a LwM2M Server observing some resources is not reachable, the LwM2M Client stores the notifications until the connectivity is restored. By default, IOWA stores the last notifications in memory. When this flag is set, IOWA discharges the storage of these notifications to the platform. This feature requires the system abstraction functions iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_dequeue() , and iowa_system_queue_delete() to be implemented. LWM2M_STORAGE_QUEUE_PEEK_SUPPORT \u00b6 When a LwM2M Server observing some resources is not reachable, the LwM2M Client stores the notifications until the connectivity is restored. By default, IOWA stores the last notifications in memory. When this flag is set, IOWA discharges the storage of these notifications to the platform. New version using a peek/remove mechanism instead of a dequeue mechanism. This feature requires the system abstraction functions iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_peek() , iowa_system_queue_remove() , and iowa_system_queue_delete() to be implemented. LWM2M_SUPPORT_TIMESTAMP \u00b6 This enables the support of the timestamp for notifications. Timestamp can only be used with the following Content format: JSON with [ LWM2M_SUPPORT_JSON ][LWM2M_SUPPORT_JSON] SenML JSON with [ LWM2M_SUPPORT_SENML_JSON ][LWM2M_SUPPORT_SENML_JSON] SenML CBOR with [ LWM2M_SUPPORT_SENML_CBOR ][LWM2M_SUPPORT_SENML_CBOR] LWM2M_ALTPATH_SUPPORT \u00b6 By default, the LwM2M Objects are located under the root path. However, devices might be hosting other CoAP Resources on an endpoint, and there may be the need to place LwM2M Objects under an alternate path. This define allows the use of the Alternate Path. For LwM2M Servers, the support is enabled automatically when LWM2M_SERVER_MODE is set. LWM2M_CLIENT_INCOMING_CONNECTION_SUPPORT \u00b6 This is only relevant when IOWA is in Client mode. When set, this define enables the iowa_client_new_incoming_connection() API. LWM2M_CLIENT_ASYNCHRONOUS_OPERATION_SUPPORT \u00b6 This is only relevant when IOWA is in Client mode. When this compilation flag is activated, operations on LwM2M Objects can be declared as asynchronous. See iowa_client_object_set_mode() . Composite operations \u00b6 The composite operations are automatically enabled when LWM2M_SERVER_MODE and LWM2M_VERSION_1_1_SUPPORT are set. Those features require that either LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR are set. LWM2M_READ_COMPOSITE_SUPPORT \u00b6 This enables the support of the Read-Composite operation defined in LwM2M 1.1. LWM2M_OBSERVE_COMPOSITE_SUPPORT \u00b6 This enables the support of Observe-Composite operation and Read-Composite operation defined in LwM2M 1.1. This means that LWM2M_READ_COMPOSITE_SUPPORT will be automatically set. LWM2M_WRITE_COMPOSITE_SUPPORT \u00b6 This enables the support of the Write-Composite operation defined in LwM2M 1.1. LWM2M_DATA_PUSH_SUPPORT \u00b6 This enables the support of data push operation defined in LwM2M 1.1. This feature requires that either LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR are set. Objects Configuration \u00b6 OMA Objects \u00b6 IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT \u00b6 This enables the support of Access Control List OMA Object. Refer to the [ Access Control List Object ][Access Control List Object] for details. IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT \u00b6 This enables the support of Firmware Update OMA Object. Refer to the [ Firmware Update Object ][Firmware Update Object] for details. IOWA_FIRMWARE_UPDATE_MAX_BLOCK_INTERVAL \u00b6 When the LwM2M Client supports the \"Push\" method of [Device Update][Device Update], and IOWA_COAP_BLOCK_MINIMAL_SUPPORT , this defines the maximum time in seconds to wait between blocks before considering the connection as lost. IOWA_SUPPORT_SOFTWARE_COMPONENT_OBJECT \u00b6 This enables the support of Software Component OMA Object. Refer to the [ Software Component Object ][Software Component Object] for details. IOWA_SUPPORT_SOFTWARE_MANAGEMENT_OBJECT \u00b6 This enables the support of Software Management OMA Object. Refer to the [ Software Management Object ][Software Management Object] for details. APN Connection Profile \u00b6 By default, all the resources of the APN Connection Profile Object are enabled. But they can be disabled by using the following defines: IOWA_APN_CONNECTION_PROFILE_RSC_APN_REMOVE : Disable the resource \"APN\" (Id: 1) IOWA_APN_CONNECTION_PROFILE_RSC_AUTO_SELECT_APN_DEVICE_REMOVE : Disable the resource \"Auto select APN by device\" (Id: 2) IOWA_APN_CONNECTION_PROFILE_RSC_ENABLE_STATUS_REMOVE : Disable the resource \"Enable status\" (Id: 3) IOWA_APN_CONNECTION_PROFILE_RSC_USER_NAME_REMOVE : Disable the resource \"User Name\" (Id: 5) IOWA_APN_CONNECTION_PROFILE_RSC_SECRET_REMOVE : Disable the resource \"Secret\" (Id: 6) IOWA_APN_CONNECTION_PROFILE_RSC_RECONNECT_SCHEDULE_REMOVE : Disable the resource \"Reconnect Schedule\" (Id: 7) IOWA_APN_CONNECTION_PROFILE_RSC_VALIDITY_REMOVE : Disable the resource \"Validity (MCC, MNC)\" (Id: 8) IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_TIME_REMOVE : Disable the resource \"Connection establishment time\" (Id: 9) IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_RESULT_REMOVE : Disable the resource \"Connection establishment result\" (Id: 10) IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_REJECT_CAUSE_REMOVE : Disable the resource \"Connection establishment reject cause\" (Id: 11) IOWA_APN_CONNECTION_PROFILE_RSC_CONNECTION_END_TIME_REMOVE : Disable the resource \"Connection end time\" (Id: 12) IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_SENT_REMOVE : Disable the resource \"TotalBytesSent\" (Id: 13) IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_RECEIVED_REMOVE : Disable the resource \"TotalBytesReceived\" (Id: 14) IOWA_APN_CONNECTION_PROFILE_RSC_IP_ADDRESS_REMOVE : Disable the resource \"IP address\" (Id: 15) IOWA_APN_CONNECTION_PROFILE_RSC_PREFIX_LENGTH_REMOVE : Disable the resource \"Prefix length\" (Id: 16) IOWA_APN_CONNECTION_PROFILE_RSC_SUBNET_MASK_REMOVE : Disable the resource \"Subnet mask\" (Id: 17) IOWA_APN_CONNECTION_PROFILE_RSC_GATEWAY_REMOVE : Disable the resource \"Gateway\" (Id: 18) IOWA_APN_CONNECTION_PROFILE_RSC_PRIMARY_DNS_ADDRESS_REMOVE : Disable the resource \"Primary DNS address\" (Id: 19) IOWA_APN_CONNECTION_PROFILE_RSC_SECONDARY_DNS_ADDRESS_REMOVE : Disable the resource \"Secondary DNS address\" (Id: 20) IOWA_APN_CONNECTION_PROFILE_RSC_QCI_REMOVE : Disable the resource \"QCI\" (Id: 21) IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_PACKETS_SENT_REMOVE : Disable the resource \"TotalPacketsSent\" (Id: 23) IOWA_APN_CONNECTION_PROFILE_RSC_PDN_TYPE_REMOVE : Disable the resource \"PDN Type\" (Id: 24) IOWA_APN_CONNECTION_PROFILE_RSC_APN_RATE_CONTROL_REMOVE : Disable the resource \"APN Rate Control\" (Id: 25) Bearer Selection \u00b6 By default, all the resources of the Bearer Selection Object are enabled. But they can be disabled by using the following defines: IOWA_BEARER_SELECTION_RSC_PREFERRED_COMM_BEARER_REMOVE : Disable the resource \"Preferred Communications Bearer\" (Id: 0) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_GSM_REMOVE : Disable the resource \"Acceptable RSSI (GSM)\" (Id: 1) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSCP_UMTS_REMOVE : Disable the resource \"Acceptable RSCP (UMTS)\" (Id: 2) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_LTE_REMOVE : Disable the resource \"Acceptable RSRP (LTE)\" (Id: 3) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_EV_DO_REMOVE : Disable the resource \"Acceptable RSSI (1xEV-DO)\" (Id: 4) IOWA_BEARER_SELECTION_RSC_CELL_LOCK_LIST_REMOVE : Disable the resource \"Cell lock list\" (Id: 5) IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST_REMOVE : Disable the resource \"Operator list\" (Id: 6) IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST_MODE_REMOVE : Disable the resource \"Operator list mode\" (Id: 7) IOWA_BEARER_SELECTION_RSC_AVAILABLE_PLMNS_REMOVE : Disable the resource \"List of available PLMNs\" (Id: 8) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_NB_IOT_REMOVE : Disable the resource \"Acceptable RSRP (NB-IoT\" (Id: 10) IOWA_BEARER_SELECTION_RSC_PLMN_SEARCH_TIMER_REMOVE : Disable the resource \"Higher Priority PLMN Search Timer\" (Id: 11) IOWA_BEARER_SELECTION_RSC_ATTACH_WO_PDN_CONNECTION_REMOVE : Disable the resource \"Attach without PDN connection\" (Id: 12) Note You can not set all these defines at once, the Object would not have any resource. Cellular Connectivity \u00b6 By default, all the resources of the Cellular Connectivity Object are enabled. But they can be disabled by using the following defines: IOWA_CELLULAR_CONNECTIVITY_RSC_SMSC_ADDRESS_REMOVE : Disable the resource \"SMSC address\" (Id: 0) IOWA_CELLULAR_CONNECTIVITY_RSC_DISABLE_RADIO_PERIOD_REMOVE : Disable the resource \"Disable radio period\" (Id: 1) IOWA_CELLULAR_CONNECTIVITY_RSC_MODULE_ACTIVATION_CODE_REMOVE : Disable the resource \"Module activation code\" (Id: 2) IOWA_CELLULAR_CONNECTIVITY_RSC_PSM_TIMER_REMOVE : Disable the resource \"PSM Timer\" (Id: 4) IOWA_CELLULAR_CONNECTIVITY_RSC_ACTIVE_TIMER_REMOVE : Disable the resource \"Active Timer\" (Id: 5) IOWA_CELLULAR_CONNECTIVITY_RSC_PLMN_RATE_CONTROL_REMOVE : Disable the resource \"Serving PLMN Rate control\" (Id: 6) IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_IU_MODE_REMOVE : Disable the resource \"eDRX parameters for Iu mode\" (Id: 7) IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_WB_S1_MODE_REMOVE : Disable the resource \"eDRX parameters for WB-S1 mode\" (Id: 8) IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_NB_S1_MODE_REMOVE : Disable the resource \"eDRX parameters for NB-S1 mode\" (Id: 9) IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_A_GB_MODE_REMOVE : Disable the resource \"eDRX parameters for A/Gb mode\" (Id: 10) Connectivity Monitoring \u00b6 By default, all the resources of the Connectivity Monitoring Object are enabled. But they can be disabled by using the following defines: IOWA_CONNECTIVITY_MONITORING_RSC_LINK_QUALITY_REMOVE : Disable the resource \"Link Quality\" (Id: 3) IOWA_CONNECTIVITY_MONITORING_RSC_ROUTER_IP_ADDR_REMOVE : Disable the resource \"Router IP Addresses\" (Id: 5) IOWA_CONNECTIVITY_MONITORING_RSC_LINK_USAGE_REMOVE : Disable the resource \"Link Utilization\" (Id: 6) IOWA_CONNECTIVITY_MONITORING_RSC_APN_REMOVE : Disable the resource \"APN\" (Id: 7) IOWA_CONNECTIVITY_MONITORING_RSC_CELL_ID_REMOVE : Disable the resource \"Cell ID\" (Id: 8) IOWA_CONNECTIVITY_MONITORING_RSC_SMNC_REMOVE : Disable the resource \"SMNC\" (Id: 9) IOWA_CONNECTIVITY_MONITORING_RSC_SMCC_REMOVE : Disable the resource \"SMCC\" (Id: 10) Device \u00b6 By default, all the resources of the Device Object are enabled. But they can be disabled by using the following defines: IOWA_DEVICE_RSC_MANUFACTURER_REMOVE : Disable the resource \"Manufacturer\" (Id: 0) IOWA_DEVICE_RSC_MODEL_NUMBER_REMOVE : Disable the resource \"Model Number\" (Id: 1) IOWA_DEVICE_RSC_SERIAL_NUMBER_REMOVE : Disable the resource \"Serial Number\" (Id: 2) IOWA_DEVICE_RSC_FIRMWARE_VERSION_REMOVE : Disable the resource \"Firmware Version\" (Id: 3) IOWA_DEVICE_RSC_FACTORY_RESET_REMOVE : Disable the resource \"Factory Reset\" (Id: 5) IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE : Disable the resources \"Available Power Sources\" (Id: 6), \"Power Source Voltage\" (Id: 7) and \"Power Source Current\" (Id: 8) IOWA_DEVICE_RSC_BATTERY_REMOVE : Disable the resources \"Battery Level\" (Id: 9) and \"Battery Status\" (Id: 20) IOWA_DEVICE_RSC_RESET_ERROR_REMOVE : Disable the resource \"Reset Error Code\" (Id: 12) IOWA_DEVICE_RSC_CURRENT_TIME_REMOVE : Disable the resource \"Current Time\" (Id: 13) IOWA_DEVICE_RSC_UTC_OFFSET_REMOVE : Disable the resource \"UTC Offset\" (Id: 14) IOWA_DEVICE_RSC_TIMEZONE_REMOVE : Disable the resource \"Timezone\" (Id: 15) IOWA_DEVICE_RSC_DEVICE_TYPE_REMOVE : Disable the resource \"Device Type\" (Id: 17) IOWA_DEVICE_RSC_HARDWARE_VERSION_REMOVE : Disable the resource \"Hardware Version\" (Id: 18) IOWA_DEVICE_RSC_SOFTWARE_VERSION_REMOVE : Disable the resource \"Software Version\" (Id: 19) Server \u00b6 By default, all the resources of the Server Object are enabled. But they can be disabled by using the following defines: IOWA_SERVER_RSC_DISABLE_TIMEOUT_REMOVE : Disable resources \"Disable\" (Id: 4) and \"Disable Timeout\" (Id: 5) IOWA_SERVER_RSC_DEFAULT_PERIODS_REMOVE : Disable resources \"Default Minimum Period\" (Id: 2) and \"Default Maximum Period\" (Id: 3) IOWA_SERVER_RSC_BOOTSTRAP_TRIGGER_REMOVE : Disable the resource \"Bootstrap-Request Trigger\" (Id: 9). This resource is also disabled when LWM2M_BOOTSTRAP is not defined. IOWA_SERVER_RSC_REGISTRATION_BEHAVIOUR_REMOVE : Disable resources \"Registration Priority Order\" (Id: 13), \"Initial Registration Delay Timer\" (Id: 14), \"Registration Failure Block\" (Id: 15) and \"Bootstrap on Registration Failure\" (Id: 16). These resources are also disabled when LWM2M_VERSION_1_1_SUPPORT is not defined. IOWA_SERVER_RSC_COMMUNICATION_ATTEMPTS_REMOVE : Disable resources \"Communication Retry Count\" (Id: 17), \"Communication Retry Timer\" (Id: 18), \"Communication Sequence Delay Timer\" (Id: 19) and \"Communication Sequence Retry Count\" (Id: 20). These resources are also disabled when LWM2M_VERSION_1_1_SUPPORT is not defined. IOWA_SERVER_RSC_MUTE_SEND_REMOVE : Disable resources \"Mute Send\" (Id: 23). Only relevant when LWM2M_DATA_PUSH_SUPPORT is set. As well, some resources contain default value which can be updated using the following defines: IOWA_SERVER_RSC_DISABLE_TIMEOUT_DEFAULT_VALUE : Update default resource value of \"Disable Timeout\" (Id: 5) IOWA_SERVER_RSC_STORING_DEFAULT_VALUE : Update default resource value of \"Notification Storing When Disabled or Offline\" (Id: 6) IOWA_SERVER_RSC_MUTE_SEND_DEFAULT_VALUE : Update default resource value of \"Mute Send\" (Id: 23) Light Control \u00b6 By default, all the resources of the Light Control Object are enabled. But they can be disabled by using the following defines: IOWA_LIGHT_CONTROL_RSC_DIMMER_REMOVE : Disable the resource \"Dimmer\" (Id: 5851) IOWA_LIGHT_CONTROL_RSC_ON_TIME_REMOVE : Disable the resource \"On time\" (Id: 5852) IOWA_LIGHT_CONTROL_RSC_CUMULATIVE_ACTIVE_POWER_REMOVE : Disable the resource \"Cumulative active power\" (Id: 5805) IOWA_LIGHT_CONTROL_RSC_POWER_FACTOR_REMOVE : Disable the resource \"Power factor\" (Id: 5820) IOWA_LIGHT_CONTROL_RSC_COLOUR_REMOVE : Disable the resources \"Colour\" (Id: 5706) and \"Sensor Units\" (Id: 5701)","title":"IOWA Software Development Kit"},{"location":"SDK/#iowa-software-development-kit","text":"","title":"IOWA Software Development Kit"},{"location":"SDK/#content","text":"doc : The IOWA APIs reference document. externals : Open source code used by IOWA. include : The IOWA header files. src : The IOWA source code. samples : Sample applications.","title":"Content"},{"location":"SDK/#samples","text":"IOWA SDK comes with several sample applications.","title":"Samples"},{"location":"SDK/#samples-compilation","text":"","title":"Samples Compilation"},{"location":"SDK/#on-linux","text":"Prerequisites: An x86-64 computer with a Linux distribution installed, the cmake utility, the make utility and a C compiler. Create a build folder mkdir build Go to this folder cd build Launch cmake in debug mode cmake -DCMAKE_BUILD_TYPE=Debug .. (the last parameter point to the folder containing the CMakeLists.txt file of your target. In this case the one at the root of the repo including all the samples) Build the client and the server make -j 4 ( the -j 4 parameter enables four parallel compilations) After making some modifications to the code, only the step 4 is required.","title":"On Linux"},{"location":"SDK/#on-windows","text":"","title":"On Windows"},{"location":"SDK/#using-visual-studio-code","text":"Install the Microsoft C++ compiler as explained here: https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=vs-2019 Select the \"Build Tools for Visual Studio 2019\". In the Installer, make sure the following optional features are checked: MSVC v142 - VS 2019 C++ x64/x86 build tools (Note that the version may differ) Windows 10 SDK C++ CMake tools for Windows Install Visual Studio Code from https://code.visualstudio.com/ Launch Visual Studio Code. Go to the \"Extensions\" panel (Ctrl+Shift+X) on the left side. Install the \"C/C++\", \"CMake\", and \"CMake Tools\" extensions Open the folder containing the IOWA Samples (\"File\" menu -> \"Open Folder...\" or \"Ctrl+K Ctrl+O\") Open the CMake panel on the left side. On the top bar of the CMake panel, click on the icon \"Configure All Projects\". When prompted to select a kit, choose one of the Visual Studio Build Tools. On the top bar of the CMake panel, click on the icon \"Build All Projects\". Click on the sample of your choice. Right-click on the application and select \"Run in terminal\"","title":"Using Visual Studio Code"},{"location":"SDK/#using-visual-studio-with-c-support","text":"Visual Studio version must be at least 2017 for the CMake support. In the Visual Studio menu bar, go to \"File\", \"Open\", \"Folder\". Select the IOWA Samples folder. In the \"Solution Explorer\" windows, right-click on \"CMakeList.txt\" and choose \"Set as Startup Item\". In the Visual Studio menu bar, go to \"Build\", \"Build All\"","title":"Using Visual Studio with C++ support."},{"location":"SDK/#testing","text":"","title":"Testing"},{"location":"SDK/#without-security","text":"Launch the previously built 'server'. Launch the previously built 'client' on the same computer.","title":"Without Security"},{"location":"SDK/#with-psk-security","text":"Launch the 'server' previously built. Edit the samples/client/main.c file to go from: // Add the information of a LwM2M Server to connect to result = iowa_client_add_server ( iowaH , SERVER_SHORT_ID , SERVER_URI , 300 , 0 , IOWA_SEC_NONE ); // or if you want to use a secure connection // result = iowa_client_add_server(iowaH, SERVER_SHORT_ID, SERVER_SECURE_URI, 300, 0, IOWA_SEC_PRE_SHARED_KEY); to: // Add the information of a LwM2M Server to connect to // result = iowa_client_add_server(iowaH, SERVER_SHORT_ID, SERVER_URI, 300, 0, IOWA_SEC_NONE); // or if you want to use a secure connection result = iowa_client_add_server ( iowaH , SERVER_SHORT_ID , SERVER_SECURE_URI , 300 , 0 , IOWA_SEC_PRE_SHARED_KEY ); Rebuild and launch 'client'.","title":"With PSK security"},{"location":"SDK/#build-system","text":"If you are using cmake as your build system, you can include the file iowa.cmake from the src folder. This file defines several variables: IOWA_HEADERS is the list of all the header files of IOWA, IOWA_SOURCES is the list of all the source files of IOWA, IOWA_INCLUDE_DIR is the path to IOWA header files. Similar to the defines above, iowa.cmake provides additional defines if you only build a IOWA LwM2M Client or a IOWA LwM2M Server: IOWA_CLIENT_HEADERS is the list of all the header files of IOWA Client, IOWA_CLIENT_SOURCES is the list of all the source files of IOWA Client, IOWA_CLIENT_DIR is the path to IOWA Client header files, IOWA_SERVER_HEADERS is the list of all the header files of IOWA Server, IOWA_SERVER_SOURCES is the list of all the source files of IOWA Server, IOWA_SERVER_DIR is the path to IOWA Server header files. Likewise, the folder externals contains the files mbedtls.cmake and tinydtls.cmake which define similar variables to compile mbed TLS or TinyDTLS.","title":"Build System"},{"location":"SDK/#configuration","text":"IOWA relies on the compilation flags described below to enable or disable features. These compilation flags can be set in the header file iowa_config.h . Every source file of IOWA includes this header file. To create your product, a template is provided in the include folder.","title":"Configuration"},{"location":"SDK/#platform-configuration","text":"","title":"Platform Configuration"},{"location":"SDK/#lwm2m_big_endian-and-lwm2m_little_endian","text":"Define one and only one of these two to specify the endianness of your platform.","title":"LWM2M_BIG_ENDIAN and LWM2M_LITTLE_ENDIAN"},{"location":"SDK/#iowa_buffer_size","text":"When using a packet switching transport (e.g. UDP), IOWA stores the received data in a static buffer. IOWA_BUFFER_SIZE defines the size in bytes of this static buffer.","title":"IOWA_BUFFER_SIZE"},{"location":"SDK/#iowa_use_snprintf","text":"When using a text content format, IOWA uses snprintf to serialize float which absolute value is greater than INT64_MAX.","title":"IOWA_USE_SNPRINTF"},{"location":"SDK/#iowa-configuration","text":"","title":"IOWA Configuration"},{"location":"SDK/#transports","text":"IOWA can support various transports. These transports are enabled by defining the following: IOWA_UDP_SUPPORT : Support for UDP transport. URI scheme is in the form \"coap://\" or \"coaps://\". IOWA_TCP_SUPPORT : Support for TCP transport. URI scheme is in the form \"coap+tcp://\" or \"coaps+tcp://\". IOWA_SMS_SUPPORT : Support for SMS transport. URI scheme is in the form \"coap+sms://\" for text SMS or \"sms://\" for binary SMS. IOWA_LORAWAN_SUPPORT : Support for LoRaWAN transport. URI scheme is in the form \"lorawan://\".","title":"Transports"},{"location":"SDK/#additional-flags","text":"IOWA_COAP_BLOCK_SUPPORT : Support for full packet fragmentation at CoAP level as defined in RFC 7959 \"Block-Wise Transfers in the Constrained Application Protocol (CoAP)\". IOWA_COAP_BLOCK_MINIMAL_SUPPORT : Support for reassembly of fragmented packets at CoAP level. Automatically defined with IOWA_COAP_BLOCK_SUPPORT . Useful for constrained devices using the \"Push\" method of [Device Update][Device Update]. IOWA_COAP_OSCORE_SUPPORT : Support for security at the CoAP message level using Object Security for Constrained RESTful Environments (RFC 8613).","title":"Additional flags"},{"location":"SDK/#iowa_security_layer","text":"IOWA can use different DTLS/TLS stacks to secure communication between LwM2M Clients and Servers. The possible values for this define are: IOWA_SECURITY_LAYER_NONE : No security features can be used. This is the default value if IOWA_SECURITY_LAYER is not defined. IOWA_SECURITY_LAYER_USER : To provide your security stack. Refer to the [Providing your security implementation][Providing your security implementation] section for details. IOWA_SECURITY_LAYER_MBEDTLS : Use mbed TLS as the DTLS/TLS stack. The sources of mbed TLS are provided in the externals/mbedtls folder. IOWA_SECURITY_LAYER_MBEDTLS_OSCORE_ONLY : Use mbed TLS as the cryptographic stack restricted to OSCORE mode. The sources of mbed TLS are provided in the externals/mbedtls folder. IOWA_SECURITY_LAYER_MBEDTLS_PSK_ONLY : Use mbed TLS as the DTLS/TLS stack restricted to Pre-Shared Key mode. The sources of mbed TLS are provided in the externals/mbedtls folder. IOWA_SECURITY_LAYER_TINYDTLS : Use tinydtls as the DTLS/TLS stack. The sources of tinydtls are provided in the externals/mbedtls folder. Note that tinydtls does not handle certificate based security modes. If security is in use, the platform abstraction functions iowa_system_security_data() and iowa_system_random_vector_generator() must be implemented. Be aware, security increases the ROM/RAM footprints. The mbed TLS or tinyDTLS layer have been configured to keep a good ratio between the ROM/RAM footprints and optimal security. But on constrained devices, the Flash used is small and designed to be optimal (fully used). Thus, if the security layer exceeds the footprints, additional defines can be set depending of the device. These defines are outside of the scope of IOWA. For mbed TLS layer, the following defines can be set in externals/mbedtls/include/mbedtls/config.h : MBEDTLS_AES_ROM_TABLES : Store the pre-computed AES tables in the ROM instead of the RAM. It can reduce RAM usage by ~8kb, but increase ROM usage by ~8kb. MBEDTLS_AES_FEWER_TABLES : Store a smaller pre-computed AES tables in the ROM/RAM. It can reduce the usage by ~6kb, and thus pre-computed AES tables cost only ~2kb.","title":"IOWA_SECURITY_LAYER"},{"location":"SDK/#iowa_log_level-and-iowa_log_part","text":"These defines configure the traces provided by IOWA. Obviously, having more traces increase the code footprint of IOWA. Note that all traces are provided to the platform abstraction function iowa_system_trace() . IOWA_LOG_LEVEL possible values are: IOWA_LOG_LEVEL_NONE : No traces are generated. This is the default value if IOWA_LOG_LEVEL is not defined. IOWA_LOG_LEVEL_ERROR : Only the most critical errors are reported like calling IOWA APIs with wrong parameters or memory allocation failures. IOWA_LOG_LEVEL_WARNING : Recoverable errors are also reported. IOWA_LOG_LEVEL_INFO : IOWA reports information on major steps of its execution. This is the recommended setting during integration. IOWA_LOG_LEVEL_TRACE : IOWA reports every step of its execution. It is advised to use this value only to provide details when contacting the support. IOWA_LOG_PART is useful to restrict traces to some components of IOWA. It is a combination of the following: IOWA_PART_BASE IOWA APIs and execution. IOWA_PART_COAP the CoAP layer. IOWA_PART_COMM the communication handling. IOWA_PART_DATA the serialization/deserialization payload packet handling. IOWA_PART_LWM2M the Lightweight M2M layer. IOWA_PART_OBJECT the object layer. IOWA_PART_SECURITY the security layer. IOWA_PART_SYSTEM the platform abstraction layer. Additionally, IOWA_PART_ALL is defined as enabling traces of all components. This is the default value if IOWA_LOG_PART is not defined.","title":"IOWA_LOG_LEVEL and IOWA_LOG_PART"},{"location":"SDK/#iowa_thread_support","text":"When using IOWA in a multithreaded system, defining IOWA_THREAD_SUPPORT enables thread safety in IOWA. This feature requires the platform abstraction functions iowa_system_connection_interrupt_select() , iowa_system_mutex_lock() , and iowa_system_mutex_unlock() to be implemented.","title":"IOWA_THREAD_SUPPORT"},{"location":"SDK/#iowa_storage_context_support","text":"IOWA can save and restore its context through the APIs iowa_save_context() , iowa_save_context_snapshot() and iowa_load_context() . This feature requires this compilation flag to be set. This feature allows external data to be saved and restored with the context through callback. Callbacks can be added and deleted through the APIs iowa_backup_register_callback() and iowa_backup_deregister_callback() . This feature requires the platform abstraction functions iowa_system_store_context() and iowa_system_retrieve_context() to be implemented.","title":"IOWA_STORAGE_CONTEXT_SUPPORT"},{"location":"SDK/#iowa_storage_context_automatic_backup","text":"When this flag is set, IOWA would save the LwM2M Client context after every modification by a LwM2M Server or LwM2M Bootstrap Server. This feature does not save the server's runtime information. This is only relevant when IOWA is in Client mode and requires IOWA_STORAGE_CONTEXT_SUPPORT to be set.","title":"IOWA_STORAGE_CONTEXT_AUTOMATIC_BACKUP"},{"location":"SDK/#iowa_config_skip_system_function_check","text":"This define allows disabling system function checks such as memory allocation. It assumes that system functions can not fail. This define is useful to reduce the code footprint.","title":"IOWA_CONFIG_SKIP_SYSTEM_FUNCTION_CHECK"},{"location":"SDK/#iowa_config_skip_args_check","text":"This define allows disabling check functions' arguments. It assumes that the functions' arguments are valid. This define is useful to reduce the code footprint.","title":"IOWA_CONFIG_SKIP_ARGS_CHECK"},{"location":"SDK/#iowa_logger_user","text":"This define allows implementing your Logger's functions. If not defined, use the IOWA Logger implementation. If this define is set, the platform abstraction functions iowa_log() , iowa_log_arg() , iowa_log_buffer() and iowa_log_arg_buffer() must be implemented.","title":"IOWA_LOGGER_USER"},{"location":"SDK/#iowa_peer_identifier_size","text":"This is only relevant when IOWA is in Server and/or Bootstrap Server mode. This define is used to set the maximum size of the peer identifier on the network. This is used when the endpoint name is not found in the registration payload and the stack calls iowa_system_connection_get_peer_identifier .","title":"IOWA_PEER_IDENTIFIER_SIZE"},{"location":"SDK/#lwm2m-configuration","text":"","title":"LwM2M Configuration"},{"location":"SDK/#lwm2m-role","text":"Lightweight M2M defines three possible roles for the elements of a LwM2M system: Client, Server, or Bootstrap Server. You can define the role of your device by defining one of LWM2M_CLIENT_MODE , LWM2M_SERVER_MODE , or LWM2M_BOOTSTRAP_SERVER_MODE .","title":"LwM2M Role"},{"location":"SDK/#lwm2m_bootstrap","text":"This is only relevant when IOWA is in Client mode. This allows the LwM2M Client to be configured by a LwM2M Bootstrap Server.","title":"LWM2M_BOOTSTRAP"},{"location":"SDK/#lwm2m-version","text":"","title":"LwM2M Version"},{"location":"SDK/#lwm2m_version_1_0_remove","text":"This disables the default Lightweight M2M version of this stack: LwM2M version 1.0.","title":"LWM2M_VERSION_1_0_REMOVE"},{"location":"SDK/#lwm2m_version_1_1_support","text":"This enables the support of the LwM2M version 1.1.","title":"LWM2M_VERSION_1_1_SUPPORT"},{"location":"SDK/#lwm2m-data-encoding","text":"","title":"LwM2M Data Encoding"},{"location":"SDK/#lwm2m_support_json","text":"This enables the support of JSON encoding for LwM2M payload. This support is optional for LwM2M Clients and mandatory for LwM2M Servers. Thus, the feature is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set. Note that JSON is a verbose encoding in LwM2M. Note that JSON encoding is deprecated in LwM2M 1.1.","title":"LWM2M_SUPPORT_JSON"},{"location":"SDK/#lwm2m_support_senml_json","text":"This enables the support of SenML JSON encoding for LwM2M 1.1 payload. This support is optional for LwM2M Clients and mandatory for LwM2M Servers: For LwM2M Clients, at least one of the following format must be supported: SenML CBOR or SenML JSON if LWM2M_VERSION_1_1_SUPPORT is set. For LwM2M Servers, the support is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set. Note that SenML JSON is a verbose encoding in LwM2M.","title":"LWM2M_SUPPORT_SENML_JSON"},{"location":"SDK/#lwm2m_support_cbor","text":"This enables the support of CBOR encoding for LwM2M 1.1 payloads containing a single resource value. This support is optional for LwM2M Clients and mandatory for LwM2M Servers. This support is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set.","title":"LWM2M_SUPPORT_CBOR"},{"location":"SDK/#lwm2m_support_senml_cbor","text":"This enables the support of SenML CBOR encoding for LwM2M 1.1 payload. This support is optional for LwM2M Clients and mandatory for LwM2M Servers: For LwM2M Clients, at least one of the following format must be supported: SenML CBOR or SenML JSON if LWM2M_VERSION_1_1_SUPPORT is set. For LwM2M Servers, the support is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set.","title":"LWM2M_SUPPORT_SENML_CBOR"},{"location":"SDK/#lwm2m_support_tlv","text":"This enables the support of TLV encoding for LwM2M payload. This support is mandatory in LwM2M 1.0, this means that this feature is automatically set if LWM2M_VERSION_1_0_REMOVE is NOT set. In LwM2M 1.1 and later, this support is optional for LwM2M Clients and mandatory for LwM2M Servers. Thus, the feature is enabled automatically when LWM2M_SERVER_MODE or LWM2M_BOOTSTRAP_SERVER_MODE are set if LWM2M_VERSION_1_0_REMOVE is set. Note that TLV encoding is deprecated in LwM2M 1.1.","title":"LWM2M_SUPPORT_TLV"},{"location":"SDK/#lwm2m_storage_queue_support","text":"When a LwM2M Server observing some resources is not reachable, the LwM2M Client stores the notifications until the connectivity is restored. By default, IOWA stores the last notifications in memory. When this flag is set, IOWA discharges the storage of these notifications to the platform. This feature requires the system abstraction functions iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_dequeue() , and iowa_system_queue_delete() to be implemented.","title":"LWM2M_STORAGE_QUEUE_SUPPORT"},{"location":"SDK/#lwm2m_storage_queue_peek_support","text":"When a LwM2M Server observing some resources is not reachable, the LwM2M Client stores the notifications until the connectivity is restored. By default, IOWA stores the last notifications in memory. When this flag is set, IOWA discharges the storage of these notifications to the platform. New version using a peek/remove mechanism instead of a dequeue mechanism. This feature requires the system abstraction functions iowa_system_queue_create() , iowa_system_queue_enqueue() , iowa_system_queue_peek() , iowa_system_queue_remove() , and iowa_system_queue_delete() to be implemented.","title":"LWM2M_STORAGE_QUEUE_PEEK_SUPPORT"},{"location":"SDK/#lwm2m_support_timestamp","text":"This enables the support of the timestamp for notifications. Timestamp can only be used with the following Content format: JSON with [ LWM2M_SUPPORT_JSON ][LWM2M_SUPPORT_JSON] SenML JSON with [ LWM2M_SUPPORT_SENML_JSON ][LWM2M_SUPPORT_SENML_JSON] SenML CBOR with [ LWM2M_SUPPORT_SENML_CBOR ][LWM2M_SUPPORT_SENML_CBOR]","title":"LWM2M_SUPPORT_TIMESTAMP"},{"location":"SDK/#lwm2m_altpath_support","text":"By default, the LwM2M Objects are located under the root path. However, devices might be hosting other CoAP Resources on an endpoint, and there may be the need to place LwM2M Objects under an alternate path. This define allows the use of the Alternate Path. For LwM2M Servers, the support is enabled automatically when LWM2M_SERVER_MODE is set.","title":"LWM2M_ALTPATH_SUPPORT"},{"location":"SDK/#lwm2m_client_incoming_connection_support","text":"This is only relevant when IOWA is in Client mode. When set, this define enables the iowa_client_new_incoming_connection() API.","title":"LWM2M_CLIENT_INCOMING_CONNECTION_SUPPORT"},{"location":"SDK/#lwm2m_client_asynchronous_operation_support","text":"This is only relevant when IOWA is in Client mode. When this compilation flag is activated, operations on LwM2M Objects can be declared as asynchronous. See iowa_client_object_set_mode() .","title":"LWM2M_CLIENT_ASYNCHRONOUS_OPERATION_SUPPORT"},{"location":"SDK/#composite-operations","text":"The composite operations are automatically enabled when LWM2M_SERVER_MODE and LWM2M_VERSION_1_1_SUPPORT are set. Those features require that either LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR are set.","title":"Composite operations"},{"location":"SDK/#lwm2m_read_composite_support","text":"This enables the support of the Read-Composite operation defined in LwM2M 1.1.","title":"LWM2M_READ_COMPOSITE_SUPPORT"},{"location":"SDK/#lwm2m_observe_composite_support","text":"This enables the support of Observe-Composite operation and Read-Composite operation defined in LwM2M 1.1. This means that LWM2M_READ_COMPOSITE_SUPPORT will be automatically set.","title":"LWM2M_OBSERVE_COMPOSITE_SUPPORT"},{"location":"SDK/#lwm2m_write_composite_support","text":"This enables the support of the Write-Composite operation defined in LwM2M 1.1.","title":"LWM2M_WRITE_COMPOSITE_SUPPORT"},{"location":"SDK/#lwm2m_data_push_support","text":"This enables the support of data push operation defined in LwM2M 1.1. This feature requires that either LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR are set.","title":"LWM2M_DATA_PUSH_SUPPORT"},{"location":"SDK/#objects-configuration","text":"","title":"Objects Configuration"},{"location":"SDK/#oma-objects","text":"","title":"OMA Objects"},{"location":"SDK/#iowa_support_access_control_list_object","text":"This enables the support of Access Control List OMA Object. Refer to the [ Access Control List Object ][Access Control List Object] for details.","title":"IOWA_SUPPORT_ACCESS_CONTROL_LIST_OBJECT"},{"location":"SDK/#iowa_support_firmware_update_object","text":"This enables the support of Firmware Update OMA Object. Refer to the [ Firmware Update Object ][Firmware Update Object] for details.","title":"IOWA_SUPPORT_FIRMWARE_UPDATE_OBJECT"},{"location":"SDK/#iowa_firmware_update_max_block_interval","text":"When the LwM2M Client supports the \"Push\" method of [Device Update][Device Update], and IOWA_COAP_BLOCK_MINIMAL_SUPPORT , this defines the maximum time in seconds to wait between blocks before considering the connection as lost.","title":"IOWA_FIRMWARE_UPDATE_MAX_BLOCK_INTERVAL"},{"location":"SDK/#iowa_support_software_component_object","text":"This enables the support of Software Component OMA Object. Refer to the [ Software Component Object ][Software Component Object] for details.","title":"IOWA_SUPPORT_SOFTWARE_COMPONENT_OBJECT"},{"location":"SDK/#iowa_support_software_management_object","text":"This enables the support of Software Management OMA Object. Refer to the [ Software Management Object ][Software Management Object] for details.","title":"IOWA_SUPPORT_SOFTWARE_MANAGEMENT_OBJECT"},{"location":"SDK/#apn-connection-profile","text":"By default, all the resources of the APN Connection Profile Object are enabled. But they can be disabled by using the following defines: IOWA_APN_CONNECTION_PROFILE_RSC_APN_REMOVE : Disable the resource \"APN\" (Id: 1) IOWA_APN_CONNECTION_PROFILE_RSC_AUTO_SELECT_APN_DEVICE_REMOVE : Disable the resource \"Auto select APN by device\" (Id: 2) IOWA_APN_CONNECTION_PROFILE_RSC_ENABLE_STATUS_REMOVE : Disable the resource \"Enable status\" (Id: 3) IOWA_APN_CONNECTION_PROFILE_RSC_USER_NAME_REMOVE : Disable the resource \"User Name\" (Id: 5) IOWA_APN_CONNECTION_PROFILE_RSC_SECRET_REMOVE : Disable the resource \"Secret\" (Id: 6) IOWA_APN_CONNECTION_PROFILE_RSC_RECONNECT_SCHEDULE_REMOVE : Disable the resource \"Reconnect Schedule\" (Id: 7) IOWA_APN_CONNECTION_PROFILE_RSC_VALIDITY_REMOVE : Disable the resource \"Validity (MCC, MNC)\" (Id: 8) IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_TIME_REMOVE : Disable the resource \"Connection establishment time\" (Id: 9) IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_RESULT_REMOVE : Disable the resource \"Connection establishment result\" (Id: 10) IOWA_APN_CONNECTION_PROFILE_RSC_CONN_ESTABLISHMENT_REJECT_CAUSE_REMOVE : Disable the resource \"Connection establishment reject cause\" (Id: 11) IOWA_APN_CONNECTION_PROFILE_RSC_CONNECTION_END_TIME_REMOVE : Disable the resource \"Connection end time\" (Id: 12) IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_SENT_REMOVE : Disable the resource \"TotalBytesSent\" (Id: 13) IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_BYTES_RECEIVED_REMOVE : Disable the resource \"TotalBytesReceived\" (Id: 14) IOWA_APN_CONNECTION_PROFILE_RSC_IP_ADDRESS_REMOVE : Disable the resource \"IP address\" (Id: 15) IOWA_APN_CONNECTION_PROFILE_RSC_PREFIX_LENGTH_REMOVE : Disable the resource \"Prefix length\" (Id: 16) IOWA_APN_CONNECTION_PROFILE_RSC_SUBNET_MASK_REMOVE : Disable the resource \"Subnet mask\" (Id: 17) IOWA_APN_CONNECTION_PROFILE_RSC_GATEWAY_REMOVE : Disable the resource \"Gateway\" (Id: 18) IOWA_APN_CONNECTION_PROFILE_RSC_PRIMARY_DNS_ADDRESS_REMOVE : Disable the resource \"Primary DNS address\" (Id: 19) IOWA_APN_CONNECTION_PROFILE_RSC_SECONDARY_DNS_ADDRESS_REMOVE : Disable the resource \"Secondary DNS address\" (Id: 20) IOWA_APN_CONNECTION_PROFILE_RSC_QCI_REMOVE : Disable the resource \"QCI\" (Id: 21) IOWA_APN_CONNECTION_PROFILE_RSC_TOTAL_PACKETS_SENT_REMOVE : Disable the resource \"TotalPacketsSent\" (Id: 23) IOWA_APN_CONNECTION_PROFILE_RSC_PDN_TYPE_REMOVE : Disable the resource \"PDN Type\" (Id: 24) IOWA_APN_CONNECTION_PROFILE_RSC_APN_RATE_CONTROL_REMOVE : Disable the resource \"APN Rate Control\" (Id: 25)","title":"APN Connection Profile"},{"location":"SDK/#bearer-selection","text":"By default, all the resources of the Bearer Selection Object are enabled. But they can be disabled by using the following defines: IOWA_BEARER_SELECTION_RSC_PREFERRED_COMM_BEARER_REMOVE : Disable the resource \"Preferred Communications Bearer\" (Id: 0) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_GSM_REMOVE : Disable the resource \"Acceptable RSSI (GSM)\" (Id: 1) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSCP_UMTS_REMOVE : Disable the resource \"Acceptable RSCP (UMTS)\" (Id: 2) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_LTE_REMOVE : Disable the resource \"Acceptable RSRP (LTE)\" (Id: 3) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSSI_EV_DO_REMOVE : Disable the resource \"Acceptable RSSI (1xEV-DO)\" (Id: 4) IOWA_BEARER_SELECTION_RSC_CELL_LOCK_LIST_REMOVE : Disable the resource \"Cell lock list\" (Id: 5) IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST_REMOVE : Disable the resource \"Operator list\" (Id: 6) IOWA_BEARER_SELECTION_RSC_OPERATOR_LIST_MODE_REMOVE : Disable the resource \"Operator list mode\" (Id: 7) IOWA_BEARER_SELECTION_RSC_AVAILABLE_PLMNS_REMOVE : Disable the resource \"List of available PLMNs\" (Id: 8) IOWA_BEARER_SELECTION_RSC_ACCEPTABLE_RSRP_NB_IOT_REMOVE : Disable the resource \"Acceptable RSRP (NB-IoT\" (Id: 10) IOWA_BEARER_SELECTION_RSC_PLMN_SEARCH_TIMER_REMOVE : Disable the resource \"Higher Priority PLMN Search Timer\" (Id: 11) IOWA_BEARER_SELECTION_RSC_ATTACH_WO_PDN_CONNECTION_REMOVE : Disable the resource \"Attach without PDN connection\" (Id: 12) Note You can not set all these defines at once, the Object would not have any resource.","title":"Bearer Selection"},{"location":"SDK/#cellular-connectivity","text":"By default, all the resources of the Cellular Connectivity Object are enabled. But they can be disabled by using the following defines: IOWA_CELLULAR_CONNECTIVITY_RSC_SMSC_ADDRESS_REMOVE : Disable the resource \"SMSC address\" (Id: 0) IOWA_CELLULAR_CONNECTIVITY_RSC_DISABLE_RADIO_PERIOD_REMOVE : Disable the resource \"Disable radio period\" (Id: 1) IOWA_CELLULAR_CONNECTIVITY_RSC_MODULE_ACTIVATION_CODE_REMOVE : Disable the resource \"Module activation code\" (Id: 2) IOWA_CELLULAR_CONNECTIVITY_RSC_PSM_TIMER_REMOVE : Disable the resource \"PSM Timer\" (Id: 4) IOWA_CELLULAR_CONNECTIVITY_RSC_ACTIVE_TIMER_REMOVE : Disable the resource \"Active Timer\" (Id: 5) IOWA_CELLULAR_CONNECTIVITY_RSC_PLMN_RATE_CONTROL_REMOVE : Disable the resource \"Serving PLMN Rate control\" (Id: 6) IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_IU_MODE_REMOVE : Disable the resource \"eDRX parameters for Iu mode\" (Id: 7) IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_WB_S1_MODE_REMOVE : Disable the resource \"eDRX parameters for WB-S1 mode\" (Id: 8) IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_NB_S1_MODE_REMOVE : Disable the resource \"eDRX parameters for NB-S1 mode\" (Id: 9) IOWA_CELLULAR_CONNECTIVITY_RSC_EDRX_PARAM_A_GB_MODE_REMOVE : Disable the resource \"eDRX parameters for A/Gb mode\" (Id: 10)","title":"Cellular Connectivity"},{"location":"SDK/#connectivity-monitoring","text":"By default, all the resources of the Connectivity Monitoring Object are enabled. But they can be disabled by using the following defines: IOWA_CONNECTIVITY_MONITORING_RSC_LINK_QUALITY_REMOVE : Disable the resource \"Link Quality\" (Id: 3) IOWA_CONNECTIVITY_MONITORING_RSC_ROUTER_IP_ADDR_REMOVE : Disable the resource \"Router IP Addresses\" (Id: 5) IOWA_CONNECTIVITY_MONITORING_RSC_LINK_USAGE_REMOVE : Disable the resource \"Link Utilization\" (Id: 6) IOWA_CONNECTIVITY_MONITORING_RSC_APN_REMOVE : Disable the resource \"APN\" (Id: 7) IOWA_CONNECTIVITY_MONITORING_RSC_CELL_ID_REMOVE : Disable the resource \"Cell ID\" (Id: 8) IOWA_CONNECTIVITY_MONITORING_RSC_SMNC_REMOVE : Disable the resource \"SMNC\" (Id: 9) IOWA_CONNECTIVITY_MONITORING_RSC_SMCC_REMOVE : Disable the resource \"SMCC\" (Id: 10)","title":"Connectivity Monitoring"},{"location":"SDK/#device","text":"By default, all the resources of the Device Object are enabled. But they can be disabled by using the following defines: IOWA_DEVICE_RSC_MANUFACTURER_REMOVE : Disable the resource \"Manufacturer\" (Id: 0) IOWA_DEVICE_RSC_MODEL_NUMBER_REMOVE : Disable the resource \"Model Number\" (Id: 1) IOWA_DEVICE_RSC_SERIAL_NUMBER_REMOVE : Disable the resource \"Serial Number\" (Id: 2) IOWA_DEVICE_RSC_FIRMWARE_VERSION_REMOVE : Disable the resource \"Firmware Version\" (Id: 3) IOWA_DEVICE_RSC_FACTORY_RESET_REMOVE : Disable the resource \"Factory Reset\" (Id: 5) IOWA_DEVICE_RSC_POWER_SOURCE_REMOVE : Disable the resources \"Available Power Sources\" (Id: 6), \"Power Source Voltage\" (Id: 7) and \"Power Source Current\" (Id: 8) IOWA_DEVICE_RSC_BATTERY_REMOVE : Disable the resources \"Battery Level\" (Id: 9) and \"Battery Status\" (Id: 20) IOWA_DEVICE_RSC_RESET_ERROR_REMOVE : Disable the resource \"Reset Error Code\" (Id: 12) IOWA_DEVICE_RSC_CURRENT_TIME_REMOVE : Disable the resource \"Current Time\" (Id: 13) IOWA_DEVICE_RSC_UTC_OFFSET_REMOVE : Disable the resource \"UTC Offset\" (Id: 14) IOWA_DEVICE_RSC_TIMEZONE_REMOVE : Disable the resource \"Timezone\" (Id: 15) IOWA_DEVICE_RSC_DEVICE_TYPE_REMOVE : Disable the resource \"Device Type\" (Id: 17) IOWA_DEVICE_RSC_HARDWARE_VERSION_REMOVE : Disable the resource \"Hardware Version\" (Id: 18) IOWA_DEVICE_RSC_SOFTWARE_VERSION_REMOVE : Disable the resource \"Software Version\" (Id: 19)","title":"Device"},{"location":"SDK/#server","text":"By default, all the resources of the Server Object are enabled. But they can be disabled by using the following defines: IOWA_SERVER_RSC_DISABLE_TIMEOUT_REMOVE : Disable resources \"Disable\" (Id: 4) and \"Disable Timeout\" (Id: 5) IOWA_SERVER_RSC_DEFAULT_PERIODS_REMOVE : Disable resources \"Default Minimum Period\" (Id: 2) and \"Default Maximum Period\" (Id: 3) IOWA_SERVER_RSC_BOOTSTRAP_TRIGGER_REMOVE : Disable the resource \"Bootstrap-Request Trigger\" (Id: 9). This resource is also disabled when LWM2M_BOOTSTRAP is not defined. IOWA_SERVER_RSC_REGISTRATION_BEHAVIOUR_REMOVE : Disable resources \"Registration Priority Order\" (Id: 13), \"Initial Registration Delay Timer\" (Id: 14), \"Registration Failure Block\" (Id: 15) and \"Bootstrap on Registration Failure\" (Id: 16). These resources are also disabled when LWM2M_VERSION_1_1_SUPPORT is not defined. IOWA_SERVER_RSC_COMMUNICATION_ATTEMPTS_REMOVE : Disable resources \"Communication Retry Count\" (Id: 17), \"Communication Retry Timer\" (Id: 18), \"Communication Sequence Delay Timer\" (Id: 19) and \"Communication Sequence Retry Count\" (Id: 20). These resources are also disabled when LWM2M_VERSION_1_1_SUPPORT is not defined. IOWA_SERVER_RSC_MUTE_SEND_REMOVE : Disable resources \"Mute Send\" (Id: 23). Only relevant when LWM2M_DATA_PUSH_SUPPORT is set. As well, some resources contain default value which can be updated using the following defines: IOWA_SERVER_RSC_DISABLE_TIMEOUT_DEFAULT_VALUE : Update default resource value of \"Disable Timeout\" (Id: 5) IOWA_SERVER_RSC_STORING_DEFAULT_VALUE : Update default resource value of \"Notification Storing When Disabled or Offline\" (Id: 6) IOWA_SERVER_RSC_MUTE_SEND_DEFAULT_VALUE : Update default resource value of \"Mute Send\" (Id: 23)","title":"Server"},{"location":"SDK/#light-control","text":"By default, all the resources of the Light Control Object are enabled. But they can be disabled by using the following defines: IOWA_LIGHT_CONTROL_RSC_DIMMER_REMOVE : Disable the resource \"Dimmer\" (Id: 5851) IOWA_LIGHT_CONTROL_RSC_ON_TIME_REMOVE : Disable the resource \"On time\" (Id: 5852) IOWA_LIGHT_CONTROL_RSC_CUMULATIVE_ACTIVE_POWER_REMOVE : Disable the resource \"Cumulative active power\" (Id: 5805) IOWA_LIGHT_CONTROL_RSC_POWER_FACTOR_REMOVE : Disable the resource \"Power factor\" (Id: 5820) IOWA_LIGHT_CONTROL_RSC_COLOUR_REMOVE : Disable the resources \"Colour\" (Id: 5706) and \"Sensor Units\" (Id: 5701)","title":"Light Control"},{"location":"Security/","text":"Security \u00b6 To enable the Security, [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] must not be set to IOWA_SECURITY_LAYER_NONE . IOWA supports two security layers and add the ability to provide your security layer: mbed TLS: https://tls.mbed.org/ tinydtls: https://projects.eclipse.org/projects/iot.tinydtls Custom implementation Additionally, IOWA supports the following security mode with their possible cipher suites (by priority order): OSCORE: AES128-CCM8 and AES128-CBCSHA256, Pre-Shared Key: AES128-CCM8 and AES128-CBCSHA256, Raw Public Key: AES128-CCM8 and AES128-CBCSHA256, X.509 (Certificate): AES128-CCM8 and AES128-CBCSHA256. Security layers \u00b6 Warning: There is currently an incompatibility between tinydtls and mbed TLS. Thus A tinydtls client can not connect to mbed TLS server. The recommended security layer to use is mbed TLS. mbed TLS \u00b6 To use mbed TLS as the security layer, [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] can be set with the following defines: IOWA_SECURITY_LAYER_MBEDTLS_OSCORE_ONLY supports only OSCORE mode, IOWA_SECURITY_LAYER_MBEDTLS_PSK_ONLY supports Pre-Shared Key mode. Imply supporting OSCORE. IOWA_SECURITY_LAYER_MBEDTLS supports OSCORE, Pre-Shared Key and X.509 modes, These defines exist mainly for code size reduction if the application doesn't need to embed the whole mbed TLS stack. Note that mbed TLS does not support Raw Public Key security mode. tinydtls \u00b6 To use tinydtls as the security layer, [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] has to bet set to IOWA_SECURITY_LAYER_TINYDTLS . Note that tinydtls does not support X.509 security mode. Custom implementation \u00b6 To use your security implementation, [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] has to bet set to IOWA_SECURITY_LAYER_USER . Please refer to the [Providing your security implementation][Providing your security implementation] section for details. How to use the security in IOWA \u00b6 Find below two examples that could help to understand how to enable encrypted connection between a LwM2M Client and a LwM2M Server. Client side \u00b6 The following example shows how to use a certificate loaded from a file with the security layer mbed TLS. This is in complement of the Client sample using Pre-Shared Key. The structure to contain the certificates: typedef struct { iowa_certificate_data_t certData ; } application_data_t ; The main implementation: #include \"iowa_client.h\" #include <stdio.h> #include <stdlib.h> #define SERVER_URI \"coaps: //localhost:5684\" #define CERTIFICATES_FOLDER \"certs\" #define CA_CERTIFICATE_FILE \"server.crt\" #define CERTIFICATE_FILE \"client.crt\" #define CERTIFICATE_PRIVATE_KEY_FILE \"client.key\" size_t read_certificate_file ( char * certFolder , char * certFile , uint8_t ** bufferP ) { size_t fileLength ; char * certPath ; FILE * fileP ; fileLength = 0 ; certPath = malloc ( strlen ( certFolder ) + strlen ( certFile ) + 2 ); sprintf ( certPath , \"%s/%s\" , certFolder , certFile ); fileP = fopen ( certPath , \"rb\" ); if ( fileP == NULL ) { fprintf ( stderr , \"Error while opening the file: %s. \\r\\n \" , certPath ); goto function_exit ; } fseek ( fileP , 0 , SEEK_END ); fileLength = ftell ( fileP ); if ( fileLength == 0 ) { fprintf ( stderr , \"File length is 0. \\r\\n \" ); goto function_exit ; } fseek ( fileP , 0 , SEEK_SET ); * bufferP = iowa_system_malloc ( fileLength ); if ( * bufferP == NULL ) { fprintf ( stderr , \"Memory allocation error. \\r\\n \" ); goto function_exit ; } fread ( * bufferP , fileLength , 1 , fileP ); function_exit : if ( fileP != NULL ) { fclose ( fileP ); } iowa_system_free ( certPath ); return fileLength ; } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; application_data_t clientData ; /****************** * Initialization */ clientData . certData . caCertificateLength = read_certificate_file ( CERTIFICATES_FOLDER , CA_CERTIFICATE_FILE , & clientData . certData . caCertificate ); if ( clientData . certData . caCertificateLength == 0 ) { return -1 ; } clientData . certData . certificateLength = read_certificate_file ( CERTIFICATES_FOLDER , CERTIFICATE_FILE , & clientData . certData . certificate ); if ( clientData . certData . certificateLength == 0 ) { iowa_system_free ( clientData . certData . caCertificate ); return -1 ; } clientData . certData . certificatePrivateKeyLength = read_certificate_file ( CERTIFICATES_FOLDER , CERTIFICATE_PRIVATE_KEY_FILE , & clientData . certData . certificatePrivateKey ); if ( clientData . certData . certificatePrivateKeyLength == 0 ) { iowa_system_free ( clientData . certData . caCertificate ); iowa_system_free ( clientData . certData . certificate ); return -1 ; } // Initialize IOWA iowaH = iowa_init ( & clientData ); iowa_client_configure ( iowaH , \"IOWA_Client\" , NULL , NULL ); iowa_client_add_server ( iowaH , 1234 , SERVER_URI , 0 , 0 , IOWA_SEC_CERTIFICATE ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_server ( iowaH , 1234 ); iowa_close ( iowaH ); iowa_system_free ( clientData . certData . caCertificate ); iowa_system_free ( clientData . certData . certificate ); iowa_system_free ( clientData . certData . certificatePrivateKey ); return 0 ; } The Platform implementation: iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ) { application_data_t * clientDataP ; clientDataP = ( application_data_t * ) userDataP ; switch ( securityOp ) { case IOWA_SEC_READ : { switch ( securityDataP -> securityMode ) { case IOWA_SEC_CERTIFICATE : securityDataP -> securityMode = IOWA_SEC_CERTIFICATE ; // Copy the CA certificate securityDataP -> protocol . certData . caCertificate = clientDataP -> certData . caCertificate ; securityDataP -> protocol . certData . caCertificateLen = clientDataP -> certData . caCertificateLen ; // Copy the certificate securityDataP -> protocol . certData . certificate = clientDataP -> certData . certificate ; securityDataP -> protocol . certData . certificateLen = clientDataP -> certData . certificateLen ; // Copy the private key securityDataP -> protocol . certData . privateKey = clientDataP -> certData . privateKey ; securityDataP -> protocol . certData . privateKeyLen = clientDataP -> certData . privateKeyLen ; break ; default : break ; } break ; } default : break ; } return IOWA_COAP_NO_ERROR ; } Server side \u00b6 The following example shows how to use a certificate loaded from a file with the security layer mbed TLS. This is in complement of the Server sample using Pres-Shared Key. The example is nearly identical to the Client one, except that iowa_system_security_data reads only the Server certificate and do not verify Client certificates. The same structure and the same loading functions can be reused typedef struct { iowa_certificate_data_t certData ; } application_data_t ; The main implementation: #include \"iowa_server.h\" #include <stdio.h> #include <stdlib.h> #define CERTIFICATES_FOLDER \"certs\" #define CERTIFICATE_FILE \"server.crt\" #define CERTIFICATE_PRIVATE_KEY_FILE \"server.key\" size_t read_certificate_file ( char * certFolder , char * certFile , uint8_t ** bufferP ) { ... } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; application_data_t clientData ; /****************** * Initialization */ clientData . certData . certificateLength = read_certificate_file ( CERTIFICATES_FOLDER , CERTIFICATE_FILE , & clientData . certData . certificate ); if ( clientData . certData . certificateLength == 0 ) { iowa_system_free ( clientData . certData . caCertificate ); return -1 ; } clientData . certData . certificatePrivateKeyLength = read_certificate_file ( CERTIFICATES_FOLDER , CERTIFICATE_PRIVATE_KEY_FILE , & clientData . certData . certificatePrivateKey ); if ( clientData . certData . certificatePrivateKeyLength == 0 ) { iowa_system_free ( clientData . certData . caCertificate ); iowa_system_free ( clientData . certData . certificate ); return -1 ; } // Initialize IOWA iowaH = iowa_init ( & clientData ); iowa_server_configure ( iowaH , NULL , NULL , NULL ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_close ( iowaH ); iowa_system_free ( clientData . certData . certificate ); iowa_system_free ( clientData . certData . certificatePrivateKey ); return 0 ; } The Platform implementation: iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ) { application_data_t * clientDataP ; clientDataP = ( application_data_t * ) userDataP ; switch ( securityOp ) { case IOWA_SEC_READ : { switch ( securityDataP -> securityMode ) { case IOWA_SEC_CERTIFICATE : securityDataP -> securityMode = IOWA_SEC_CERTIFICATE ; // Copy the certificate securityDataP -> protocol . certData . certificate = clientDataP -> certData . certificate ; securityDataP -> protocol . certData . certificateLen = clientDataP -> certData . certificateLen ; // Copy the private key securityDataP -> protocol . certData . privateKey = clientDataP -> certData . privateKey ; securityDataP -> protocol . certData . privateKeyLen = clientDataP -> certData . privateKeyLen ; break ; default : break ; } break ; } default : break ; } return IOWA_COAP_NO_ERROR ; } Providing your security implementation \u00b6 You can replace the provided mbed TLS or tinydtls with your TLS/DTLS implementation. There are two ways to provide your security implementation: either you re-implement the whole Security component of IOWA as described in [IOWA Components][IOWA Components], or you can use the Security Implementation Abstraction described here. To do this, first [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] must be set to IOWA_SECURITY_LAYER_USER . Then you must implement the abstraction functions defined in the file include/iowa_security_user.h and documented below. Depending of your security implementation, you can set the two following defines in iowa_config.h to specify if the layer supports RPK and/or Certificate modes. By default, when IOWA_SECURITY_LAYER_USER is set, we considered that the two modes are not supported: #define IOWA_SECURITY_RAW_PUBLIC_KEY_SUPPORT #define IOWA_SECURITY_CERTIFICATE_SUPPORT An example of such implementation is provided in the sample user_security_client . Security Implementation Abstraction Functions \u00b6 iowa_user_security_create_client_session \u00b6 Prototype iowa_status_t iowa_user_security_create_client_session ( iowa_security_session_t securityS ); Description iowa_user_security_create_client_session() initializes implementation internals data of a new client-side security session. Arguments securityS : An iowa_security_session_t pointing to the security session to initialize. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage iowa_user_security_create_server_session \u00b6 Prototype iowa_status_t iowa_user_security_create_server_session ( iowa_security_session_t securityS ); Description iowa_user_security_create_server_session() initializes implementation internals data of a new server-side security session. Arguments securityS : An iowa_security_session_t pointing to the security session to initialize. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage iowa_user_security_delete_session \u00b6 Prototype void iowa_user_security_delete_session ( iowa_security_session_t securityS ); Description iowa_user_security_delete_session() deletes the implementation internals data of a security session. Arguments securityS : An iowa_security_session_t pointing to the security session to delete data from. Return Value None. \\clearpage iowa_user_security_handle_handshake_packet \u00b6 Prototype iowa_status_t iowa_user_security_handle_handshake_packet ( iowa_security_session_t securityS ); Description iowa_user_security_handle_handshake_packet() is called by IOWA when there is incoming data to read while the security session is in the SECURITY_STATE_HANDSHAKING state. Arguments securityS : An iowa_security_session_t pointing to the security session receiving data. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage iowa_user_security_step \u00b6 Prototype iowa_status_t iowa_user_security_step ( iowa_security_session_t securityS ); Description iowa_user_security_step() performs the required operations on the security session: updating state, handling timeouts, etc... Arguments securityS : An iowa_security_session_t pointing to the security session to update. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. Notes This function should update the IOWA context global timeout. See iowa_security_session_set_step_delay() . \\clearpage iowa_user_security_send \u00b6 Prototype int iowa_user_security_send ( iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description iowa_user_security_send() encrypts and sends data on a connected security session. Arguments securityS : An iowa_security_session_t pointing to the security session to send data on. buffer : The data to send. length : The length of the data in bytes. Return Value The number of bytes sent or a negative number in case of error. \\clearpage iowa_user_security_recv \u00b6 Prototype int iowa_user_security_recv ( iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description iowa_user_security_recv() reads and decrypts data received on a security session. Arguments securityS : An iowa_security_session_t pointing to the security session to receives data from. buffer : A buffer to store the decrypted data. length : The length of the buffer in bytes. Return Value The number of received bytes or a negative number in case of error. \\clearpage iowa_user_security_disconnect \u00b6 Prototype void iowa_user_security_disconnect ( iowa_security_session_t securityS ); Description iowa_user_security_disconnect() disconnects a security session. Arguments securityS : An iowa_security_session_t pointing to the security session to disconnect. Return Value None. \\clearpage iowa_user_security_HKDF \u00b6 Prototype iowa_status_t iowa_user_security_HKDF ( iowa_security_hash_t hash , uint8_t * IKM , size_t IKMLength , uint8_t * salt , size_t saltLength , uint8_t * info , size_t infoLength , uint8_t * OKM , size_t OKMLength ); Description iowa_user_security_HKDF() derives a new security key using HMAC-based Extract-and-Expand Key Derivation Function from RFC 5869 . Arguments hash : The hash algorithm to use. IKM : The input keying material. IKMLength : The length in bytes of IKM . salt : The salt value. This may be nil. saltLength : The length in bytes of salt . This may be 0. info : The context and application specific information. This may be nil. infoLength : The length in bytes of info . This may be 0. OKM : The buffer to store the compted output keying material. OKMLength : The length in bytes of OKM . Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage iowa_user_security_AEAD_encrypt \u00b6 Prototype iowa_status_t iowa_user_security_AEAD_encrypt ( iowa_security_aead_t aead , uint8_t * key , size_t keyLength , uint8_t * nonce , size_t nonceLength , uint8_t * aad , size_t aadLength , uint8_t * plainData , size_t plainDataLength , uint8_t * encryptedData , size_t * encryptedDataLengthP , uint8_t * tag , size_t tagLength ); Description iowa_user_security_AEAD_encrypt() encrypts data. Arguments aead : The AEAD algorithm to use. key : The key to use to encrypt. keyLength : The length in bytes of key . nonce : The nonce to use. This may be nil. nonceLength : The length in bytes of nonce . This may be 0. aad : The additional data to authenticate. This may be nil. aadLength : The length in bytes of aad . This may be 0. plainData : The data to encrypt. plainDataLength : The length in bytes of plainData . encryptedData : The buffer to store the encrypted data. encryptedDataLengthP : IN/OUT. The length in bytes of encryptedData . This may be modified by iowa_user_security_AEAD_encrypt() . tag : A buffer to store the authentication tag. This may be nil. tagLength : The length in bytes of tag . This may be 0. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage iowa_user_security_AEAD_decrypt \u00b6 Prototype iowa_status_t iowa_user_security_AEAD_decrypt ( iowa_security_aead_t aead , uint8_t * key , size_t keyLength , uint8_t * nonce , size_t nonceLength , uint8_t * aad , size_t aadLength , uint8_t * tag , size_t tagLength , uint8_t * encryptedData , size_t encryptedDataLength , uint8_t * plainData , size_t * plainDataLengthP ); Description iowa_user_security_AEAD_decrypt() decrypts data. Arguments aead : The AEAD algorithm to use. key : The key to use to encrypt. keyLength : The length in bytes of key . nonce : The nonce to use. This may be nil. nonceLength : The length in bytes of nonce . This may be 0. aad : The additional data to authenticate. This may be nil. aadLength : The length in bytes of aad . This may be 0. tag : The authentication tag. This may be nil. tagLength : The length in bytes of tag . This may be 0. encryptedData : The data to decrypt. encryptedDataLength : The length in bytes of encryptedData . plainData : The buffer to store the decrypted data. plainDataLengthP : IN/OUT. The length in bytes of plainData . This may be modified by iowa_user_security_AEAD_decrypt() . Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage Data types \u00b6 iowa_security_session_t \u00b6 This type is used to store the session of the IOWA security stack engine. Multiple sessions can exist at the same time. This can be treated as an opaque type and be used through the helper functions below. iowa_security_mode_t \u00b6 typedef uint8_t iowa_security_mode_t ; This contains the possible security mode for the Security layer. The following values are defined: IOWA_SEC_PRE_SHARED_KEY : Use the Pre-Shared Key mode of the security layer. IOWA_SEC_RAW_PUBLIC_KEY : Use the Private/Public Key mode of the security layer. IOWA_SEC_CERTIFICATE : Use the X.509 Certificate mode of the security layer. IOWA_SEC_NONE : The security layer is not involved in the communication with this peer. IOWA_SEC_CERTIFICATE_WITH_EST : Use the X.509 Certificate with EST mode of the security layer. IOWA_SEC_OSCORE : Use the OSCORE security of the CoAP layer. This value can be used as a flag to be combined with the other values, e.g. IOWA_SEC_PRE_SHARED_KEY | IOWA_SEC_OSCORE . iowa_cert_usage_mode_t \u00b6 typedef uint8_t iowa_cert_usage_mode_t ; This contains the possible semantic of the certificate or raw public key, which is used to match the certificate presented in the TLS/DTLS handshake. It is used by the Security layer when the security is IOWA_SEC_RAW_PUBLIC_KEY , IOWA_SEC_CERTIFICATE , or IOWA_SEC_CERTIFICATE_WITH_EST . The following values are defined: IOWA_CERTIFICATE_USAGE_CA_CONSTRAINT : CA constraint. IOWA_CERTIFICATE_USAGE_SERVICE_CERTIFICATE_CONSTRAINT : Service certificate constraint. IOWA_CERTIFICATE_USAGE_TRUST_ANCHOR_ASSERTION : Trust anchor assertion. IOWA_CERTIFICATE_USAGE_DOMAIN_ISSUED_CERTIFICATE : Domain-issued certificate. iowa_security_state_t \u00b6 typedef enum { SECURITY_STATE_DISCONNECTED = 0 , SECURITY_STATE_DISCONNECTING , SECURITY_STATE_INIT_HANDSHAKE , SECURITY_STATE_HANDSHAKING , SECURITY_STATE_HANDSHAKE_DONE , SECURITY_STATE_CONNECTED , SECURITY_STATE_CONNECTION_FAILING , SECURITY_STATE_CONNECTION_FAILED , } iowa_security_state_t ; This reflects the state of the security session. It is an enumeration of the following values: SECURITY_STATE_DISCONNECTED : The security session is disconnected. SECURITY_STATE_DISCONNECTING : The security session is currently disconnecting. SECURITY_STATE_INIT_HANDSHAKE : The security session is starting the handshake with the peer. SECURITY_STATE_HANDSHAKING : The security session is in the middle of the handshake with the peer. SECURITY_STATE_HANDSHAKE_DONE : The handshake with the peer is done. SECURITY_STATE_CONNECTED : The security session is connected to the peer. SECURITY_STATE_CONNECTION_FAILING : An error occurred during the security session connection to the peer. SECURITY_STATE_CONNECTION_FAILED : The security session failed to connect to the peer. iowa_security_event_t \u00b6 typedef enum { SECURITY_EVENT_UNDEFINED = 0 , SECURITY_EVENT_DISCONNECTED , SECURITY_EVENT_CONNECTED , SECURITY_EVENT_DATA_AVAILABLE , } iowa_security_event_t ; This contains the possible events to report to the upper layers. It is an enumeration of the following values: SECURITY_EVENT_UNDEFINED : No specific event. This should never be used and only serves as a non default event. SECURITY_EVENT_DISCONNECTED : The security session disconnected. SECURITY_EVENT_CONNECTED : The security session is now connected. SECURITY_EVENT_DATA_AVAILABLE : Decrypted data are available to read on the security session. iowa_security_hash_t \u00b6 typedef enum { SECURITY_HMAC_UNDEFINED = 0 , SECURITY_HMAC_SHA256_64 = 4 , SECURITY_HMAC_SHA256 = 5 , SECURITY_HMAC_SHA384 = 6 , SECURITY_HMAC_SHA512 = 7 } iowa_security_hash_t ; This contains the possible HMAC algorithms used by OSCORE. See table 7 of RFC 8152 . SECURITY_HMAC_UNDEFINED : No specific algorithm. This should never be used and only serves as a non default value. SECURITY_HMAC_SHA256_64 : HMAC with SHA-256 truncated to 64 bits. SECURITY_HMAC_SHA256 : HMAC with SHA-256. SECURITY_HMAC_SHA384 : HMAC with SHA-384. SECURITY_HMAC_SHA512 : HMAC with SHA-512. iowa_security_aead_t \u00b6 typedef enum { SECURITY_AEAD_UNDEFINED = 0 , SECURITY_AEAD_AES_CCM_16_64_128 = 10 , SECURITY_AEAD_AES_CCM_16_64_256 = 11 , SECURITY_AEAD_AES_CCM_64_64_128 = 12 , SECURITY_AEAD_AES_CCM_64_64_256 = 13 , SECURITY_AEAD_AES_CCM_16_128_128 = 30 , SECURITY_AEAD_AES_CCM_16_128_256 = 31 , SECURITY_AEAD_AES_CCM_64_128_128 = 32 , SECURITY_AEAD_AES_CCM_64_128_256 = 33 } iowa_security_aead_t ; This contains the possible AEAD algorithms used by OSCORE. See table 10 of RFC 8152 . SECURITY_AEAD_UNDEFINED : No specific algorithm. This should never be used and only serves as a non default value. SECURITY_AEAD_AES_CCM_16_64_128 : AES-CCM mode 128-bit key, 64-bit tag, 13-byte nonce. SECURITY_AEAD_AES_CCM_16_64_256 : AES-CCM mode 256-bit key, 64-bit tag, 13-byte nonce. SECURITY_AEAD_AES_CCM_64_64_128 : AES-CCM mode 128-bit key, 64-bit tag, 7-byte nonce. SECURITY_AEAD_AES_CCM_64_64_256 : AES-CCM mode 256-bit key, 64-bit tag, 7-byte nonce. SECURITY_AEAD_AES_CCM_16_128_128 : AES-CCM mode 128-bit key, 128-bit tag, 13-byte nonce. SECURITY_AEAD_AES_CCM_16_128_256 : AES-CCM mode 256-bit key, 128-bit tag, 13-byte nonce. SECURITY_AEAD_AES_CCM_64_128_128 : AES-CCM mode 128-bit key, 128-bit tag, 7-byte nonce. SECURITY_AEAD_AES_CCM_64_128_256 : AES-CCM mode 256-bit key, 128-bit tag, 7-byte nonce. \\clearpage Helper Functions \u00b6 iowa_security_session_set_user_internals \u00b6 Prototype void iowa_security_session_set_user_internals ( iowa_security_session_t securityS , void * internalsP ); Description iowa_security_session_set_user_internals() stores opaque data in a security session. Arguments securityS : An iowa_security_session_t pointing to the security session where to store the opaque data. internalsP : A pointer to the opaque data to store. Return Value None. \\clearpage iowa_security_session_get_user_internals \u00b6 Prototype void * iowa_security_session_get_user_internals ( iowa_security_session_t securityS ); Description iowa_security_session_get_user_internals() retrieves the opaque data stored in a security session with iowa_security_session_set_user_internals() . Arguments securityS : An iowa_security_session_t pointing to the security session where to store the opaque data. Return Value A pointer to the stored opaque data. \\clearpage iowa_security_session_get_state \u00b6 Prototype iowa_security_state_t iowa_security_session_get_state ( iowa_security_session_t securityS ); Description iowa_security_session_get_state() retrieves the state of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The state of the security session. \\clearpage iowa_security_session_set_state \u00b6 Prototype void iowa_security_session_set_state ( iowa_security_session_t securityS , iowa_security_state_t state ); Description iowa_security_session_set_state() sets the state of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. state : The new state of the security session. Return Value None. \\clearpage iowa_security_get_server_session \u00b6 Prototype iowa_security_session_t iowa_security_get_server_session ( iowa_context_t contextP , uint16_t shortServerId ); Description iowa_security_get_server_session() retrieves the security session associated to a Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortServerId : The Short ID assigned to the server. Return Value The security session if found, otherwise NULL. \\clearpage iowa_security_get_client_session \u00b6 Prototype iowa_security_session_t iowa_security_get_client_session ( iowa_context_t contextP , uint32_t clientId ); Description iowa_security_get_client_session() retrieves the security session associated to a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID assigned to the Client. Return Value The security session if found, otherwise NULL. \\clearpage iowa_security_session_generate_event \u00b6 Prototype void iowa_security_session_generate_event ( iowa_security_session_t securityS , iowa_security_event_t event ); Description iowa_security_session_generate_event() calls the event callback of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. event : The event to be passed as parameter to the event callback. Return Value None. \\clearpage iowa_security_session_get_connection_type \u00b6 Prototype iowa_connection_type_t iowa_security_session_get_connection_type ( iowa_security_session_t securityS ); Description iowa_security_session_get_connection_type() retrieves the type of the underlying connection of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The type of the underlying connection as an iowa_connection_type_t . \\clearpage iowa_security_session_get_security_mode \u00b6 Prototype iowa_security_mode_t iowa_security_session_get_security_mode ( iowa_security_session_t securityS ); Description iowa_security_session_get_security_mode() retrieves the security mode of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The security mode as an iowa_security_mode_t . \\clearpage iowa_security_session_get_uri \u00b6 Prototype const char * iowa_security_session_get_uri ( iowa_security_session_t securityS ); Description iowa_security_session_get_uri() retrieves the URI of the peer of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The URI of the peer. \\clearpage iowa_security_session_set_step_delay \u00b6 Prototype void iowa_security_session_set_step_delay ( iowa_security_session_t securityS , int32_t delay ); Description iowa_security_session_set_step_delay() sets the delay before the next scheduled operation on a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. securityS : the time in seconds before iowa_user_security_step() needs to be call again for this security session. Return Value None. Notes If delay is a negative number, it is ignored. As IOWA maintains only one global delay, iowa_user_security_step() may be called before the delay expires. The delay must be updated at each call. \\clearpage iowa_security_session_get_context \u00b6 Prototype iowa_context_t iowa_security_session_get_context ( iowa_security_session_t securityS ); Description iowa_security_session_get_context() retrieves the IOWA context in which a security session exists. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The IOWA context. \\clearpage iowa_security_session_get_context_user_data \u00b6 Prototype void * iowa_security_session_get_context_user_data ( iowa_security_session_t securityS ); Description iowa_security_session_get_context_user_data() retrieves the pointer to application-specific data of the IOWA context in which a security session exists. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The pointer to application-specific data as passed to iowa_init() . \\clearpage iowa_security_connection_send \u00b6 Prototype int iowa_security_connection_send ( iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description iowa_security_connection_send() sends data on the underlying connection of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. buffer : The data to send. length : The length of the data in bytes. Return Value The number of bytes sent or a negative number in case of error. \\clearpage iowa_security_connection_recv \u00b6 Prototype int iowa_security_connection_recv ( iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description iowa_security_connection_recv() reads data on the underlying connection of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. buffer : A buffer to store the received data. length : The number of bytes to read. Return Value The number of bytes read or a negative number in case of error.","title":"Security"},{"location":"Security/#security","text":"To enable the Security, [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] must not be set to IOWA_SECURITY_LAYER_NONE . IOWA supports two security layers and add the ability to provide your security layer: mbed TLS: https://tls.mbed.org/ tinydtls: https://projects.eclipse.org/projects/iot.tinydtls Custom implementation Additionally, IOWA supports the following security mode with their possible cipher suites (by priority order): OSCORE: AES128-CCM8 and AES128-CBCSHA256, Pre-Shared Key: AES128-CCM8 and AES128-CBCSHA256, Raw Public Key: AES128-CCM8 and AES128-CBCSHA256, X.509 (Certificate): AES128-CCM8 and AES128-CBCSHA256.","title":"Security"},{"location":"Security/#security-layers","text":"Warning: There is currently an incompatibility between tinydtls and mbed TLS. Thus A tinydtls client can not connect to mbed TLS server. The recommended security layer to use is mbed TLS.","title":"Security layers"},{"location":"Security/#mbed-tls","text":"To use mbed TLS as the security layer, [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] can be set with the following defines: IOWA_SECURITY_LAYER_MBEDTLS_OSCORE_ONLY supports only OSCORE mode, IOWA_SECURITY_LAYER_MBEDTLS_PSK_ONLY supports Pre-Shared Key mode. Imply supporting OSCORE. IOWA_SECURITY_LAYER_MBEDTLS supports OSCORE, Pre-Shared Key and X.509 modes, These defines exist mainly for code size reduction if the application doesn't need to embed the whole mbed TLS stack. Note that mbed TLS does not support Raw Public Key security mode.","title":"mbed TLS"},{"location":"Security/#tinydtls","text":"To use tinydtls as the security layer, [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] has to bet set to IOWA_SECURITY_LAYER_TINYDTLS . Note that tinydtls does not support X.509 security mode.","title":"tinydtls"},{"location":"Security/#custom-implementation","text":"To use your security implementation, [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] has to bet set to IOWA_SECURITY_LAYER_USER . Please refer to the [Providing your security implementation][Providing your security implementation] section for details.","title":"Custom implementation"},{"location":"Security/#how-to-use-the-security-in-iowa","text":"Find below two examples that could help to understand how to enable encrypted connection between a LwM2M Client and a LwM2M Server.","title":"How to use the security in IOWA"},{"location":"Security/#client-side","text":"The following example shows how to use a certificate loaded from a file with the security layer mbed TLS. This is in complement of the Client sample using Pre-Shared Key. The structure to contain the certificates: typedef struct { iowa_certificate_data_t certData ; } application_data_t ; The main implementation: #include \"iowa_client.h\" #include <stdio.h> #include <stdlib.h> #define SERVER_URI \"coaps: //localhost:5684\" #define CERTIFICATES_FOLDER \"certs\" #define CA_CERTIFICATE_FILE \"server.crt\" #define CERTIFICATE_FILE \"client.crt\" #define CERTIFICATE_PRIVATE_KEY_FILE \"client.key\" size_t read_certificate_file ( char * certFolder , char * certFile , uint8_t ** bufferP ) { size_t fileLength ; char * certPath ; FILE * fileP ; fileLength = 0 ; certPath = malloc ( strlen ( certFolder ) + strlen ( certFile ) + 2 ); sprintf ( certPath , \"%s/%s\" , certFolder , certFile ); fileP = fopen ( certPath , \"rb\" ); if ( fileP == NULL ) { fprintf ( stderr , \"Error while opening the file: %s. \\r\\n \" , certPath ); goto function_exit ; } fseek ( fileP , 0 , SEEK_END ); fileLength = ftell ( fileP ); if ( fileLength == 0 ) { fprintf ( stderr , \"File length is 0. \\r\\n \" ); goto function_exit ; } fseek ( fileP , 0 , SEEK_SET ); * bufferP = iowa_system_malloc ( fileLength ); if ( * bufferP == NULL ) { fprintf ( stderr , \"Memory allocation error. \\r\\n \" ); goto function_exit ; } fread ( * bufferP , fileLength , 1 , fileP ); function_exit : if ( fileP != NULL ) { fclose ( fileP ); } iowa_system_free ( certPath ); return fileLength ; } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; application_data_t clientData ; /****************** * Initialization */ clientData . certData . caCertificateLength = read_certificate_file ( CERTIFICATES_FOLDER , CA_CERTIFICATE_FILE , & clientData . certData . caCertificate ); if ( clientData . certData . caCertificateLength == 0 ) { return -1 ; } clientData . certData . certificateLength = read_certificate_file ( CERTIFICATES_FOLDER , CERTIFICATE_FILE , & clientData . certData . certificate ); if ( clientData . certData . certificateLength == 0 ) { iowa_system_free ( clientData . certData . caCertificate ); return -1 ; } clientData . certData . certificatePrivateKeyLength = read_certificate_file ( CERTIFICATES_FOLDER , CERTIFICATE_PRIVATE_KEY_FILE , & clientData . certData . certificatePrivateKey ); if ( clientData . certData . certificatePrivateKeyLength == 0 ) { iowa_system_free ( clientData . certData . caCertificate ); iowa_system_free ( clientData . certData . certificate ); return -1 ; } // Initialize IOWA iowaH = iowa_init ( & clientData ); iowa_client_configure ( iowaH , \"IOWA_Client\" , NULL , NULL ); iowa_client_add_server ( iowaH , 1234 , SERVER_URI , 0 , 0 , IOWA_SEC_CERTIFICATE ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_client_remove_server ( iowaH , 1234 ); iowa_close ( iowaH ); iowa_system_free ( clientData . certData . caCertificate ); iowa_system_free ( clientData . certData . certificate ); iowa_system_free ( clientData . certData . certificatePrivateKey ); return 0 ; } The Platform implementation: iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ) { application_data_t * clientDataP ; clientDataP = ( application_data_t * ) userDataP ; switch ( securityOp ) { case IOWA_SEC_READ : { switch ( securityDataP -> securityMode ) { case IOWA_SEC_CERTIFICATE : securityDataP -> securityMode = IOWA_SEC_CERTIFICATE ; // Copy the CA certificate securityDataP -> protocol . certData . caCertificate = clientDataP -> certData . caCertificate ; securityDataP -> protocol . certData . caCertificateLen = clientDataP -> certData . caCertificateLen ; // Copy the certificate securityDataP -> protocol . certData . certificate = clientDataP -> certData . certificate ; securityDataP -> protocol . certData . certificateLen = clientDataP -> certData . certificateLen ; // Copy the private key securityDataP -> protocol . certData . privateKey = clientDataP -> certData . privateKey ; securityDataP -> protocol . certData . privateKeyLen = clientDataP -> certData . privateKeyLen ; break ; default : break ; } break ; } default : break ; } return IOWA_COAP_NO_ERROR ; }","title":"Client side"},{"location":"Security/#server-side","text":"The following example shows how to use a certificate loaded from a file with the security layer mbed TLS. This is in complement of the Server sample using Pres-Shared Key. The example is nearly identical to the Client one, except that iowa_system_security_data reads only the Server certificate and do not verify Client certificates. The same structure and the same loading functions can be reused typedef struct { iowa_certificate_data_t certData ; } application_data_t ; The main implementation: #include \"iowa_server.h\" #include <stdio.h> #include <stdlib.h> #define CERTIFICATES_FOLDER \"certs\" #define CERTIFICATE_FILE \"server.crt\" #define CERTIFICATE_PRIVATE_KEY_FILE \"server.key\" size_t read_certificate_file ( char * certFolder , char * certFile , uint8_t ** bufferP ) { ... } int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; application_data_t clientData ; /****************** * Initialization */ clientData . certData . certificateLength = read_certificate_file ( CERTIFICATES_FOLDER , CERTIFICATE_FILE , & clientData . certData . certificate ); if ( clientData . certData . certificateLength == 0 ) { iowa_system_free ( clientData . certData . caCertificate ); return -1 ; } clientData . certData . certificatePrivateKeyLength = read_certificate_file ( CERTIFICATES_FOLDER , CERTIFICATE_PRIVATE_KEY_FILE , & clientData . certData . certificatePrivateKey ); if ( clientData . certData . certificatePrivateKeyLength == 0 ) { iowa_system_free ( clientData . certData . caCertificate ); iowa_system_free ( clientData . certData . certificate ); return -1 ; } // Initialize IOWA iowaH = iowa_init ( & clientData ); iowa_server_configure ( iowaH , NULL , NULL , NULL ); /****************** * \"Main loop\" */ do { // Run for 4 seconds result = iowa_step ( iowaH , 4 ); } while ( result == IOWA_COAP_NO_ERROR ) iowa_close ( iowaH ); iowa_system_free ( clientData . certData . certificate ); iowa_system_free ( clientData . certData . certificatePrivateKey ); return 0 ; } The Platform implementation: iowa_status_t iowa_system_security_data ( const uint8_t * peerIdentity , size_t peerIdentityLen , iowa_security_operation_t securityOp , iowa_security_data_t * securityDataP , void * userDataP ) { application_data_t * clientDataP ; clientDataP = ( application_data_t * ) userDataP ; switch ( securityOp ) { case IOWA_SEC_READ : { switch ( securityDataP -> securityMode ) { case IOWA_SEC_CERTIFICATE : securityDataP -> securityMode = IOWA_SEC_CERTIFICATE ; // Copy the certificate securityDataP -> protocol . certData . certificate = clientDataP -> certData . certificate ; securityDataP -> protocol . certData . certificateLen = clientDataP -> certData . certificateLen ; // Copy the private key securityDataP -> protocol . certData . privateKey = clientDataP -> certData . privateKey ; securityDataP -> protocol . certData . privateKeyLen = clientDataP -> certData . privateKeyLen ; break ; default : break ; } break ; } default : break ; } return IOWA_COAP_NO_ERROR ; }","title":"Server side"},{"location":"Security/#providing-your-security-implementation","text":"You can replace the provided mbed TLS or tinydtls with your TLS/DTLS implementation. There are two ways to provide your security implementation: either you re-implement the whole Security component of IOWA as described in [IOWA Components][IOWA Components], or you can use the Security Implementation Abstraction described here. To do this, first [ IOWA_SECURITY_LAYER ][IOWA_SECURITY_LAYER] must be set to IOWA_SECURITY_LAYER_USER . Then you must implement the abstraction functions defined in the file include/iowa_security_user.h and documented below. Depending of your security implementation, you can set the two following defines in iowa_config.h to specify if the layer supports RPK and/or Certificate modes. By default, when IOWA_SECURITY_LAYER_USER is set, we considered that the two modes are not supported: #define IOWA_SECURITY_RAW_PUBLIC_KEY_SUPPORT #define IOWA_SECURITY_CERTIFICATE_SUPPORT An example of such implementation is provided in the sample user_security_client .","title":"Providing your security implementation"},{"location":"Security/#security-implementation-abstraction-functions","text":"","title":"Security Implementation Abstraction Functions"},{"location":"Security/#iowa_user_security_create_client_session","text":"Prototype iowa_status_t iowa_user_security_create_client_session ( iowa_security_session_t securityS ); Description iowa_user_security_create_client_session() initializes implementation internals data of a new client-side security session. Arguments securityS : An iowa_security_session_t pointing to the security session to initialize. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"iowa_user_security_create_client_session"},{"location":"Security/#iowa_user_security_create_server_session","text":"Prototype iowa_status_t iowa_user_security_create_server_session ( iowa_security_session_t securityS ); Description iowa_user_security_create_server_session() initializes implementation internals data of a new server-side security session. Arguments securityS : An iowa_security_session_t pointing to the security session to initialize. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"iowa_user_security_create_server_session"},{"location":"Security/#iowa_user_security_delete_session","text":"Prototype void iowa_user_security_delete_session ( iowa_security_session_t securityS ); Description iowa_user_security_delete_session() deletes the implementation internals data of a security session. Arguments securityS : An iowa_security_session_t pointing to the security session to delete data from. Return Value None. \\clearpage","title":"iowa_user_security_delete_session"},{"location":"Security/#iowa_user_security_handle_handshake_packet","text":"Prototype iowa_status_t iowa_user_security_handle_handshake_packet ( iowa_security_session_t securityS ); Description iowa_user_security_handle_handshake_packet() is called by IOWA when there is incoming data to read while the security session is in the SECURITY_STATE_HANDSHAKING state. Arguments securityS : An iowa_security_session_t pointing to the security session receiving data. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"iowa_user_security_handle_handshake_packet"},{"location":"Security/#iowa_user_security_step","text":"Prototype iowa_status_t iowa_user_security_step ( iowa_security_session_t securityS ); Description iowa_user_security_step() performs the required operations on the security session: updating state, handling timeouts, etc... Arguments securityS : An iowa_security_session_t pointing to the security session to update. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. Notes This function should update the IOWA context global timeout. See iowa_security_session_set_step_delay() . \\clearpage","title":"iowa_user_security_step"},{"location":"Security/#iowa_user_security_send","text":"Prototype int iowa_user_security_send ( iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description iowa_user_security_send() encrypts and sends data on a connected security session. Arguments securityS : An iowa_security_session_t pointing to the security session to send data on. buffer : The data to send. length : The length of the data in bytes. Return Value The number of bytes sent or a negative number in case of error. \\clearpage","title":"iowa_user_security_send"},{"location":"Security/#iowa_user_security_recv","text":"Prototype int iowa_user_security_recv ( iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description iowa_user_security_recv() reads and decrypts data received on a security session. Arguments securityS : An iowa_security_session_t pointing to the security session to receives data from. buffer : A buffer to store the decrypted data. length : The length of the buffer in bytes. Return Value The number of received bytes or a negative number in case of error. \\clearpage","title":"iowa_user_security_recv"},{"location":"Security/#iowa_user_security_disconnect","text":"Prototype void iowa_user_security_disconnect ( iowa_security_session_t securityS ); Description iowa_user_security_disconnect() disconnects a security session. Arguments securityS : An iowa_security_session_t pointing to the security session to disconnect. Return Value None. \\clearpage","title":"iowa_user_security_disconnect"},{"location":"Security/#iowa_user_security_hkdf","text":"Prototype iowa_status_t iowa_user_security_HKDF ( iowa_security_hash_t hash , uint8_t * IKM , size_t IKMLength , uint8_t * salt , size_t saltLength , uint8_t * info , size_t infoLength , uint8_t * OKM , size_t OKMLength ); Description iowa_user_security_HKDF() derives a new security key using HMAC-based Extract-and-Expand Key Derivation Function from RFC 5869 . Arguments hash : The hash algorithm to use. IKM : The input keying material. IKMLength : The length in bytes of IKM . salt : The salt value. This may be nil. saltLength : The length in bytes of salt . This may be 0. info : The context and application specific information. This may be nil. infoLength : The length in bytes of info . This may be 0. OKM : The buffer to store the compted output keying material. OKMLength : The length in bytes of OKM . Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"iowa_user_security_HKDF"},{"location":"Security/#iowa_user_security_aead_encrypt","text":"Prototype iowa_status_t iowa_user_security_AEAD_encrypt ( iowa_security_aead_t aead , uint8_t * key , size_t keyLength , uint8_t * nonce , size_t nonceLength , uint8_t * aad , size_t aadLength , uint8_t * plainData , size_t plainDataLength , uint8_t * encryptedData , size_t * encryptedDataLengthP , uint8_t * tag , size_t tagLength ); Description iowa_user_security_AEAD_encrypt() encrypts data. Arguments aead : The AEAD algorithm to use. key : The key to use to encrypt. keyLength : The length in bytes of key . nonce : The nonce to use. This may be nil. nonceLength : The length in bytes of nonce . This may be 0. aad : The additional data to authenticate. This may be nil. aadLength : The length in bytes of aad . This may be 0. plainData : The data to encrypt. plainDataLength : The length in bytes of plainData . encryptedData : The buffer to store the encrypted data. encryptedDataLengthP : IN/OUT. The length in bytes of encryptedData . This may be modified by iowa_user_security_AEAD_encrypt() . tag : A buffer to store the authentication tag. This may be nil. tagLength : The length in bytes of tag . This may be 0. Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"iowa_user_security_AEAD_encrypt"},{"location":"Security/#iowa_user_security_aead_decrypt","text":"Prototype iowa_status_t iowa_user_security_AEAD_decrypt ( iowa_security_aead_t aead , uint8_t * key , size_t keyLength , uint8_t * nonce , size_t nonceLength , uint8_t * aad , size_t aadLength , uint8_t * tag , size_t tagLength , uint8_t * encryptedData , size_t encryptedDataLength , uint8_t * plainData , size_t * plainDataLengthP ); Description iowa_user_security_AEAD_decrypt() decrypts data. Arguments aead : The AEAD algorithm to use. key : The key to use to encrypt. keyLength : The length in bytes of key . nonce : The nonce to use. This may be nil. nonceLength : The length in bytes of nonce . This may be 0. aad : The additional data to authenticate. This may be nil. aadLength : The length in bytes of aad . This may be 0. tag : The authentication tag. This may be nil. tagLength : The length in bytes of tag . This may be 0. encryptedData : The data to decrypt. encryptedDataLength : The length in bytes of encryptedData . plainData : The buffer to store the decrypted data. plainDataLengthP : IN/OUT. The length in bytes of plainData . This may be modified by iowa_user_security_AEAD_decrypt() . Return Value IOWA_COAP_NO_ERROR in case of success or an error status. \\clearpage","title":"iowa_user_security_AEAD_decrypt"},{"location":"Security/#data-types","text":"","title":"Data types"},{"location":"Security/#iowa_security_session_t","text":"This type is used to store the session of the IOWA security stack engine. Multiple sessions can exist at the same time. This can be treated as an opaque type and be used through the helper functions below.","title":"iowa_security_session_t"},{"location":"Security/#iowa_security_mode_t","text":"typedef uint8_t iowa_security_mode_t ; This contains the possible security mode for the Security layer. The following values are defined: IOWA_SEC_PRE_SHARED_KEY : Use the Pre-Shared Key mode of the security layer. IOWA_SEC_RAW_PUBLIC_KEY : Use the Private/Public Key mode of the security layer. IOWA_SEC_CERTIFICATE : Use the X.509 Certificate mode of the security layer. IOWA_SEC_NONE : The security layer is not involved in the communication with this peer. IOWA_SEC_CERTIFICATE_WITH_EST : Use the X.509 Certificate with EST mode of the security layer. IOWA_SEC_OSCORE : Use the OSCORE security of the CoAP layer. This value can be used as a flag to be combined with the other values, e.g. IOWA_SEC_PRE_SHARED_KEY | IOWA_SEC_OSCORE .","title":"iowa_security_mode_t"},{"location":"Security/#iowa_cert_usage_mode_t","text":"typedef uint8_t iowa_cert_usage_mode_t ; This contains the possible semantic of the certificate or raw public key, which is used to match the certificate presented in the TLS/DTLS handshake. It is used by the Security layer when the security is IOWA_SEC_RAW_PUBLIC_KEY , IOWA_SEC_CERTIFICATE , or IOWA_SEC_CERTIFICATE_WITH_EST . The following values are defined: IOWA_CERTIFICATE_USAGE_CA_CONSTRAINT : CA constraint. IOWA_CERTIFICATE_USAGE_SERVICE_CERTIFICATE_CONSTRAINT : Service certificate constraint. IOWA_CERTIFICATE_USAGE_TRUST_ANCHOR_ASSERTION : Trust anchor assertion. IOWA_CERTIFICATE_USAGE_DOMAIN_ISSUED_CERTIFICATE : Domain-issued certificate.","title":"iowa_cert_usage_mode_t"},{"location":"Security/#iowa_security_state_t","text":"typedef enum { SECURITY_STATE_DISCONNECTED = 0 , SECURITY_STATE_DISCONNECTING , SECURITY_STATE_INIT_HANDSHAKE , SECURITY_STATE_HANDSHAKING , SECURITY_STATE_HANDSHAKE_DONE , SECURITY_STATE_CONNECTED , SECURITY_STATE_CONNECTION_FAILING , SECURITY_STATE_CONNECTION_FAILED , } iowa_security_state_t ; This reflects the state of the security session. It is an enumeration of the following values: SECURITY_STATE_DISCONNECTED : The security session is disconnected. SECURITY_STATE_DISCONNECTING : The security session is currently disconnecting. SECURITY_STATE_INIT_HANDSHAKE : The security session is starting the handshake with the peer. SECURITY_STATE_HANDSHAKING : The security session is in the middle of the handshake with the peer. SECURITY_STATE_HANDSHAKE_DONE : The handshake with the peer is done. SECURITY_STATE_CONNECTED : The security session is connected to the peer. SECURITY_STATE_CONNECTION_FAILING : An error occurred during the security session connection to the peer. SECURITY_STATE_CONNECTION_FAILED : The security session failed to connect to the peer.","title":"iowa_security_state_t"},{"location":"Security/#iowa_security_event_t","text":"typedef enum { SECURITY_EVENT_UNDEFINED = 0 , SECURITY_EVENT_DISCONNECTED , SECURITY_EVENT_CONNECTED , SECURITY_EVENT_DATA_AVAILABLE , } iowa_security_event_t ; This contains the possible events to report to the upper layers. It is an enumeration of the following values: SECURITY_EVENT_UNDEFINED : No specific event. This should never be used and only serves as a non default event. SECURITY_EVENT_DISCONNECTED : The security session disconnected. SECURITY_EVENT_CONNECTED : The security session is now connected. SECURITY_EVENT_DATA_AVAILABLE : Decrypted data are available to read on the security session.","title":"iowa_security_event_t"},{"location":"Security/#iowa_security_hash_t","text":"typedef enum { SECURITY_HMAC_UNDEFINED = 0 , SECURITY_HMAC_SHA256_64 = 4 , SECURITY_HMAC_SHA256 = 5 , SECURITY_HMAC_SHA384 = 6 , SECURITY_HMAC_SHA512 = 7 } iowa_security_hash_t ; This contains the possible HMAC algorithms used by OSCORE. See table 7 of RFC 8152 . SECURITY_HMAC_UNDEFINED : No specific algorithm. This should never be used and only serves as a non default value. SECURITY_HMAC_SHA256_64 : HMAC with SHA-256 truncated to 64 bits. SECURITY_HMAC_SHA256 : HMAC with SHA-256. SECURITY_HMAC_SHA384 : HMAC with SHA-384. SECURITY_HMAC_SHA512 : HMAC with SHA-512.","title":"iowa_security_hash_t"},{"location":"Security/#iowa_security_aead_t","text":"typedef enum { SECURITY_AEAD_UNDEFINED = 0 , SECURITY_AEAD_AES_CCM_16_64_128 = 10 , SECURITY_AEAD_AES_CCM_16_64_256 = 11 , SECURITY_AEAD_AES_CCM_64_64_128 = 12 , SECURITY_AEAD_AES_CCM_64_64_256 = 13 , SECURITY_AEAD_AES_CCM_16_128_128 = 30 , SECURITY_AEAD_AES_CCM_16_128_256 = 31 , SECURITY_AEAD_AES_CCM_64_128_128 = 32 , SECURITY_AEAD_AES_CCM_64_128_256 = 33 } iowa_security_aead_t ; This contains the possible AEAD algorithms used by OSCORE. See table 10 of RFC 8152 . SECURITY_AEAD_UNDEFINED : No specific algorithm. This should never be used and only serves as a non default value. SECURITY_AEAD_AES_CCM_16_64_128 : AES-CCM mode 128-bit key, 64-bit tag, 13-byte nonce. SECURITY_AEAD_AES_CCM_16_64_256 : AES-CCM mode 256-bit key, 64-bit tag, 13-byte nonce. SECURITY_AEAD_AES_CCM_64_64_128 : AES-CCM mode 128-bit key, 64-bit tag, 7-byte nonce. SECURITY_AEAD_AES_CCM_64_64_256 : AES-CCM mode 256-bit key, 64-bit tag, 7-byte nonce. SECURITY_AEAD_AES_CCM_16_128_128 : AES-CCM mode 128-bit key, 128-bit tag, 13-byte nonce. SECURITY_AEAD_AES_CCM_16_128_256 : AES-CCM mode 256-bit key, 128-bit tag, 13-byte nonce. SECURITY_AEAD_AES_CCM_64_128_128 : AES-CCM mode 128-bit key, 128-bit tag, 7-byte nonce. SECURITY_AEAD_AES_CCM_64_128_256 : AES-CCM mode 256-bit key, 128-bit tag, 7-byte nonce. \\clearpage","title":"iowa_security_aead_t"},{"location":"Security/#helper-functions","text":"","title":"Helper Functions"},{"location":"Security/#iowa_security_session_set_user_internals","text":"Prototype void iowa_security_session_set_user_internals ( iowa_security_session_t securityS , void * internalsP ); Description iowa_security_session_set_user_internals() stores opaque data in a security session. Arguments securityS : An iowa_security_session_t pointing to the security session where to store the opaque data. internalsP : A pointer to the opaque data to store. Return Value None. \\clearpage","title":"iowa_security_session_set_user_internals"},{"location":"Security/#iowa_security_session_get_user_internals","text":"Prototype void * iowa_security_session_get_user_internals ( iowa_security_session_t securityS ); Description iowa_security_session_get_user_internals() retrieves the opaque data stored in a security session with iowa_security_session_set_user_internals() . Arguments securityS : An iowa_security_session_t pointing to the security session where to store the opaque data. Return Value A pointer to the stored opaque data. \\clearpage","title":"iowa_security_session_get_user_internals"},{"location":"Security/#iowa_security_session_get_state","text":"Prototype iowa_security_state_t iowa_security_session_get_state ( iowa_security_session_t securityS ); Description iowa_security_session_get_state() retrieves the state of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The state of the security session. \\clearpage","title":"iowa_security_session_get_state"},{"location":"Security/#iowa_security_session_set_state","text":"Prototype void iowa_security_session_set_state ( iowa_security_session_t securityS , iowa_security_state_t state ); Description iowa_security_session_set_state() sets the state of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. state : The new state of the security session. Return Value None. \\clearpage","title":"iowa_security_session_set_state"},{"location":"Security/#iowa_security_get_server_session","text":"Prototype iowa_security_session_t iowa_security_get_server_session ( iowa_context_t contextP , uint16_t shortServerId ); Description iowa_security_get_server_session() retrieves the security session associated to a Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. shortServerId : The Short ID assigned to the server. Return Value The security session if found, otherwise NULL. \\clearpage","title":"iowa_security_get_server_session"},{"location":"Security/#iowa_security_get_client_session","text":"Prototype iowa_security_session_t iowa_security_get_client_session ( iowa_context_t contextP , uint32_t clientId ); Description iowa_security_get_client_session() retrieves the security session associated to a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID assigned to the Client. Return Value The security session if found, otherwise NULL. \\clearpage","title":"iowa_security_get_client_session"},{"location":"Security/#iowa_security_session_generate_event","text":"Prototype void iowa_security_session_generate_event ( iowa_security_session_t securityS , iowa_security_event_t event ); Description iowa_security_session_generate_event() calls the event callback of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. event : The event to be passed as parameter to the event callback. Return Value None. \\clearpage","title":"iowa_security_session_generate_event"},{"location":"Security/#iowa_security_session_get_connection_type","text":"Prototype iowa_connection_type_t iowa_security_session_get_connection_type ( iowa_security_session_t securityS ); Description iowa_security_session_get_connection_type() retrieves the type of the underlying connection of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The type of the underlying connection as an iowa_connection_type_t . \\clearpage","title":"iowa_security_session_get_connection_type"},{"location":"Security/#iowa_security_session_get_security_mode","text":"Prototype iowa_security_mode_t iowa_security_session_get_security_mode ( iowa_security_session_t securityS ); Description iowa_security_session_get_security_mode() retrieves the security mode of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The security mode as an iowa_security_mode_t . \\clearpage","title":"iowa_security_session_get_security_mode"},{"location":"Security/#iowa_security_session_get_uri","text":"Prototype const char * iowa_security_session_get_uri ( iowa_security_session_t securityS ); Description iowa_security_session_get_uri() retrieves the URI of the peer of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The URI of the peer. \\clearpage","title":"iowa_security_session_get_uri"},{"location":"Security/#iowa_security_session_set_step_delay","text":"Prototype void iowa_security_session_set_step_delay ( iowa_security_session_t securityS , int32_t delay ); Description iowa_security_session_set_step_delay() sets the delay before the next scheduled operation on a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. securityS : the time in seconds before iowa_user_security_step() needs to be call again for this security session. Return Value None. Notes If delay is a negative number, it is ignored. As IOWA maintains only one global delay, iowa_user_security_step() may be called before the delay expires. The delay must be updated at each call. \\clearpage","title":"iowa_security_session_set_step_delay"},{"location":"Security/#iowa_security_session_get_context","text":"Prototype iowa_context_t iowa_security_session_get_context ( iowa_security_session_t securityS ); Description iowa_security_session_get_context() retrieves the IOWA context in which a security session exists. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The IOWA context. \\clearpage","title":"iowa_security_session_get_context"},{"location":"Security/#iowa_security_session_get_context_user_data","text":"Prototype void * iowa_security_session_get_context_user_data ( iowa_security_session_t securityS ); Description iowa_security_session_get_context_user_data() retrieves the pointer to application-specific data of the IOWA context in which a security session exists. Arguments securityS : An iowa_security_session_t pointing to a security session. Return Value The pointer to application-specific data as passed to iowa_init() . \\clearpage","title":"iowa_security_session_get_context_user_data"},{"location":"Security/#iowa_security_connection_send","text":"Prototype int iowa_security_connection_send ( iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description iowa_security_connection_send() sends data on the underlying connection of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. buffer : The data to send. length : The length of the data in bytes. Return Value The number of bytes sent or a negative number in case of error. \\clearpage","title":"iowa_security_connection_send"},{"location":"Security/#iowa_security_connection_recv","text":"Prototype int iowa_security_connection_recv ( iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description iowa_security_connection_recv() reads data on the underlying connection of a security session. Arguments securityS : An iowa_security_session_t pointing to a security session. buffer : A buffer to store the received data. length : The number of bytes to read. Return Value The number of bytes read or a negative number in case of error.","title":"iowa_security_connection_recv"},{"location":"SecurityComponent/","text":"Security Component \u00b6 The functions explained below are defined inside the file src/security/iowa_prv_security.h . iowa_status_t securityInit ( iowa_context_t contextP ); void securityClose ( iowa_context_t contextP ); iowa_status_t securityStep ( iowa_context_t contextP ); iowa_security_session_t securityClientNewSession ( iowa_context_t contextP , const char * uri , iowa_security_mode_t securityMode ); iowa_security_session_t securityServerNewSession ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); void securityDeleteSession ( iowa_context_t contextP , iowa_security_session_t securityS ); void securitySetEventCallback ( iowa_context_t contextP , iowa_security_session_t securityS , security_event_callback_t eventCb , void * userDataCb ); iowa_status_t securityConnect ( iowa_context_t contextP , iowa_security_session_t securityS ); void securityDisconnect ( iowa_context_t contextP , iowa_security_session_t securityS ); int securitySend ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); int securityRecv ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); bool securityGetIsSecure ( iowa_context_t contextP , iowa_security_session_t securityS ); size_t securityGetIdentity ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); iowa_status_t securityAddKey ( iowa_context_t contextP , const char * uri , iowa_security_data_t * securityDataP ); iowa_status_t securityRemoveKey ( iowa_context_t contextP , const char * uri ); \\clearpage Data types \u00b6 iowa_security_context_t \u00b6 This type is used to store the context of the IOWA security stack engine. It is created by calling [ securityInit() ][securityInit] and destroyed by calling [ securityClose() ][securityClose]. iowa_security_session_t \u00b6 This type is used to store the session of the IOWA security stack engine. Multiple sessions can exist at the same time. It is created by calling [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession] and destroyed by calling [ securityDeleteSession() ][securityDeleteSession]. \\clearpage Functions \u00b6 securityInit \u00b6 Prototype \u00b6 iowa_status_t securityInit ( iowa_context_t contextP ); Description \u00b6 securityInit() initializes a security context. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 iowa_prv_security.h \\clearpage securityClose \u00b6 Prototype \u00b6 void securityClose ( iowa_context_t contextP ); Description \u00b6 securityClose() closes a security context. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 None. Header File \u00b6 iowa_prv_security.h \\clearpage securityStep \u00b6 Prototype \u00b6 iowa_status_t securityStep ( iowa_context_t contextP ); Description \u00b6 securityStep() does a security step to handle the handshaking, the timeout, ... for all the security sessions. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_INTERNAL_SERVER_ERROR : attempt to do handshake on a security session which doesn't need it. IOWA_COAP_500_INTERNAL_SERVER_ERROR : error during the handshake of a security session. Header File \u00b6 iowa_prv_security.h \\clearpage securityClientNewSession \u00b6 Prototype \u00b6 iowa_security_session_t securityClientNewSession ( iowa_context_t contextP , const char * uri , iowa_security_mode_t securityMode ); Description \u00b6 securityClientNewSession() initializes a security session for a client. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. uri : URI of the server, used as identity. securityMode : The security mode to use when connecting to this LwM2M Server. Return Value \u00b6 An iowa_security_session_t in case of success or NULL in case of error. Header File \u00b6 iowa_prv_security.h \\clearpage securityServerNewSession \u00b6 Prototype \u00b6 iowa_security_session_t securityServerNewSession ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); Description \u00b6 securityServerNewSession() initializes a security session for a server. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The connection type of the incoming connection. connP : The connection as returned by iowa_system_connection_open() . isSecure : Inform if the incoming connection is secure. Return Value An iowa_security_session_t in case of success or NULL in case of error. Header File iowa_prv_security.h \\clearpage securityDeleteSession \u00b6 Prototype \u00b6 void securityDeleteSession ( iowa_context_t contextP , iowa_security_session_t securityS ); Description \u00b6 securityDeleteSession() closes a security session. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. Return Value \u00b6 None. Header File \u00b6 iowa_prv_security.h \\clearpage securitySetEventCallback \u00b6 Prototype \u00b6 void securitySetEventCallback ( iowa_context_t contextP , iowa_security_session_t securityS , security_event_callback_t eventCb , void * userDataCb ); Description \u00b6 securitySetEventCallback() sets the event callback for a security session. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. eventCb : The event callback called when a new event occurs. userDataCb : The user data pass to the event callback when called. Return Value \u00b6 None. Header File \u00b6 iowa_prv_security.h \\clearpage securityConnect \u00b6 Prototype \u00b6 iowa_status_t securityConnect ( iowa_context_t contextP , iowa_security_session_t securityS ); Description \u00b6 securityConnect() connects to a new connection. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. Header File \u00b6 iowa_prv_security.h \\clearpage securityDisconnect \u00b6 Prototype \u00b6 void securityDisconnect ( iowa_context_t contextP , iowa_security_session_t securityS ); Description \u00b6 securityDisconnect() disconnects from a connection. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. Return Value \u00b6 None. Header File \u00b6 iowa_prv_security.h \\clearpage securitySend \u00b6 Prototype \u00b6 int securitySend ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description \u00b6 securitySend() sends a buffer on a connection. Must call the platform function iowa_system_connection_send . Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. buffer : The data to send. length : The length of the data in bytes. Return Value \u00b6 The number of bytes sent or a negative number in case of error. Header File \u00b6 iowa_prv_security.h \\clearpage securityRecv \u00b6 Prototype \u00b6 int securityRecv ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description \u00b6 securityRecv() reads data from a connection. Must call the platform function iowa_system_connection_recv . Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. buffer : A buffer to store the received data. length : The length of the buffer in bytes. Return Value \u00b6 The number of received bytes or a negative number in case of error. Header File \u00b6 iowa_prv_security.h \\clearpage securityGetIsSecure \u00b6 Prototype \u00b6 bool securityGetIsSecure ( iowa_context_t contextP , iowa_security_session_t securityS ); Description \u00b6 securityGetIsSecure() returns if a security session is encrypted. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. Return Value \u00b6 'true' if encrypted, 'false' otherwise. Header File \u00b6 iowa_prv_security.h \\clearpage securityGetIdentity \u00b6 Prototype \u00b6 size_t securityGetIdentity ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); Description \u00b6 securityGetIdentity() retrieves the identity of a secured peer. Must call the platform function iowa_system_connection_get_peer_identifier . Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. buffer : A buffer to store the identity. length : The length of the buffer in bytes. Return Value \u00b6 The length in bytes of the identity. Header File \u00b6 iowa_prv_security.h \\clearpage securityAddKey \u00b6 Prototype \u00b6 iowa_status_t securityAddKey ( iowa_context_t contextP , const char * uri , iowa_security_data_t * securityDataP ); Description \u00b6 securityAddKey() stores a key. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. uri : The URI of the peer the key is associated to. securityDataP : Data containing the key. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. Header File \u00b6 iowa_prv_security.h Notes \u00b6 If IOWA is built with IOWA_SECURITY_LAYER different from IOWA_SECURITY_LAYER_NONE , [ securityAddKey ][securityAddKey] will call the platform function iowa_system_security_data . But there is no prerequisite to call this platform function if IOWA is built with IOWA_SECURITY_LAYER equals to IOWA_SECURITY_LAYER_USER . If iowa_system_security_data has to be called, the argument securityOp must be set to IOWA_SEC_CREATE. \\clearpage securityRemoveKey \u00b6 Prototype \u00b6 iowa_status_t securityRemoveKey ( iowa_context_t contextP , const char * uri ); Description \u00b6 securityRemoveKey() removes the keys. Arguments \u00b6 contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. uri : The URI of the peer the keys are associated to. Return Value \u00b6 IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : the associated keys have not been found. Header File \u00b6 iowa_prv_security.h Notes \u00b6 If IOWA is built with IOWA_SECURITY_LAYER different from IOWA_SECURITY_LAYER_NONE , [ securityRemoveKey ][securityRemoveKey] will call the platform function iowa_system_security_data . But there is no prerequisite to call this platform function if IOWA is built with IOWA_SECURITY_LAYER equals to IOWA_SECURITY_LAYER_USER . If iowa_system_security_data has to be called, the argument securityOp must be set to IOWA_SEC_DELETE.","title":"SecurityComponent"},{"location":"SecurityComponent/#security-component","text":"The functions explained below are defined inside the file src/security/iowa_prv_security.h . iowa_status_t securityInit ( iowa_context_t contextP ); void securityClose ( iowa_context_t contextP ); iowa_status_t securityStep ( iowa_context_t contextP ); iowa_security_session_t securityClientNewSession ( iowa_context_t contextP , const char * uri , iowa_security_mode_t securityMode ); iowa_security_session_t securityServerNewSession ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); void securityDeleteSession ( iowa_context_t contextP , iowa_security_session_t securityS ); void securitySetEventCallback ( iowa_context_t contextP , iowa_security_session_t securityS , security_event_callback_t eventCb , void * userDataCb ); iowa_status_t securityConnect ( iowa_context_t contextP , iowa_security_session_t securityS ); void securityDisconnect ( iowa_context_t contextP , iowa_security_session_t securityS ); int securitySend ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); int securityRecv ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); bool securityGetIsSecure ( iowa_context_t contextP , iowa_security_session_t securityS ); size_t securityGetIdentity ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length ); iowa_status_t securityAddKey ( iowa_context_t contextP , const char * uri , iowa_security_data_t * securityDataP ); iowa_status_t securityRemoveKey ( iowa_context_t contextP , const char * uri ); \\clearpage","title":"Security Component"},{"location":"SecurityComponent/#data-types","text":"","title":"Data types"},{"location":"SecurityComponent/#iowa_security_context_t","text":"This type is used to store the context of the IOWA security stack engine. It is created by calling [ securityInit() ][securityInit] and destroyed by calling [ securityClose() ][securityClose].","title":"iowa_security_context_t"},{"location":"SecurityComponent/#iowa_security_session_t","text":"This type is used to store the session of the IOWA security stack engine. Multiple sessions can exist at the same time. It is created by calling [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession] and destroyed by calling [ securityDeleteSession() ][securityDeleteSession]. \\clearpage","title":"iowa_security_session_t"},{"location":"SecurityComponent/#functions","text":"","title":"Functions"},{"location":"SecurityComponent/#securityinit","text":"","title":"securityInit"},{"location":"SecurityComponent/#prototype","text":"iowa_status_t securityInit ( iowa_context_t contextP );","title":"Prototype"},{"location":"SecurityComponent/#description","text":"securityInit() initializes a security context.","title":"Description"},{"location":"SecurityComponent/#arguments","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"Arguments"},{"location":"SecurityComponent/#return-value","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"SecurityComponent/#header-file","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securityclose","text":"","title":"securityClose"},{"location":"SecurityComponent/#prototype_1","text":"void securityClose ( iowa_context_t contextP );","title":"Prototype"},{"location":"SecurityComponent/#description_1","text":"securityClose() closes a security context.","title":"Description"},{"location":"SecurityComponent/#arguments_1","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"Arguments"},{"location":"SecurityComponent/#return-value_1","text":"None.","title":"Return Value"},{"location":"SecurityComponent/#header-file_1","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securitystep","text":"","title":"securityStep"},{"location":"SecurityComponent/#prototype_2","text":"iowa_status_t securityStep ( iowa_context_t contextP );","title":"Prototype"},{"location":"SecurityComponent/#description_2","text":"securityStep() does a security step to handle the handshaking, the timeout, ... for all the security sessions.","title":"Description"},{"location":"SecurityComponent/#arguments_2","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime.","title":"Arguments"},{"location":"SecurityComponent/#return-value_2","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_412_INTERNAL_SERVER_ERROR : attempt to do handshake on a security session which doesn't need it. IOWA_COAP_500_INTERNAL_SERVER_ERROR : error during the handshake of a security session.","title":"Return Value"},{"location":"SecurityComponent/#header-file_2","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securityclientnewsession","text":"","title":"securityClientNewSession"},{"location":"SecurityComponent/#prototype_3","text":"iowa_security_session_t securityClientNewSession ( iowa_context_t contextP , const char * uri , iowa_security_mode_t securityMode );","title":"Prototype"},{"location":"SecurityComponent/#description_3","text":"securityClientNewSession() initializes a security session for a client.","title":"Description"},{"location":"SecurityComponent/#arguments_3","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. uri : URI of the server, used as identity. securityMode : The security mode to use when connecting to this LwM2M Server.","title":"Arguments"},{"location":"SecurityComponent/#return-value_3","text":"An iowa_security_session_t in case of success or NULL in case of error.","title":"Return Value"},{"location":"SecurityComponent/#header-file_3","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securityservernewsession","text":"","title":"securityServerNewSession"},{"location":"SecurityComponent/#prototype_4","text":"iowa_security_session_t securityServerNewSession ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure );","title":"Prototype"},{"location":"SecurityComponent/#description_4","text":"securityServerNewSession() initializes a security session for a server.","title":"Description"},{"location":"SecurityComponent/#arguments_4","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The connection type of the incoming connection. connP : The connection as returned by iowa_system_connection_open() . isSecure : Inform if the incoming connection is secure. Return Value An iowa_security_session_t in case of success or NULL in case of error. Header File iowa_prv_security.h \\clearpage","title":"Arguments"},{"location":"SecurityComponent/#securitydeletesession","text":"","title":"securityDeleteSession"},{"location":"SecurityComponent/#prototype_5","text":"void securityDeleteSession ( iowa_context_t contextP , iowa_security_session_t securityS );","title":"Prototype"},{"location":"SecurityComponent/#description_5","text":"securityDeleteSession() closes a security session.","title":"Description"},{"location":"SecurityComponent/#arguments_5","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime.","title":"Arguments"},{"location":"SecurityComponent/#return-value_4","text":"None.","title":"Return Value"},{"location":"SecurityComponent/#header-file_4","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securityseteventcallback","text":"","title":"securitySetEventCallback"},{"location":"SecurityComponent/#prototype_6","text":"void securitySetEventCallback ( iowa_context_t contextP , iowa_security_session_t securityS , security_event_callback_t eventCb , void * userDataCb );","title":"Prototype"},{"location":"SecurityComponent/#description_6","text":"securitySetEventCallback() sets the event callback for a security session.","title":"Description"},{"location":"SecurityComponent/#arguments_6","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. eventCb : The event callback called when a new event occurs. userDataCb : The user data pass to the event callback when called.","title":"Arguments"},{"location":"SecurityComponent/#return-value_5","text":"None.","title":"Return Value"},{"location":"SecurityComponent/#header-file_5","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securityconnect","text":"","title":"securityConnect"},{"location":"SecurityComponent/#prototype_7","text":"iowa_status_t securityConnect ( iowa_context_t contextP , iowa_security_session_t securityS );","title":"Prototype"},{"location":"SecurityComponent/#description_7","text":"securityConnect() connects to a new connection.","title":"Description"},{"location":"SecurityComponent/#arguments_7","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime.","title":"Arguments"},{"location":"SecurityComponent/#return-value_6","text":"IOWA_COAP_NO_ERROR : success.","title":"Return Value"},{"location":"SecurityComponent/#header-file_6","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securitydisconnect","text":"","title":"securityDisconnect"},{"location":"SecurityComponent/#prototype_8","text":"void securityDisconnect ( iowa_context_t contextP , iowa_security_session_t securityS );","title":"Prototype"},{"location":"SecurityComponent/#description_8","text":"securityDisconnect() disconnects from a connection.","title":"Description"},{"location":"SecurityComponent/#arguments_8","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime.","title":"Arguments"},{"location":"SecurityComponent/#return-value_7","text":"None.","title":"Return Value"},{"location":"SecurityComponent/#header-file_7","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securitysend","text":"","title":"securitySend"},{"location":"SecurityComponent/#prototype_9","text":"int securitySend ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length );","title":"Prototype"},{"location":"SecurityComponent/#description_9","text":"securitySend() sends a buffer on a connection. Must call the platform function iowa_system_connection_send .","title":"Description"},{"location":"SecurityComponent/#arguments_9","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. buffer : The data to send. length : The length of the data in bytes.","title":"Arguments"},{"location":"SecurityComponent/#return-value_8","text":"The number of bytes sent or a negative number in case of error.","title":"Return Value"},{"location":"SecurityComponent/#header-file_8","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securityrecv","text":"","title":"securityRecv"},{"location":"SecurityComponent/#prototype_10","text":"int securityRecv ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length );","title":"Prototype"},{"location":"SecurityComponent/#description_10","text":"securityRecv() reads data from a connection. Must call the platform function iowa_system_connection_recv .","title":"Description"},{"location":"SecurityComponent/#arguments_10","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. buffer : A buffer to store the received data. length : The length of the buffer in bytes.","title":"Arguments"},{"location":"SecurityComponent/#return-value_9","text":"The number of received bytes or a negative number in case of error.","title":"Return Value"},{"location":"SecurityComponent/#header-file_9","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securitygetissecure","text":"","title":"securityGetIsSecure"},{"location":"SecurityComponent/#prototype_11","text":"bool securityGetIsSecure ( iowa_context_t contextP , iowa_security_session_t securityS );","title":"Prototype"},{"location":"SecurityComponent/#description_11","text":"securityGetIsSecure() returns if a security session is encrypted.","title":"Description"},{"location":"SecurityComponent/#arguments_11","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime.","title":"Arguments"},{"location":"SecurityComponent/#return-value_10","text":"'true' if encrypted, 'false' otherwise.","title":"Return Value"},{"location":"SecurityComponent/#header-file_10","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securitygetidentity","text":"","title":"securityGetIdentity"},{"location":"SecurityComponent/#prototype_12","text":"size_t securityGetIdentity ( iowa_context_t contextP , iowa_security_session_t securityS , uint8_t * buffer , size_t length );","title":"Prototype"},{"location":"SecurityComponent/#description_12","text":"securityGetIdentity() retrieves the identity of a secured peer. Must call the platform function iowa_system_connection_get_peer_identifier .","title":"Description"},{"location":"SecurityComponent/#arguments_12","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. securityS : An iowa_security_session_t as returned by [ securityClientNewSession() ][securityClientNewSession] or [ securityServerNewSession() ][securityServerNewSession]. Should not be checked at runtime. buffer : A buffer to store the identity. length : The length of the buffer in bytes.","title":"Arguments"},{"location":"SecurityComponent/#return-value_11","text":"The length in bytes of the identity.","title":"Return Value"},{"location":"SecurityComponent/#header-file_11","text":"iowa_prv_security.h \\clearpage","title":"Header File"},{"location":"SecurityComponent/#securityaddkey","text":"","title":"securityAddKey"},{"location":"SecurityComponent/#prototype_13","text":"iowa_status_t securityAddKey ( iowa_context_t contextP , const char * uri , iowa_security_data_t * securityDataP );","title":"Prototype"},{"location":"SecurityComponent/#description_13","text":"securityAddKey() stores a key.","title":"Description"},{"location":"SecurityComponent/#arguments_13","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. uri : The URI of the peer the key is associated to. securityDataP : Data containing the key.","title":"Arguments"},{"location":"SecurityComponent/#return-value_12","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed.","title":"Return Value"},{"location":"SecurityComponent/#header-file_12","text":"iowa_prv_security.h","title":"Header File"},{"location":"SecurityComponent/#notes","text":"If IOWA is built with IOWA_SECURITY_LAYER different from IOWA_SECURITY_LAYER_NONE , [ securityAddKey ][securityAddKey] will call the platform function iowa_system_security_data . But there is no prerequisite to call this platform function if IOWA is built with IOWA_SECURITY_LAYER equals to IOWA_SECURITY_LAYER_USER . If iowa_system_security_data has to be called, the argument securityOp must be set to IOWA_SEC_CREATE. \\clearpage","title":"Notes"},{"location":"SecurityComponent/#securityremovekey","text":"","title":"securityRemoveKey"},{"location":"SecurityComponent/#prototype_14","text":"iowa_status_t securityRemoveKey ( iowa_context_t contextP , const char * uri );","title":"Prototype"},{"location":"SecurityComponent/#description_14","text":"securityRemoveKey() removes the keys.","title":"Description"},{"location":"SecurityComponent/#arguments_14","text":"contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. uri : The URI of the peer the keys are associated to.","title":"Arguments"},{"location":"SecurityComponent/#return-value_13","text":"IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : the associated keys have not been found.","title":"Return Value"},{"location":"SecurityComponent/#header-file_13","text":"iowa_prv_security.h","title":"Header File"},{"location":"SecurityComponent/#notes_1","text":"If IOWA is built with IOWA_SECURITY_LAYER different from IOWA_SECURITY_LAYER_NONE , [ securityRemoveKey ][securityRemoveKey] will call the platform function iowa_system_security_data . But there is no prerequisite to call this platform function if IOWA is built with IOWA_SECURITY_LAYER equals to IOWA_SECURITY_LAYER_USER . If iowa_system_security_data has to be called, the argument securityOp must be set to IOWA_SEC_DELETE.","title":"Notes"},{"location":"ServerAPI/","text":"Server Mode API Reference \u00b6 The functions explained below are defined inside the file include/iowa_server.h . Server pseudo code \u00b6 #include \"iowa_server.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; int serverSocket ; /****************** * Initialization */ serverSocket = open_udp_socket (); iowaH = iowa_init ( NULL ); result = iowa_server_configure ( iowaH , client_monitor , NULL , NULL ); /****************** * \"Main loop\" */ while ( result == IOWA_COAP_NO_ERROR ) { result = iowa_step ( iowaH , 10 ); if ( isDataAvailable ( serverSocket )) { void * newConnection ; newConnection = create_new_connection (); result = iowa_server_new_incoming_connection ( iowaH , IOWA_CONN_DATAGRAM , newConnection , true ); } } iowa_close ( iowaH ); close ( serverSocket ); return 0 ; } Data types \u00b6 iowa_supported_format_t \u00b6 typedef uint8_t iowa_supported_format_t ; #define IOWA_SUPPORTED_FORMAT_UNKNOWN 0x00 #define IOWA_SUPPORTED_FORMAT_TLV 0x01 #define IOWA_SUPPORTED_FORMAT_JSON 0x02 #define IOWA_SUPPORTED_FORMAT_OLD_TLV 0x04 #define IOWA_SUPPORTED_FORMAT_OLD_JSON 0x08 #define IOWA_SUPPORTED_FORMAT_CBOR 0x10 #define IOWA_SUPPORTED_FORMAT_SENML_JSON 0x20 #define IOWA_SUPPORTED_FORMAT_SENML_CBOR 0x40 This contains the possible supported content format. It is an enumeration of the following values: IOWA_SUPPORTED_FORMAT_UNKNOWN : Unknown supported format. IOWA_SUPPORTED_FORMAT_TLV : TLV supported format. IOWA_SUPPORTED_FORMAT_JSON : JSON supported format. IOWA_SUPPORTED_FORMAT_OLD_TLV : Old TLV supported format. IOWA_SUPPORTED_FORMAT_OLD_JSON : Old JSON supported format. IOWA_SUPPORTED_FORMAT_CBOR : CBOR format. IOWA_SUPPORTED_FORMAT_SENML_JSON : SenML JSON supported format. IOWA_SUPPORTED_FORMAT_SENML_CBOR : SenML CBOR supported format. iowa_lwm2m_protocol_version_t \u00b6 typedef enum { IOWA_LWM2M_VERSION_UNDEFINED = 0 , IOWA_LWM2M_VERSION_1_0 , IOWA_LWM2M_VERSION_1_1 } iowa_lwm2m_protocol_version_t ; This contains the possible LwM2M Enabler version. It is an enumeration of the following values: IOWA_LWM2M_VERSION_UNDEFINED : Unknown LwM2M enabler version. IOWA_LWM2M_VERSION_1_0 : LwM2M Enabler version 1.0. IOWA_LWM2M_VERSION_1_1 : LwM2M Enabler version 1.1. iowa_client_t \u00b6 This structure describes a LwM2M Client known to the LwM2M Server. typedef struct { const char * name ; uint16_t id ; bool queueMode ; iowa_supported_format_t supportedFormats ; const char * msisdn ; size_t objectLinkCount ; iowa_lwm2m_object_link_t * objectLinkArray ; uint32_t lifetime ; iowa_connection_type_t connectionType ; bool secureConnection ; iowa_lwm2m_protocol_version_t lwm2mVersion ; } iowa_client_t ; name : The unique name of the Client. id : The internal ID of the Client. To be used with iowa_server_dm_...() APIs. queueMode : Set to true if the LwM2M Client supports the Queue Mode. supportedFormats : The content formats supported by the Client. msisdn : The MSISDN to which the LwM2M Client is reachable for SMS trigger. objectLinkCount : The number of elements in the objectLinkArray . objectLinkArray : An array containing the Objects and Object Instances registered by the Client. : If an Object has no Instances, iowa_lwm2m_object_link_t::instanceID is set to IOWA_LWM2M_ID_ALL . lifetime : The lifetime of the Client. connectionType : The type of the connection on which the Client reach the Server. secureConnection : Set to true if the connection is encrypted. lwm2mVersion : The LwM2M Enabler version used by the Client. \\clearpage Callbacks \u00b6 iowa_result_callback_t \u00b6 The device management APIs ( iowa_server_write() , iowa_server_dm_exec() , iowa_server_dm_create() , iowa_server_dm_delete() , iowa_server_dm_discover() and iowa_server_observe() ) are using an iowa_result_callback_t to asynchronously return the result of the operation. typedef void ( * iowa_result_callback_t ) ( iowa_dm_operation_t operation , uint16_t clientId , uint16_t objectId , uint16_t instanceId , uint16_t resourceId , iowa_status_t status , size_t dataCount , iowa_lwm2m_data_t * dataArray , void * resultUserData , iowa_context_t contextP ); operation : The type of command matching this result. clientId : The ID of the client targeted by the command. objectId : The ID of the Object targeted by the command. instanceId : The ID of the Instance targeted by the command. This may be IOWA_LWM2M_ID_ALL . resourceId : The ID of the Resource targeted by the command. This may be IOWA_LWM2M_ID_ALL . status : The status of the command or the notification counter if operation is IOWA_DM_NOTIFY . dataCount : The number of elements in the dataArray . This may be 0. dataArray : An array containing the Resource values returned by the Client. This may be nil. resultUserData : A pointer to application specific data. This is a parameter of the matching iowa_server_dm_...() API. contextP : The IOWA context on which the device management API ( iowa_server_dm_exec() ) was called. iowa_monitor_callback_t \u00b6 This is the client state monitoring callback, called when a LwM2M Client changes its registration to the Server or when a LwM2M Client connects to the Bootstrap Server. typedef void ( * iowa_monitor_callback_t )( const iowa_client_t * clientP , iowa_state_t state , void * callbackUserData , iowa_context_t contextP ); clientP : The information of the Client. state : The new state of the Client among: : - IOWA_STATE_REGISTERED : when a new or returning client registers. : - IOWA_STATE_UPDATING : when a client updates its registration. : - IOWA_STATE_UNREGISTERED : when a client ends its registration or when the registration expires. : - IOWA_STATE_BOOTSTRAP_REQUIRED : when a new or returning client connects to the bootstrap server. : - IOWA_STATE_BOOTSTRAPPING : when a client is in bootstrapping state. : - IOWA_STATE_BOOTSTRAP_FAILED : when the bootstrapping procedure of a client failed. : - IOWA_STATE_BOOTSTRAP_FINISHED : when the bootstrapping procedure of a client succeeded. callbackUserData : A pointer to application specific data. This is a parameter of `iowa_server_configure() . contextP : The IOWA context on which iowa_server_configure() was called. When state is set to IOWA_STATE_UNREGISTERED , clientP contains only the ID of the former Client. When state is set to IOWA_STATE_BOOTSTRAP_REQUIRED , IOWA_STATE_BOOTSTRAPPING , IOWA_STATE_BOOTSTRAP_FAILED , or IOWA_STATE_BOOTSTRAP_FINISHED , clientP contains only the ID, the name of the Client and the connection type information. iowa_resource_type_callback_t \u00b6 This is the callback called to retrieve the data type of resources of non standard LwM2M Objects. typedef iowa_lwm2m_data_type_t ( * iowa_resource_type_callback_t ) ( uint16_t objectID , uint16_t resourceID , void * callbackUserData ); Arguments objectID : The ID of the non standard LwM2M Objects. resourceID : The ID of the resource inside the non standard LwM2M Objects. callbackUserData : A pointer to application specific data. This is a parameter of `iowa_server_configure() . Return Value The data type of the resource or IOWA_LWM2M_TYPE_UNDEFINED . iowa_verify_client_callback_t \u00b6 This is the callback called when LwM2M Clients register to the Server. If the callback returns IOWA_COAP_NO_ERROR , the Client is accepted by the Server. Otherwise, to reject a Client the callback has to return ONLY the following values: IOWA_COAP_400_BAD_REQUEST if the Client is unknown or something does not match. IOWA_COAP_409_CONFLICT if on LoRaWAN transport, the Client didn't provide its objects list and this list is not present on Server side. typedef iowa_status_t ( * iowa_verify_client_callback_t ) ( const iowa_client_t * clientP , iowa_state_t state , void * callbackUserData , iowa_context_t contextP ); clientP : The information of the Client. state : The new state of the Client among: : - IOWA_STATE_REGISTERING : when a new or returning client registers. : - IOWA_STATE_UPDATING : when a client updates its registration. : - IOWA_STATE_BOOTSTRAP_REQUIRED : when a new or returning client connects to the bootstrap server. callbackUserData : A pointer to application specific data. This is a parameter of `iowa_server_set_verify_client_callback() . contextP : The IOWA context on which iowa_server_configure() was called. When state is set to IOWA_STATE_BOOTSTRAP_REQUIRED , clientP contains only the ID, the name of the Client and the connection type information. \\clearpage API \u00b6 iowa_server_configure \u00b6 Prototype iowa_status_t iowa_server_configure ( iowa_context_t contextP , iowa_monitor_callback_t monitorCb , iowa_resource_type_callback_t resTypeCb , void * callbackUserData ); Description iowa_server_configure() sets the monitoring callback called when LwM2M Clients register to the Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. monitorCb : The callback called when Clients update their status. This can be nil. resTypeCb : The callback called when parsing received data of non standard LwM2M Objects. This can be nil. callbackUserData : A pointer to application specific data. This is passed as argument to monitorCb and resTypeCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. Header File iowa_server.h \\clearpage iowa_server_set_verify_client_callback \u00b6 Prototype void iowa_server_set_verify_client_callback ( iowa_context_t contextP , iowa_verify_client_callback_t verifyClientCb , void * callbackUserData ); Description iowa_server_set_verify_client_callback() sets the verify client callback called when LwM2M Clients register to the Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. verifyClientCb : The callback called when Clients register. This can be nil. callbackUserData : A pointer to application specific data. This is passed as argument to verifyClientCb . This can be nil. Return Value None. Header File iowa_server.h Notes If the verify client callback is not set, Clients will always be accepted. \\clearpage iowa_server_new_incoming_connection \u00b6 Prototype iowa_status_t iowa_server_new_incoming_connection ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); Description iowa_server_new_incoming_connection() informs the stack of a new incoming connection. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The type of the new connection. See iowa_connection_type_t . connP : The new connection of the same user-defined type as the one returned by iowa_system_connection_open() . isSecure : Set to true if the security must be enabled on this connection. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_503_SERVICE_UNAVAILABLE : either: : - a memory allocation failed. : - type is unsupported. Header File iowa_server.h \\clearpage iowa_server_configure_data_push \u00b6 Prototype void iowa_server_configure_data_push ( iowa_context_t contextP , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_server_configure_data_push() enables/disables the Data push operation for all clients. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. responseCb : The callback called when a client pushes data. If this callback is nil, data push possibility is disabled. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value None. Header File iowa_server.h Notes The responseCb will be called with the operation set to IOWA_DM_DATA_PUSH and the status code set to IOWA_COAP_205_CONTENT . To be able to use this function, [ LWM2M_DATA_PUSH_SUPPORT ][LWM2M_DATA_PUSH_SUPPORT] must be defined. \\clearpage iowa_server_read \u00b6 Prototype iowa_status_t iowa_server_read ( iowa_context_t contextP , uint32_t clientId , size_t uriCount , iowa_lwm2m_uri_t * uriP , iowa_response_callback_t responseCb , void * userDataP ) Description iowa_server_read() performs a Read operation on Client\u2019s URIs. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uriCount, uriP : An array of the URIs to read. responseCb : The callback called when the reply to this operation is known. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : Either: : - responseCb is nil. : - uriCount is zero or uriP is nil. : - uriP targets Object ID IOWA_LWM2M_ID_ALL and [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] is not defined. : - uriP targets Object ID IOWA_LWM2M_ID_ALL , [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] is defined, but uriCount is not equal to 1. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : A memory allocation failed. IOWA_COAP_501_NOT_IMPLEMENTED : uriCount is superior to 1 with [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] not defined. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Read was successful, the Client will return a IOWA_COAP_205_CONTENT status code. The ability to read several URIs at once is only present in LwM2M version 1.1 or later, this means that to use it LWM2M_VERSION_1_1_SUPPORT must be defined. This feature is only operational on SenML JSON and SenML CBOR data encoding, so LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR must be defined. Some LwM2M Clients may not be able to read on several URIs in a single operation. In this case the resultCb will be called with an error status, typically IOWA_COAP_405_METHOD_NOT_ALLOWED . Per LwM2M specification, when handling a read on several URIs in a single operation, the LwM2M Client treats the request as non-atomic and handles it as best effort. Hence the reply may not contain the values of all the requested URIs. The responseCb will be called with the operation set to IOWA_DM_READ . \\clearpage iowa_server_observe \u00b6 Prototype iowa_status_t iowa_server_observe ( iowa_context_t contextP , uint32_t clientId , size_t uriCount , iowa_lwm2m_uri_t * uriP , iowa_response_callback_t responseCb , void * userDataP , uint16_t * observeIdP ); Description iowa_server_observe() begins an observation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uriCount, uriP : An array of the URIs to observe. responseCb : The callback called when the reply to this operation is known. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. observeIdP : Used to store the ID of the observation. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : Either: : - responseCb is nil. : - observeIdP is nil. : - uriCount is zero or uriP is nil. : - uriP targets Object ID IOWA_LWM2M_ID_ALL and [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] is not defined. : - uriP targets Object ID IOWA_LWM2M_ID_ALL , [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] is defined, but uriCount is not equal to 1. : - At least one uriP is invalid: instanceId is equal to IOWA_LWM2M_ID_ALL but resourceId is not equal to IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_412_PRECONDITION_FAILED : Observe was already launched. observeIdP is set to the value of the previous observation. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : A memory allocation failed. IOWA_COAP_501_NOT_IMPLEMENTED : uriCount is superior to 1 with [ LWM2M_OBSERVE_COMPOSITE_SUPPORT ][LWM2M_OBSERVE_COMPOSITE_SUPPORT] not defined. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Observe was successful, the Client will return a IOWA_COAP_205_CONTENT status code with the first notification. The responseCb will be called with the operation set to IOWA_DM_NOTIFY : When the observation is internally deleted, responseCb will be called with status to IOWA_COAP_202_DELETED . When the client deregisters or when the connection with the client is lost, responseCb will be called with status to IOWA_COAP_503_SERVICE_UNAVAILABLE . Some LwM2M Clients may not be able to observe on several URIs in a single operation. In this case the responseCb will be called with an error status, typically IOWA_COAP_405_METHOD_NOT_ALLOWED . When using an unreliable communication layer, notifications may be lost or arrive out of order. \\clearpage iowa_server_observe_cancel \u00b6 Prototype iowa_status_t iowa_server_observe_cancel ( iowa_context_t contextP , uint32_t clientId , uint16_t observeId ); Description iowa_server_observe_cancel() cancels an observation on a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . observeId : The ID of the observation as returned by iowa_server_observe . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - observeId does not match a known observation. IOWA_COAP_500_INTERNAL_SERVER_ERROR : A memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes When using an unreliable communication layer, the cancellation request from the LwM2M Server to the LwM2M Client may be lost. However the observation is always cancelled. \\clearpage iowa_server_write \u00b6 Prototype iowa_status_t iowa_server_write ( iowa_context_t contextP , uint32_t clientId , size_t dataCount , iowa_lwm2m_data_t * dataArrayP , iowa_response_callback_t responseCb , void * userDataP ) Description iowa_server_write() performs a Write operation on a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . dataCount, dataArrayP : The data to write. responseCb : The callback called when the reply to this operation is known. This can be nil. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : Either: : - dataCount is zero or dataArrayP is nil. : - dataArrayP[x].objectID or dataArrayP[x].instanceID or dataArrayP[x].resourceID is IOWA_LWM2M_ID_ALL . : - dataArrayP contains several data with incorrect type. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - dataArrayP contains several data with different objectID or instanceID but LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR are not defined. : - dataArrayP contains several data with defined timestamp. : - dataArrayP contains several data of unsigned integer type which are negative. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_501_NOT_IMPLEMENTED : dataArrayP has different objectID or instanceID with [ LWM2M_WRITE_COMPOSITE_SUPPORT ][LWM2M_WRITE_COMPOSITE_SUPPORT] not defined. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Write was successful, the Client will return a IOWA_COAP_204_CHANGED status code. To be able to write on different dataArrayP[x].objectID or dataArrayP[x].instanceID at once, LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR must be defined. Some LwM2M Clients may not be able to write on different dataArrayP[x].objectID or dataArrayP[x].instanceID in a single operation. In this case the responseCb will be called with an error status, typically IOWA_COAP_405_METHOD_NOT_ALLOWED . The responseCb will be called with the operation set to IOWA_DM_WRITE . \\clearpage iowa_server_write_attributes_string \u00b6 Prototype iowa_status_t iowa_server_write_attributes_string ( iowa_context_t contextP , uint32_t clientId , iowa_lwm2m_uri_t * uriP , const char * attributesStr , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_server_write_attributes_string() performs a Write-Attributes operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uriP : The URI targeted by the operation. attributesStr : The attributes to write as a query string. responseCb : The callback called when the reply to this operation is known. This can be nil. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either : uriP is nil. : uriP->objectId is IOWA_LWM2M_ID_ALL . : uriP->resInstanceId is not IOWA_LWM2M_ID_ALL and LWM2M_VERSION_1_1_SUPPORT is not set. : attributesStr is nil or an empty string. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Write-Attributes was successful, the Client will return a IOWA_COAP_204_CHANGED status code. The responseCb will be called with the operation set to IOWA_DM_WRITE_ATTRIBUTES . LwM2M defines the following attributes: Name Level Description pmin Object, Object Instance, Resource The minimum period in seconds to wait between notifications. pmax Object, Object Instance, Resource The maximum period in seconds to wait between notifications. gt Numerical Resource An upper threshold. A notification is sent when the resource value crosses this threshold. lt Numerical Resource An lower threshold. A notification is sent when the resource value crosses this threshold. st Numerical Resource A difference minimum in a resource value for a notification to be sent. epmin Object, Object Instance, Resource The minimum sample time in seconds for the observed sensor in LwM2M 1.1 or later. epmax Object, Object Instance, Resource The maximum sample time in seconds for the observed sensor in LwM2M 1.1 or later. Setting an attribute is in the form Name \"=\" value with some constraints: lt value < gt value lt value + 2 * st value < gt value If pmax < pmin , pmax is ignored epmax > epmin Clearing an attribute is in the form Name . attributesStr Examples Receiving a notification every minute at most even if the observed URI did not change: \"pmax=60\" . Receiving only one notification per hour even if the observed URI changed several times per minute: \"pmin=3600\" . Receiving exactly one notification every sixty seconds: \"pmin=59&pmax=60\" . Receiving a notification when the resource value exceeds 95 or falls below 10, and when the resource value returns below 95 or above 10: \"lt=10&gt=95\" . Clearing the previously set minimum period and setting a maximum period of five minutes: \"pmin&pmax=300\" . \\clearpage iowa_server_dm_exec \u00b6 Prototype iowa_status_t iowa_server_dm_exec ( iowa_context_t contextP , uint32_t clientID , uint16_t objectID , uint16_t instanceID , uint16_t resourceID , iowa_result_callback_t resultCb , void * resultUserData ); Description iowa_server_dm_exec() performs an Execute operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . objectID : The ID of the Object. instanceID : The ID of the instance. resourceID : The ID of the resource. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : objectID , instanceID or resourceID is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Execute was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Per LwM2M specification, a Server can do an Execute only on an URI in the form / object / instance / resource . Thus instanceID and resourceID cannot be set IOWA_LWM2M_ID_ALL . The resultCb will be called with the operation set to IOWA_DM_EXECUTE . \\clearpage iowa_server_dm_create \u00b6 Prototype iowa_status_t iowa_server_dm_create ( iowa_context_t contextP , uint32_t clientId , uint16_t objectId , uint16_t instanceId , size_t dataCount , iowa_lwm2m_data_t * dataArrayP , iowa_result_callback_t resultCb , void * resultUserData ); Description iowa_server_dm_create() performs a Create operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . objectId , instanceId : The Object Instance targeted by the operation. dataCount , dataArrayP : The data to write. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - objectId or instanceId is IOWA_LWM2M_ID_ALL . : - dataCount is zero or dataArrayP is nil. : - dataArrayP contains several data with unknown type. IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. IOWA_COAP_406_NOT_ACCEPTABLE : Either: : - dataArrayP contains several data with defined timestamp. : - dataArrayP contains several data of unsigned integer type which are negative. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed Header File iowa_server.h Notes Per LwM2M specification, if the Create was successful, the Client will return a IOWA_COAP_201_CREATED status code. The IDs contained in the data must match objectId and instanceId . The resultCb will be called with the operation set to IOWA_DM_CREATE . \\clearpage iowa_server_dm_delete \u00b6 Prototype iowa_status_t iowa_server_dm_delete ( iowa_context_t contextP , uint32_t clientID , uint16_t objectID , uint16_t instanceID , iowa_result_callback_t resultCb , void * resultUserData ); Description iowa_server_dm_delete() performs an Delete operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . objectID : The ID of the Object. instanceID : The ID of the instance to delete. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : objectID or instanceID is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Delete was successful, the Client will return an IOWA_COAP_202_DELETED status code. Per LwM2M specification, a Server can do a Delete only on an URI in the form / object / instance . Thus objectID and instanceID cannot be set IOWA_LWM2M_ID_ALL . The resultCb will be called with the operation set to IOWA_DM_DELETE . \\clearpage iowa_server_dm_discover \u00b6 Prototype iowa_status_t iowa_server_dm_discover ( iowa_context_t contextP , uint32_t clientID , uint16_t objectID , uint16_t instanceID , uint16_t resourceID , iowa_result_callback_t resultCb , void * resultUserData ); Description iowa_server_dm_discover() performs a Discover operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . objectID : The ID of the Object. instanceID : The ID of the instance to delete. This can be IOWA_LWM2M_ID_ALL . resourceID : The ID of the resource to observe. This can be IOWA_LWM2M_ID_ALL . resultCb : The callback called when the reply to this operation is known. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - resultCb is nil. : - objectID is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Discover was successful, the Client will return an IOWA_COAP_205_CONTENT status code. Per LwM2M specification, a Server can do a Discover on an URI in the forms / object , / object / instance or / object / instance / resource . Thus if instanceID is set to IOWA_LWM2M_ID_ALL , resourceID must be set to IOWA_LWM2M_ID_ALL . The resultCb will be called with the operation set to IOWA_DM_DISCOVER . \\clearpage iowa_server_set_response_format \u00b6 Prototype iowa_status_t iowa_server_set_response_format ( iowa_context_t contextP , uint32_t clientID , iowa_content_format_t multiResourcesFormat , iowa_content_format_t singleResourceFormat ); Description iowa_server_set_response_format() sets the content format to use when requesting data from a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . multiResourcesFormat : format to use when requesting several resources. singleResourceFormat : format to use when requesting a single resource. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : multiResourcesFormat is set to a content format which does not support multiple resources encoding. IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. Header File iowa_server.h Notes By default, IOWA uses LwM2M TLV for all data encodings. If the flag LWM2M_VERSION_1_0_REMOVE is used, IOWA uses CBOR for single resource and SenML CBOR for multiples resources. If the Client does not support the requested content format, it will switch to another one. \\clearpage iowa_server_set_payload_format \u00b6 Prototype iowa_status_t iowa_server_set_payload_format ( iowa_context_t contextP , uint32_t clientID , iowa_content_format_t multiResourcesFormat , iowa_content_format_t singleResourceFormat ); Description iowa_server_set_payload_format() sets the content format to use when sending data to a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . multiResourcesFormat : format to use when sending several resources. singleResourceFormat : format to use when sending a single resource. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : multiResourcesFormat is set to a content format which does not support multiple resources encoding. IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. Header File iowa_server.h Notes By default, IOWA uses LwM2M TLV for all data encodings. If the flag LWM2M_VERSION_1_0_REMOVE is used, IOWA uses CBOR for single resource and SenML CBOR for multiples resources. If the Client does not support the encoding format of the data provided, it will return a IOWA_COAP_415_UNSUPPORTED_CONTENT_FORMAT error code in the callback of the iowa_server_write call. \\clearpage iowa_server_create_registration_update_trigger_message \u00b6 Prototype size_t iowa_server_create_registration_update_trigger_message ( uint16_t serverInstanceId , uint8_t ** bufferP ); Description iowa_server_create_registration_update_trigger_message() creates a Registration Update Trigger message. When receiving a Registration Update Trigger message, a LwM2M Client updates its registration to the targeted LwM2M Server. This mechanism is useful to \"wake\" up a LwM2M Client which is not longer reachable on the current transport. Arguments serverInstanceId : The Instance ID of the targeted LwM2M Server in the LwM2M Client's [ Server Object ][Server Object]. bufferP : Used to store the Registration Update Trigger message. Return Value The length of the buffer in bytes, or 0 in case of an error. Header File iowa_server.h Notes bufferP will be allocated by the iowa_server_create_registration_update_trigger_message() function using iowa_system_malloc() . It is the caller responsibility to free the buffer. It is the caller responsibility to send the Registration Update Trigger message to the LwM2M Client, typically using SMS. \\clearpage iowa_server_close_client_connection \u00b6 Prototype iowa_status_t iowa_server_close_client_connection ( iowa_context_t contextP , uint32_t clientId ); Description iowa_server_close_client_connection() closes the current connection with a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. Notes Depending of the transport used and the connection encryption, the Client will be informed or not of the closing connection. Some examples: UDP / Not secure: Client is not informed UDP / Secure: Client is informed TCP / Not secure: Client is informed TCP / Secure: Client is informed","title":"Server APIs"},{"location":"ServerAPI/#server-mode-api-reference","text":"The functions explained below are defined inside the file include/iowa_server.h .","title":"Server Mode API Reference"},{"location":"ServerAPI/#server-pseudo-code","text":"#include \"iowa_server.h\" int main ( int argc , char * argv []) { iowa_context_t iowaH ; iowa_status_t result ; int serverSocket ; /****************** * Initialization */ serverSocket = open_udp_socket (); iowaH = iowa_init ( NULL ); result = iowa_server_configure ( iowaH , client_monitor , NULL , NULL ); /****************** * \"Main loop\" */ while ( result == IOWA_COAP_NO_ERROR ) { result = iowa_step ( iowaH , 10 ); if ( isDataAvailable ( serverSocket )) { void * newConnection ; newConnection = create_new_connection (); result = iowa_server_new_incoming_connection ( iowaH , IOWA_CONN_DATAGRAM , newConnection , true ); } } iowa_close ( iowaH ); close ( serverSocket ); return 0 ; }","title":"Server pseudo code"},{"location":"ServerAPI/#data-types","text":"","title":"Data types"},{"location":"ServerAPI/#iowa_supported_format_t","text":"typedef uint8_t iowa_supported_format_t ; #define IOWA_SUPPORTED_FORMAT_UNKNOWN 0x00 #define IOWA_SUPPORTED_FORMAT_TLV 0x01 #define IOWA_SUPPORTED_FORMAT_JSON 0x02 #define IOWA_SUPPORTED_FORMAT_OLD_TLV 0x04 #define IOWA_SUPPORTED_FORMAT_OLD_JSON 0x08 #define IOWA_SUPPORTED_FORMAT_CBOR 0x10 #define IOWA_SUPPORTED_FORMAT_SENML_JSON 0x20 #define IOWA_SUPPORTED_FORMAT_SENML_CBOR 0x40 This contains the possible supported content format. It is an enumeration of the following values: IOWA_SUPPORTED_FORMAT_UNKNOWN : Unknown supported format. IOWA_SUPPORTED_FORMAT_TLV : TLV supported format. IOWA_SUPPORTED_FORMAT_JSON : JSON supported format. IOWA_SUPPORTED_FORMAT_OLD_TLV : Old TLV supported format. IOWA_SUPPORTED_FORMAT_OLD_JSON : Old JSON supported format. IOWA_SUPPORTED_FORMAT_CBOR : CBOR format. IOWA_SUPPORTED_FORMAT_SENML_JSON : SenML JSON supported format. IOWA_SUPPORTED_FORMAT_SENML_CBOR : SenML CBOR supported format.","title":"iowa_supported_format_t"},{"location":"ServerAPI/#iowa_lwm2m_protocol_version_t","text":"typedef enum { IOWA_LWM2M_VERSION_UNDEFINED = 0 , IOWA_LWM2M_VERSION_1_0 , IOWA_LWM2M_VERSION_1_1 } iowa_lwm2m_protocol_version_t ; This contains the possible LwM2M Enabler version. It is an enumeration of the following values: IOWA_LWM2M_VERSION_UNDEFINED : Unknown LwM2M enabler version. IOWA_LWM2M_VERSION_1_0 : LwM2M Enabler version 1.0. IOWA_LWM2M_VERSION_1_1 : LwM2M Enabler version 1.1.","title":"iowa_lwm2m_protocol_version_t"},{"location":"ServerAPI/#iowa_client_t","text":"This structure describes a LwM2M Client known to the LwM2M Server. typedef struct { const char * name ; uint16_t id ; bool queueMode ; iowa_supported_format_t supportedFormats ; const char * msisdn ; size_t objectLinkCount ; iowa_lwm2m_object_link_t * objectLinkArray ; uint32_t lifetime ; iowa_connection_type_t connectionType ; bool secureConnection ; iowa_lwm2m_protocol_version_t lwm2mVersion ; } iowa_client_t ; name : The unique name of the Client. id : The internal ID of the Client. To be used with iowa_server_dm_...() APIs. queueMode : Set to true if the LwM2M Client supports the Queue Mode. supportedFormats : The content formats supported by the Client. msisdn : The MSISDN to which the LwM2M Client is reachable for SMS trigger. objectLinkCount : The number of elements in the objectLinkArray . objectLinkArray : An array containing the Objects and Object Instances registered by the Client. : If an Object has no Instances, iowa_lwm2m_object_link_t::instanceID is set to IOWA_LWM2M_ID_ALL . lifetime : The lifetime of the Client. connectionType : The type of the connection on which the Client reach the Server. secureConnection : Set to true if the connection is encrypted. lwm2mVersion : The LwM2M Enabler version used by the Client. \\clearpage","title":"iowa_client_t"},{"location":"ServerAPI/#callbacks","text":"","title":"Callbacks"},{"location":"ServerAPI/#iowa_result_callback_t","text":"The device management APIs ( iowa_server_write() , iowa_server_dm_exec() , iowa_server_dm_create() , iowa_server_dm_delete() , iowa_server_dm_discover() and iowa_server_observe() ) are using an iowa_result_callback_t to asynchronously return the result of the operation. typedef void ( * iowa_result_callback_t ) ( iowa_dm_operation_t operation , uint16_t clientId , uint16_t objectId , uint16_t instanceId , uint16_t resourceId , iowa_status_t status , size_t dataCount , iowa_lwm2m_data_t * dataArray , void * resultUserData , iowa_context_t contextP ); operation : The type of command matching this result. clientId : The ID of the client targeted by the command. objectId : The ID of the Object targeted by the command. instanceId : The ID of the Instance targeted by the command. This may be IOWA_LWM2M_ID_ALL . resourceId : The ID of the Resource targeted by the command. This may be IOWA_LWM2M_ID_ALL . status : The status of the command or the notification counter if operation is IOWA_DM_NOTIFY . dataCount : The number of elements in the dataArray . This may be 0. dataArray : An array containing the Resource values returned by the Client. This may be nil. resultUserData : A pointer to application specific data. This is a parameter of the matching iowa_server_dm_...() API. contextP : The IOWA context on which the device management API ( iowa_server_dm_exec() ) was called.","title":"iowa_result_callback_t"},{"location":"ServerAPI/#iowa_monitor_callback_t","text":"This is the client state monitoring callback, called when a LwM2M Client changes its registration to the Server or when a LwM2M Client connects to the Bootstrap Server. typedef void ( * iowa_monitor_callback_t )( const iowa_client_t * clientP , iowa_state_t state , void * callbackUserData , iowa_context_t contextP ); clientP : The information of the Client. state : The new state of the Client among: : - IOWA_STATE_REGISTERED : when a new or returning client registers. : - IOWA_STATE_UPDATING : when a client updates its registration. : - IOWA_STATE_UNREGISTERED : when a client ends its registration or when the registration expires. : - IOWA_STATE_BOOTSTRAP_REQUIRED : when a new or returning client connects to the bootstrap server. : - IOWA_STATE_BOOTSTRAPPING : when a client is in bootstrapping state. : - IOWA_STATE_BOOTSTRAP_FAILED : when the bootstrapping procedure of a client failed. : - IOWA_STATE_BOOTSTRAP_FINISHED : when the bootstrapping procedure of a client succeeded. callbackUserData : A pointer to application specific data. This is a parameter of `iowa_server_configure() . contextP : The IOWA context on which iowa_server_configure() was called. When state is set to IOWA_STATE_UNREGISTERED , clientP contains only the ID of the former Client. When state is set to IOWA_STATE_BOOTSTRAP_REQUIRED , IOWA_STATE_BOOTSTRAPPING , IOWA_STATE_BOOTSTRAP_FAILED , or IOWA_STATE_BOOTSTRAP_FINISHED , clientP contains only the ID, the name of the Client and the connection type information.","title":"iowa_monitor_callback_t"},{"location":"ServerAPI/#iowa_resource_type_callback_t","text":"This is the callback called to retrieve the data type of resources of non standard LwM2M Objects. typedef iowa_lwm2m_data_type_t ( * iowa_resource_type_callback_t ) ( uint16_t objectID , uint16_t resourceID , void * callbackUserData ); Arguments objectID : The ID of the non standard LwM2M Objects. resourceID : The ID of the resource inside the non standard LwM2M Objects. callbackUserData : A pointer to application specific data. This is a parameter of `iowa_server_configure() . Return Value The data type of the resource or IOWA_LWM2M_TYPE_UNDEFINED .","title":"iowa_resource_type_callback_t"},{"location":"ServerAPI/#iowa_verify_client_callback_t","text":"This is the callback called when LwM2M Clients register to the Server. If the callback returns IOWA_COAP_NO_ERROR , the Client is accepted by the Server. Otherwise, to reject a Client the callback has to return ONLY the following values: IOWA_COAP_400_BAD_REQUEST if the Client is unknown or something does not match. IOWA_COAP_409_CONFLICT if on LoRaWAN transport, the Client didn't provide its objects list and this list is not present on Server side. typedef iowa_status_t ( * iowa_verify_client_callback_t ) ( const iowa_client_t * clientP , iowa_state_t state , void * callbackUserData , iowa_context_t contextP ); clientP : The information of the Client. state : The new state of the Client among: : - IOWA_STATE_REGISTERING : when a new or returning client registers. : - IOWA_STATE_UPDATING : when a client updates its registration. : - IOWA_STATE_BOOTSTRAP_REQUIRED : when a new or returning client connects to the bootstrap server. callbackUserData : A pointer to application specific data. This is a parameter of `iowa_server_set_verify_client_callback() . contextP : The IOWA context on which iowa_server_configure() was called. When state is set to IOWA_STATE_BOOTSTRAP_REQUIRED , clientP contains only the ID, the name of the Client and the connection type information. \\clearpage","title":"iowa_verify_client_callback_t"},{"location":"ServerAPI/#api","text":"","title":"API"},{"location":"ServerAPI/#iowa_server_configure","text":"Prototype iowa_status_t iowa_server_configure ( iowa_context_t contextP , iowa_monitor_callback_t monitorCb , iowa_resource_type_callback_t resTypeCb , void * callbackUserData ); Description iowa_server_configure() sets the monitoring callback called when LwM2M Clients register to the Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. monitorCb : The callback called when Clients update their status. This can be nil. resTypeCb : The callback called when parsing received data of non standard LwM2M Objects. This can be nil. callbackUserData : A pointer to application specific data. This is passed as argument to monitorCb and resTypeCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. Header File iowa_server.h \\clearpage","title":"iowa_server_configure"},{"location":"ServerAPI/#iowa_server_set_verify_client_callback","text":"Prototype void iowa_server_set_verify_client_callback ( iowa_context_t contextP , iowa_verify_client_callback_t verifyClientCb , void * callbackUserData ); Description iowa_server_set_verify_client_callback() sets the verify client callback called when LwM2M Clients register to the Server. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. verifyClientCb : The callback called when Clients register. This can be nil. callbackUserData : A pointer to application specific data. This is passed as argument to verifyClientCb . This can be nil. Return Value None. Header File iowa_server.h Notes If the verify client callback is not set, Clients will always be accepted. \\clearpage","title":"iowa_server_set_verify_client_callback"},{"location":"ServerAPI/#iowa_server_new_incoming_connection","text":"Prototype iowa_status_t iowa_server_new_incoming_connection ( iowa_context_t contextP , iowa_connection_type_t type , void * connP , bool isSecure ); Description iowa_server_new_incoming_connection() informs the stack of a new incoming connection. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. type : The type of the new connection. See iowa_connection_type_t . connP : The new connection of the same user-defined type as the one returned by iowa_system_connection_open() . isSecure : Set to true if the security must be enabled on this connection. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_503_SERVICE_UNAVAILABLE : either: : - a memory allocation failed. : - type is unsupported. Header File iowa_server.h \\clearpage","title":"iowa_server_new_incoming_connection"},{"location":"ServerAPI/#iowa_server_configure_data_push","text":"Prototype void iowa_server_configure_data_push ( iowa_context_t contextP , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_server_configure_data_push() enables/disables the Data push operation for all clients. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. responseCb : The callback called when a client pushes data. If this callback is nil, data push possibility is disabled. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value None. Header File iowa_server.h Notes The responseCb will be called with the operation set to IOWA_DM_DATA_PUSH and the status code set to IOWA_COAP_205_CONTENT . To be able to use this function, [ LWM2M_DATA_PUSH_SUPPORT ][LWM2M_DATA_PUSH_SUPPORT] must be defined. \\clearpage","title":"iowa_server_configure_data_push"},{"location":"ServerAPI/#iowa_server_read","text":"Prototype iowa_status_t iowa_server_read ( iowa_context_t contextP , uint32_t clientId , size_t uriCount , iowa_lwm2m_uri_t * uriP , iowa_response_callback_t responseCb , void * userDataP ) Description iowa_server_read() performs a Read operation on Client\u2019s URIs. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uriCount, uriP : An array of the URIs to read. responseCb : The callback called when the reply to this operation is known. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : Either: : - responseCb is nil. : - uriCount is zero or uriP is nil. : - uriP targets Object ID IOWA_LWM2M_ID_ALL and [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] is not defined. : - uriP targets Object ID IOWA_LWM2M_ID_ALL , [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] is defined, but uriCount is not equal to 1. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : A memory allocation failed. IOWA_COAP_501_NOT_IMPLEMENTED : uriCount is superior to 1 with [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] not defined. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Read was successful, the Client will return a IOWA_COAP_205_CONTENT status code. The ability to read several URIs at once is only present in LwM2M version 1.1 or later, this means that to use it LWM2M_VERSION_1_1_SUPPORT must be defined. This feature is only operational on SenML JSON and SenML CBOR data encoding, so LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR must be defined. Some LwM2M Clients may not be able to read on several URIs in a single operation. In this case the resultCb will be called with an error status, typically IOWA_COAP_405_METHOD_NOT_ALLOWED . Per LwM2M specification, when handling a read on several URIs in a single operation, the LwM2M Client treats the request as non-atomic and handles it as best effort. Hence the reply may not contain the values of all the requested URIs. The responseCb will be called with the operation set to IOWA_DM_READ . \\clearpage","title":"iowa_server_read"},{"location":"ServerAPI/#iowa_server_observe","text":"Prototype iowa_status_t iowa_server_observe ( iowa_context_t contextP , uint32_t clientId , size_t uriCount , iowa_lwm2m_uri_t * uriP , iowa_response_callback_t responseCb , void * userDataP , uint16_t * observeIdP ); Description iowa_server_observe() begins an observation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uriCount, uriP : An array of the URIs to observe. responseCb : The callback called when the reply to this operation is known. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. observeIdP : Used to store the ID of the observation. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : Either: : - responseCb is nil. : - observeIdP is nil. : - uriCount is zero or uriP is nil. : - uriP targets Object ID IOWA_LWM2M_ID_ALL and [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] is not defined. : - uriP targets Object ID IOWA_LWM2M_ID_ALL , [ LWM2M_READ_COMPOSITE_SUPPORT ][LWM2M_READ_COMPOSITE_SUPPORT] is defined, but uriCount is not equal to 1. : - At least one uriP is invalid: instanceId is equal to IOWA_LWM2M_ID_ALL but resourceId is not equal to IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_412_PRECONDITION_FAILED : Observe was already launched. observeIdP is set to the value of the previous observation. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : A memory allocation failed. IOWA_COAP_501_NOT_IMPLEMENTED : uriCount is superior to 1 with [ LWM2M_OBSERVE_COMPOSITE_SUPPORT ][LWM2M_OBSERVE_COMPOSITE_SUPPORT] not defined. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Observe was successful, the Client will return a IOWA_COAP_205_CONTENT status code with the first notification. The responseCb will be called with the operation set to IOWA_DM_NOTIFY : When the observation is internally deleted, responseCb will be called with status to IOWA_COAP_202_DELETED . When the client deregisters or when the connection with the client is lost, responseCb will be called with status to IOWA_COAP_503_SERVICE_UNAVAILABLE . Some LwM2M Clients may not be able to observe on several URIs in a single operation. In this case the responseCb will be called with an error status, typically IOWA_COAP_405_METHOD_NOT_ALLOWED . When using an unreliable communication layer, notifications may be lost or arrive out of order. \\clearpage","title":"iowa_server_observe"},{"location":"ServerAPI/#iowa_server_observe_cancel","text":"Prototype iowa_status_t iowa_server_observe_cancel ( iowa_context_t contextP , uint32_t clientId , uint16_t observeId ); Description iowa_server_observe_cancel() cancels an observation on a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . observeId : The ID of the observation as returned by iowa_server_observe . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : either: : - clientId does not match a known client. : - observeId does not match a known observation. IOWA_COAP_500_INTERNAL_SERVER_ERROR : A memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes When using an unreliable communication layer, the cancellation request from the LwM2M Server to the LwM2M Client may be lost. However the observation is always cancelled. \\clearpage","title":"iowa_server_observe_cancel"},{"location":"ServerAPI/#iowa_server_write","text":"Prototype iowa_status_t iowa_server_write ( iowa_context_t contextP , uint32_t clientId , size_t dataCount , iowa_lwm2m_data_t * dataArrayP , iowa_response_callback_t responseCb , void * userDataP ) Description iowa_server_write() performs a Write operation on a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . dataCount, dataArrayP : The data to write. responseCb : The callback called when the reply to this operation is known. This can be nil. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : Either: : - dataCount is zero or dataArrayP is nil. : - dataArrayP[x].objectID or dataArrayP[x].instanceID or dataArrayP[x].resourceID is IOWA_LWM2M_ID_ALL . : - dataArrayP contains several data with incorrect type. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_406_NOT_ACCEPTABLE : either: : - dataArrayP contains several data with different objectID or instanceID but LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR are not defined. : - dataArrayP contains several data with defined timestamp. : - dataArrayP contains several data of unsigned integer type which are negative. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_501_NOT_IMPLEMENTED : dataArrayP has different objectID or instanceID with [ LWM2M_WRITE_COMPOSITE_SUPPORT ][LWM2M_WRITE_COMPOSITE_SUPPORT] not defined. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Write was successful, the Client will return a IOWA_COAP_204_CHANGED status code. To be able to write on different dataArrayP[x].objectID or dataArrayP[x].instanceID at once, LWM2M_SUPPORT_SENML_JSON or LWM2M_SUPPORT_SENML_CBOR must be defined. Some LwM2M Clients may not be able to write on different dataArrayP[x].objectID or dataArrayP[x].instanceID in a single operation. In this case the responseCb will be called with an error status, typically IOWA_COAP_405_METHOD_NOT_ALLOWED . The responseCb will be called with the operation set to IOWA_DM_WRITE . \\clearpage","title":"iowa_server_write"},{"location":"ServerAPI/#iowa_server_write_attributes_string","text":"Prototype iowa_status_t iowa_server_write_attributes_string ( iowa_context_t contextP , uint32_t clientId , iowa_lwm2m_uri_t * uriP , const char * attributesStr , iowa_response_callback_t responseCb , void * userDataP ); Description iowa_server_write_attributes_string() performs a Write-Attributes operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . uriP : The URI targeted by the operation. attributesStr : The attributes to write as a query string. responseCb : The callback called when the reply to this operation is known. This can be nil. userDataP : A pointer to application specific data. This is passed as argument to responseCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either : uriP is nil. : uriP->objectId is IOWA_LWM2M_ID_ALL . : uriP->resInstanceId is not IOWA_LWM2M_ID_ALL and LWM2M_VERSION_1_1_SUPPORT is not set. : attributesStr is nil or an empty string. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : a memory allocation failed. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Write-Attributes was successful, the Client will return a IOWA_COAP_204_CHANGED status code. The responseCb will be called with the operation set to IOWA_DM_WRITE_ATTRIBUTES . LwM2M defines the following attributes: Name Level Description pmin Object, Object Instance, Resource The minimum period in seconds to wait between notifications. pmax Object, Object Instance, Resource The maximum period in seconds to wait between notifications. gt Numerical Resource An upper threshold. A notification is sent when the resource value crosses this threshold. lt Numerical Resource An lower threshold. A notification is sent when the resource value crosses this threshold. st Numerical Resource A difference minimum in a resource value for a notification to be sent. epmin Object, Object Instance, Resource The minimum sample time in seconds for the observed sensor in LwM2M 1.1 or later. epmax Object, Object Instance, Resource The maximum sample time in seconds for the observed sensor in LwM2M 1.1 or later. Setting an attribute is in the form Name \"=\" value with some constraints: lt value < gt value lt value + 2 * st value < gt value If pmax < pmin , pmax is ignored epmax > epmin Clearing an attribute is in the form Name . attributesStr Examples Receiving a notification every minute at most even if the observed URI did not change: \"pmax=60\" . Receiving only one notification per hour even if the observed URI changed several times per minute: \"pmin=3600\" . Receiving exactly one notification every sixty seconds: \"pmin=59&pmax=60\" . Receiving a notification when the resource value exceeds 95 or falls below 10, and when the resource value returns below 95 or above 10: \"lt=10&gt=95\" . Clearing the previously set minimum period and setting a maximum period of five minutes: \"pmin&pmax=300\" . \\clearpage","title":"iowa_server_write_attributes_string"},{"location":"ServerAPI/#iowa_server_dm_exec","text":"Prototype iowa_status_t iowa_server_dm_exec ( iowa_context_t contextP , uint32_t clientID , uint16_t objectID , uint16_t instanceID , uint16_t resourceID , iowa_result_callback_t resultCb , void * resultUserData ); Description iowa_server_dm_exec() performs an Execute operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . objectID : The ID of the Object. instanceID : The ID of the instance. resourceID : The ID of the resource. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : objectID , instanceID or resourceID is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Execute was successful, the Client will return an IOWA_COAP_204_CHANGED status code. Per LwM2M specification, a Server can do an Execute only on an URI in the form / object / instance / resource . Thus instanceID and resourceID cannot be set IOWA_LWM2M_ID_ALL . The resultCb will be called with the operation set to IOWA_DM_EXECUTE . \\clearpage","title":"iowa_server_dm_exec"},{"location":"ServerAPI/#iowa_server_dm_create","text":"Prototype iowa_status_t iowa_server_dm_create ( iowa_context_t contextP , uint32_t clientId , uint16_t objectId , uint16_t instanceId , size_t dataCount , iowa_lwm2m_data_t * dataArrayP , iowa_result_callback_t resultCb , void * resultUserData ); Description iowa_server_dm_create() performs a Create operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . objectId , instanceId : The Object Instance targeted by the operation. dataCount , dataArrayP : The data to write. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - objectId or instanceId is IOWA_LWM2M_ID_ALL . : - dataCount is zero or dataArrayP is nil. : - dataArrayP contains several data with unknown type. IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. IOWA_COAP_406_NOT_ACCEPTABLE : Either: : - dataArrayP contains several data with defined timestamp. : - dataArrayP contains several data of unsigned integer type which are negative. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed Header File iowa_server.h Notes Per LwM2M specification, if the Create was successful, the Client will return a IOWA_COAP_201_CREATED status code. The IDs contained in the data must match objectId and instanceId . The resultCb will be called with the operation set to IOWA_DM_CREATE . \\clearpage","title":"iowa_server_dm_create"},{"location":"ServerAPI/#iowa_server_dm_delete","text":"Prototype iowa_status_t iowa_server_dm_delete ( iowa_context_t contextP , uint32_t clientID , uint16_t objectID , uint16_t instanceID , iowa_result_callback_t resultCb , void * resultUserData ); Description iowa_server_dm_delete() performs an Delete operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . objectID : The ID of the Object. instanceID : The ID of the instance to delete. resultCb : The callback called when the reply to this operation is known. This can be nil. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : objectID or instanceID is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Delete was successful, the Client will return an IOWA_COAP_202_DELETED status code. Per LwM2M specification, a Server can do a Delete only on an URI in the form / object / instance . Thus objectID and instanceID cannot be set IOWA_LWM2M_ID_ALL . The resultCb will be called with the operation set to IOWA_DM_DELETE . \\clearpage","title":"iowa_server_dm_delete"},{"location":"ServerAPI/#iowa_server_dm_discover","text":"Prototype iowa_status_t iowa_server_dm_discover ( iowa_context_t contextP , uint32_t clientID , uint16_t objectID , uint16_t instanceID , uint16_t resourceID , iowa_result_callback_t resultCb , void * resultUserData ); Description iowa_server_dm_discover() performs a Discover operation on a Client\u2019s URI. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . objectID : The ID of the Object. instanceID : The ID of the instance to delete. This can be IOWA_LWM2M_ID_ALL . resourceID : The ID of the resource to observe. This can be IOWA_LWM2M_ID_ALL . resultCb : The callback called when the reply to this operation is known. resultUserData : A pointer to application specific data. This is passed as argument to resultCb . This can be nil. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : either: : - resultCb is nil. : - objectID is IOWA_LWM2M_ID_ALL . IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. IOWA_COAP_413_REQUEST_ENTITY_TOO_LARGE : The Platform abstraction didn't send all the data. One possible assumption is the packet was too large for the transport. IOWA_COAP_500_INTERNAL_SERVER_ERROR : either: : - a memory allocation failed. : - iowa_system_gettime() returned an error. IOWA_COAP_503_SERVICE_UNAVAILABLE : Communication with the LwM2M Client failed. Header File iowa_server.h Notes Per LwM2M specification, if the Discover was successful, the Client will return an IOWA_COAP_205_CONTENT status code. Per LwM2M specification, a Server can do a Discover on an URI in the forms / object , / object / instance or / object / instance / resource . Thus if instanceID is set to IOWA_LWM2M_ID_ALL , resourceID must be set to IOWA_LWM2M_ID_ALL . The resultCb will be called with the operation set to IOWA_DM_DISCOVER . \\clearpage","title":"iowa_server_dm_discover"},{"location":"ServerAPI/#iowa_server_set_response_format","text":"Prototype iowa_status_t iowa_server_set_response_format ( iowa_context_t contextP , uint32_t clientID , iowa_content_format_t multiResourcesFormat , iowa_content_format_t singleResourceFormat ); Description iowa_server_set_response_format() sets the content format to use when requesting data from a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . multiResourcesFormat : format to use when requesting several resources. singleResourceFormat : format to use when requesting a single resource. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : multiResourcesFormat is set to a content format which does not support multiple resources encoding. IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. Header File iowa_server.h Notes By default, IOWA uses LwM2M TLV for all data encodings. If the flag LWM2M_VERSION_1_0_REMOVE is used, IOWA uses CBOR for single resource and SenML CBOR for multiples resources. If the Client does not support the requested content format, it will switch to another one. \\clearpage","title":"iowa_server_set_response_format"},{"location":"ServerAPI/#iowa_server_set_payload_format","text":"Prototype iowa_status_t iowa_server_set_payload_format ( iowa_context_t contextP , uint32_t clientID , iowa_content_format_t multiResourcesFormat , iowa_content_format_t singleResourceFormat ); Description iowa_server_set_payload_format() sets the content format to use when sending data to a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientID : The ID of the client as reported in the iowa_monitor_callback_t . multiResourcesFormat : format to use when sending several resources. singleResourceFormat : format to use when sending a single resource. Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_400_BAD_REQUEST : multiResourcesFormat is set to a content format which does not support multiple resources encoding. IOWA_COAP_404_NOT_FOUND : clientID does not match a known client. Header File iowa_server.h Notes By default, IOWA uses LwM2M TLV for all data encodings. If the flag LWM2M_VERSION_1_0_REMOVE is used, IOWA uses CBOR for single resource and SenML CBOR for multiples resources. If the Client does not support the encoding format of the data provided, it will return a IOWA_COAP_415_UNSUPPORTED_CONTENT_FORMAT error code in the callback of the iowa_server_write call. \\clearpage","title":"iowa_server_set_payload_format"},{"location":"ServerAPI/#iowa_server_create_registration_update_trigger_message","text":"Prototype size_t iowa_server_create_registration_update_trigger_message ( uint16_t serverInstanceId , uint8_t ** bufferP ); Description iowa_server_create_registration_update_trigger_message() creates a Registration Update Trigger message. When receiving a Registration Update Trigger message, a LwM2M Client updates its registration to the targeted LwM2M Server. This mechanism is useful to \"wake\" up a LwM2M Client which is not longer reachable on the current transport. Arguments serverInstanceId : The Instance ID of the targeted LwM2M Server in the LwM2M Client's [ Server Object ][Server Object]. bufferP : Used to store the Registration Update Trigger message. Return Value The length of the buffer in bytes, or 0 in case of an error. Header File iowa_server.h Notes bufferP will be allocated by the iowa_server_create_registration_update_trigger_message() function using iowa_system_malloc() . It is the caller responsibility to free the buffer. It is the caller responsibility to send the Registration Update Trigger message to the LwM2M Client, typically using SMS. \\clearpage","title":"iowa_server_create_registration_update_trigger_message"},{"location":"ServerAPI/#iowa_server_close_client_connection","text":"Prototype iowa_status_t iowa_server_close_client_connection ( iowa_context_t contextP , uint32_t clientId ); Description iowa_server_close_client_connection() closes the current connection with a Client. Arguments contextP : An iowa_context_t as returned by iowa_init() . Not checked at runtime. clientId : The ID of the client as reported in the iowa_monitor_callback_t . Return Value IOWA_COAP_NO_ERROR : success. IOWA_COAP_404_NOT_FOUND : clientId does not match a known client. Notes Depending of the transport used and the connection encryption, the Client will be informed or not of the closing connection. Some examples: UDP / Not secure: Client is not informed UDP / Secure: Client is informed TCP / Not secure: Client is informed TCP / Secure: Client is informed","title":"iowa_server_close_client_connection"},{"location":"Streamable/","text":"Custom Object Streaming APIs \u00b6 Let's consider a proprietary LwM2M Object presenting Device generated logs with the following resources: Resource Name Resource ID Access Type Mandatory Type Description Logs Available 0 R Mandatory Boolean True means some logs are available. Logs 1 R Mandatory String The logs. The logs can be very large and thus needs to be retrieved by blocks. Object Declaration \u00b6 When declaring the Object, inform IOWA that the resource with ID 1 can be retrieved by blocks: iowa_lwm2m_resource_desc_t resources [ 2 ] = { { 0 , IOWA_LWM2M_TYPE_BOOLEAN , IOWA_DM_READ , IOWA_RESOURCE_FLAG_MANDATORY }, { 1 , IOWA_LWM2M_TYPE_STRING , IOWA_DM_READ , IOWA_RESOURCE_FLAG_MANDATORY | IOWA_RESOURCE_FLAG_STREAMABLE } }; Callback Implementation \u00b6 In iowa.h , the iowa_lwm2m_data_t structure is expanded to to be able contain a block of a string, opaque, or CoRE Link value: typedef uint8_t iowa_lwm2m_data_type_t ; #define IOWA_LWM2M_TYPE_UNDEFINED 0 #define IOWA_LWM2M_TYPE_STRING 1 #define IOWA_LWM2M_TYPE_OPAQUE 2 #define IOWA_LWM2M_TYPE_INTEGER 3 #define IOWA_LWM2M_TYPE_FLOAT 4 #define IOWA_LWM2M_TYPE_BOOLEAN 5 #define IOWA_LWM2M_TYPE_CORE_LINK 6 #define IOWA_LWM2M_TYPE_OBJECT_LINK 7 #define IOWA_LWM2M_TYPE_TIME 8 #define IOWA_LWM2M_TYPE_UNSIGNED_INTEGER 9 #define IOWA_LWM2M_TYPE_STRING_BLOCK 101 #define IOWA_LWM2M_TYPE_OPAQUE_BLOCK 102 #define IOWA_LWM2M_TYPE_CORE_LINK_BLOCK 106 typedef struct { uint16_t objectID ; uint16_t instanceID ; uint16_t resourceID ; uint16_t resInstanceID ; iowa_lwm2m_data_type_t type ; union { bool asBoolean ; int64_t asInteger ; double asFloat ; struct { size_t length ; uint8_t * buffer ; } asBuffer ; struct { uint32_t details ; uint8_t * buffer ; } asBlock ; iowa_lwm2m_object_link_t asObjLink ; } value ; int32_t timestamp ; } iowa_lwm2m_data_t ; iowa_lwm2m_data_t::value::asBlock::buffer contains the block of data. iowa_lwm2m_data_t::value::asBlock::details contains the information of the block. It is to be treated as an opaque type and must be accessed only with the helper functions below: // Get block information from an iowa_lwm2m_data_t. // Returned value: IOWA_COAP_NO_ERROR in case of success or IOWA_COAP_404_NOT_FOUND if there are no block information to retrieve. // Parameters: // - dataP: the iowa_lwm2m_data_t to retrieve the block info from. // - numberP: OUT. the block number. // - moreP: OUT. true if there are more blocks coming. // - sizeP: OUT. the size of the block. iowa_status_t iowa_data_get_block_info ( iowa_lwm2m_data_t * dataP , uint16_t * numberP , bool * moreP , uint16_t * sizeP ); // Set block information of an iowa_lwm2m_data_t. // Returned value: IOWA_COAP_NO_ERROR in case of success or an error status. // Parameters: // - dataP: the iowa_lwm2m_data_t to set the info to. // - number: the block number. // - more: true if there are more blocks coming. // - size: the size of the block. It must be inferior to 1024. iowa_status_t iowa_data_set_block_info ( iowa_lwm2m_data_t * dataP , uint16_t number , bool more , uint16_t size ); When calling iowa_data_set_block_info , if more is set to true, due to the CoAP Block format used on the wire, size can only have one of the following values: #define IOWA_DATA_BLOCK_SIZE_16 16 #define IOWA_DATA_BLOCK_SIZE_32 32 #define IOWA_DATA_BLOCK_SIZE_64 64 #define IOWA_DATA_BLOCK_SIZE_128 128 #define IOWA_DATA_BLOCK_SIZE_256 256 #define IOWA_DATA_BLOCK_SIZE_512 512 #define IOWA_DATA_BLOCK_SIZE_1024 1024 On a READ on resource 1, the Object callback can return the data by block by doing: iowa_status_t objectCallback ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t contextP ) { size_t i ; my_application_data_t * appDataP ; size_t readLength ; uint8_t * buffer ; appDataP = ( my_application_data_t * ) userData ; switch ( operation ) { case IOWA_DM_READ : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 0 : dataP [ i ]. value . asBoolean = appDataP -> hasLogs ; break ; case 1 : // Here we read the data from a file by chunks of 512 bytes buffer = iowa_system_malloc ( IOWA_DATA_BLOCK_SIZE_512 ); readLength = fread ( buffer , 1 , IOWA_DATA_BLOCK_SIZE_512 , appDataP -> logFile ); if ( feof ( appDataP -> logFile ) == 0 ) { // There are more data to read, we use block dataP [ i ]. value . asBlock . buffer = buffer ; iowa_data_set_block_info ( dataP + i , 0 , true , readLength ); } else { // There are less than 512 bytes of data dataP [ i ]. value . asBuffer . buffer = buffer ; dataP [ i ]. value . asBuffer . length = readLength ; } break ; default : // Should not happen break ; } } break ; case IOWA_DM_FREE : for ( i = 0 ; i < numData ; i ++ ) { if ( dataP [ i ]. resourceID == 1 ) { if ( dataP [ i ]. type == IOWA_LWM2M_TYPE_STRING_BLOCK ) { iowa_system_free ( dataP [ i ]. value . asBlock . buffer ); } else { iowa_system_free ( dataP [ i ]. value . asBuffer . buffer ); } } } break ; (...) The code above works only for the first block. When IOWA receives from the Object callback a iowa_lwm2m_data_t with the type flag IOWA_LWM2M_TYPE_***_BLOCK set, if the more info is set to true, it calls again the callback to retrieve the next block. For the callback to determine which block is requested, IOWA sets the iowa_lwm2m_data_t::value::asBlock::details . A correct Object callback is: iowa_status_t objectCallback ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t contextP ) { size_t i ; my_application_data_t * appDataP ; size_t readLength ; uint8_t * buffer ; iowa_status_t result ; bool more ; uint32_t blockNumber ; uint16_t blockSize ; appDataP = ( my_application_data_t * ) userData ; switch ( operation ) { case IOWA_DM_READ : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 0 : dataP [ i ]. value . asBoolean = appDataP -> hasLogs ; break ; case 1 : // Determine if this is the initial read or a request for a next block // Note that the received more value has no meaning for a Read. if ( IOWA_COAP_NO_ERROR == iowa_data_get_block_info ( dataP + i , & blockNumber , & more , & blockSize )) { size_t index ; // Note that the received more value has no meaning for a Read. // *blockSize* bytes are to be read. // Note that the block size may be different from the one we chose in the initial read. buffer = iowa_system_malloc ( blockSize ); // Compute the index of the data to read index = blockSize * blockNumber ; // Read the data from the file at the index. fseek ( appDataP -> logFile , index , SEEK_SET ); readLength = fread ( buffer , 1 , blockSize , appDataP -> logFile ); if ( feof ( appDataP -> logFile ) == 0 ) { // There are more data to read more = true ; } else { more = false ; } // Set the info dataP [ i ]. value . asBlock . buffer = buffer ; iowa_data_set_block_info ( dataP + i , blockNumber , more , readLength ); } else { // This is an initial read, do as in the first example // Here we read the data from a file by chunks of 512 bytes buffer = iowa_system_malloc ( IOWA_DATA_BLOCK_SIZE_512 ); readLength = fread ( buffer , 1 , IOWA_DATA_BLOCK_SIZE_512 , appDataP -> logFile ); if ( feof ( appDataP -> logFile ) == 0 ) { // There are more data to read, we use block dataP [ i ]. value . asBlock . buffer = buffer ; iowa_data_set_block_info ( dataP + i , 0 , true , readLength ); } else { // There are less than 512 bytes of data dataP [ i ]. value . asBuffer . buffer = buffer ; dataP [ i ]. value . asBuffer . length = readLength ; } } break ; default : // Should not happen break ; } } break ; case IOWA_DM_FREE : for ( i = 0 ; i < numData ; i ++ ) { if ( dataP [ i ]. resourceID == 1 ) { if ( dataP [ i ]. type == IOWA_LWM2M_TYPE_STRING_BLOCK ) { iowa_system_free ( dataP [ i ]. value . asBlock . buffer ); } else { iowa_system_free ( dataP [ i ]. value . asBuffer . buffer ); } } } break ; (...) Note that depending on the LwM2M Server behavior or the transport MTU, the requested block size may vary. Note also that the blocks may be read out of order. Limitations \u00b6 As the resource value is retrieved by blocks, it is not possible to encode it in a multiple-resource format like SenML. Thus the Text, Opaque or CoRE-Link data formats will be used. If the LwM2M Server performs a Read on an Object or Object Instance containing a resource returned by blocks, the response will not include the streamable resource. To retrieve the value of the resource, the Server must perform a Read on the resource URI. For the same reasons, it is not possible to add timestamps to a streamable resource. A streamable resource cannot be asynchronous.","title":"Custom Object Streaming APIs"},{"location":"Streamable/#custom-object-streaming-apis","text":"Let's consider a proprietary LwM2M Object presenting Device generated logs with the following resources: Resource Name Resource ID Access Type Mandatory Type Description Logs Available 0 R Mandatory Boolean True means some logs are available. Logs 1 R Mandatory String The logs. The logs can be very large and thus needs to be retrieved by blocks.","title":"Custom Object Streaming APIs"},{"location":"Streamable/#object-declaration","text":"When declaring the Object, inform IOWA that the resource with ID 1 can be retrieved by blocks: iowa_lwm2m_resource_desc_t resources [ 2 ] = { { 0 , IOWA_LWM2M_TYPE_BOOLEAN , IOWA_DM_READ , IOWA_RESOURCE_FLAG_MANDATORY }, { 1 , IOWA_LWM2M_TYPE_STRING , IOWA_DM_READ , IOWA_RESOURCE_FLAG_MANDATORY | IOWA_RESOURCE_FLAG_STREAMABLE } };","title":"Object Declaration"},{"location":"Streamable/#callback-implementation","text":"In iowa.h , the iowa_lwm2m_data_t structure is expanded to to be able contain a block of a string, opaque, or CoRE Link value: typedef uint8_t iowa_lwm2m_data_type_t ; #define IOWA_LWM2M_TYPE_UNDEFINED 0 #define IOWA_LWM2M_TYPE_STRING 1 #define IOWA_LWM2M_TYPE_OPAQUE 2 #define IOWA_LWM2M_TYPE_INTEGER 3 #define IOWA_LWM2M_TYPE_FLOAT 4 #define IOWA_LWM2M_TYPE_BOOLEAN 5 #define IOWA_LWM2M_TYPE_CORE_LINK 6 #define IOWA_LWM2M_TYPE_OBJECT_LINK 7 #define IOWA_LWM2M_TYPE_TIME 8 #define IOWA_LWM2M_TYPE_UNSIGNED_INTEGER 9 #define IOWA_LWM2M_TYPE_STRING_BLOCK 101 #define IOWA_LWM2M_TYPE_OPAQUE_BLOCK 102 #define IOWA_LWM2M_TYPE_CORE_LINK_BLOCK 106 typedef struct { uint16_t objectID ; uint16_t instanceID ; uint16_t resourceID ; uint16_t resInstanceID ; iowa_lwm2m_data_type_t type ; union { bool asBoolean ; int64_t asInteger ; double asFloat ; struct { size_t length ; uint8_t * buffer ; } asBuffer ; struct { uint32_t details ; uint8_t * buffer ; } asBlock ; iowa_lwm2m_object_link_t asObjLink ; } value ; int32_t timestamp ; } iowa_lwm2m_data_t ; iowa_lwm2m_data_t::value::asBlock::buffer contains the block of data. iowa_lwm2m_data_t::value::asBlock::details contains the information of the block. It is to be treated as an opaque type and must be accessed only with the helper functions below: // Get block information from an iowa_lwm2m_data_t. // Returned value: IOWA_COAP_NO_ERROR in case of success or IOWA_COAP_404_NOT_FOUND if there are no block information to retrieve. // Parameters: // - dataP: the iowa_lwm2m_data_t to retrieve the block info from. // - numberP: OUT. the block number. // - moreP: OUT. true if there are more blocks coming. // - sizeP: OUT. the size of the block. iowa_status_t iowa_data_get_block_info ( iowa_lwm2m_data_t * dataP , uint16_t * numberP , bool * moreP , uint16_t * sizeP ); // Set block information of an iowa_lwm2m_data_t. // Returned value: IOWA_COAP_NO_ERROR in case of success or an error status. // Parameters: // - dataP: the iowa_lwm2m_data_t to set the info to. // - number: the block number. // - more: true if there are more blocks coming. // - size: the size of the block. It must be inferior to 1024. iowa_status_t iowa_data_set_block_info ( iowa_lwm2m_data_t * dataP , uint16_t number , bool more , uint16_t size ); When calling iowa_data_set_block_info , if more is set to true, due to the CoAP Block format used on the wire, size can only have one of the following values: #define IOWA_DATA_BLOCK_SIZE_16 16 #define IOWA_DATA_BLOCK_SIZE_32 32 #define IOWA_DATA_BLOCK_SIZE_64 64 #define IOWA_DATA_BLOCK_SIZE_128 128 #define IOWA_DATA_BLOCK_SIZE_256 256 #define IOWA_DATA_BLOCK_SIZE_512 512 #define IOWA_DATA_BLOCK_SIZE_1024 1024 On a READ on resource 1, the Object callback can return the data by block by doing: iowa_status_t objectCallback ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t contextP ) { size_t i ; my_application_data_t * appDataP ; size_t readLength ; uint8_t * buffer ; appDataP = ( my_application_data_t * ) userData ; switch ( operation ) { case IOWA_DM_READ : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 0 : dataP [ i ]. value . asBoolean = appDataP -> hasLogs ; break ; case 1 : // Here we read the data from a file by chunks of 512 bytes buffer = iowa_system_malloc ( IOWA_DATA_BLOCK_SIZE_512 ); readLength = fread ( buffer , 1 , IOWA_DATA_BLOCK_SIZE_512 , appDataP -> logFile ); if ( feof ( appDataP -> logFile ) == 0 ) { // There are more data to read, we use block dataP [ i ]. value . asBlock . buffer = buffer ; iowa_data_set_block_info ( dataP + i , 0 , true , readLength ); } else { // There are less than 512 bytes of data dataP [ i ]. value . asBuffer . buffer = buffer ; dataP [ i ]. value . asBuffer . length = readLength ; } break ; default : // Should not happen break ; } } break ; case IOWA_DM_FREE : for ( i = 0 ; i < numData ; i ++ ) { if ( dataP [ i ]. resourceID == 1 ) { if ( dataP [ i ]. type == IOWA_LWM2M_TYPE_STRING_BLOCK ) { iowa_system_free ( dataP [ i ]. value . asBlock . buffer ); } else { iowa_system_free ( dataP [ i ]. value . asBuffer . buffer ); } } } break ; (...) The code above works only for the first block. When IOWA receives from the Object callback a iowa_lwm2m_data_t with the type flag IOWA_LWM2M_TYPE_***_BLOCK set, if the more info is set to true, it calls again the callback to retrieve the next block. For the callback to determine which block is requested, IOWA sets the iowa_lwm2m_data_t::value::asBlock::details . A correct Object callback is: iowa_status_t objectCallback ( iowa_dm_operation_t operation , iowa_lwm2m_data_t * dataP , size_t numData , void * userData , iowa_context_t contextP ) { size_t i ; my_application_data_t * appDataP ; size_t readLength ; uint8_t * buffer ; iowa_status_t result ; bool more ; uint32_t blockNumber ; uint16_t blockSize ; appDataP = ( my_application_data_t * ) userData ; switch ( operation ) { case IOWA_DM_READ : for ( i = 0 ; i < numData ; i ++ ) { switch ( dataP [ i ]. resourceID ) { case 0 : dataP [ i ]. value . asBoolean = appDataP -> hasLogs ; break ; case 1 : // Determine if this is the initial read or a request for a next block // Note that the received more value has no meaning for a Read. if ( IOWA_COAP_NO_ERROR == iowa_data_get_block_info ( dataP + i , & blockNumber , & more , & blockSize )) { size_t index ; // Note that the received more value has no meaning for a Read. // *blockSize* bytes are to be read. // Note that the block size may be different from the one we chose in the initial read. buffer = iowa_system_malloc ( blockSize ); // Compute the index of the data to read index = blockSize * blockNumber ; // Read the data from the file at the index. fseek ( appDataP -> logFile , index , SEEK_SET ); readLength = fread ( buffer , 1 , blockSize , appDataP -> logFile ); if ( feof ( appDataP -> logFile ) == 0 ) { // There are more data to read more = true ; } else { more = false ; } // Set the info dataP [ i ]. value . asBlock . buffer = buffer ; iowa_data_set_block_info ( dataP + i , blockNumber , more , readLength ); } else { // This is an initial read, do as in the first example // Here we read the data from a file by chunks of 512 bytes buffer = iowa_system_malloc ( IOWA_DATA_BLOCK_SIZE_512 ); readLength = fread ( buffer , 1 , IOWA_DATA_BLOCK_SIZE_512 , appDataP -> logFile ); if ( feof ( appDataP -> logFile ) == 0 ) { // There are more data to read, we use block dataP [ i ]. value . asBlock . buffer = buffer ; iowa_data_set_block_info ( dataP + i , 0 , true , readLength ); } else { // There are less than 512 bytes of data dataP [ i ]. value . asBuffer . buffer = buffer ; dataP [ i ]. value . asBuffer . length = readLength ; } } break ; default : // Should not happen break ; } } break ; case IOWA_DM_FREE : for ( i = 0 ; i < numData ; i ++ ) { if ( dataP [ i ]. resourceID == 1 ) { if ( dataP [ i ]. type == IOWA_LWM2M_TYPE_STRING_BLOCK ) { iowa_system_free ( dataP [ i ]. value . asBlock . buffer ); } else { iowa_system_free ( dataP [ i ]. value . asBuffer . buffer ); } } } break ; (...) Note that depending on the LwM2M Server behavior or the transport MTU, the requested block size may vary. Note also that the blocks may be read out of order.","title":"Callback Implementation"},{"location":"Streamable/#limitations","text":"As the resource value is retrieved by blocks, it is not possible to encode it in a multiple-resource format like SenML. Thus the Text, Opaque or CoRE-Link data formats will be used. If the LwM2M Server performs a Read on an Object or Object Instance containing a resource returned by blocks, the response will not include the streamable resource. To retrieve the value of the resource, the Server must perform a Read on the resource URI. For the same reasons, it is not possible to add timestamps to a streamable resource. A streamable resource cannot be asynchronous.","title":"Limitations"},{"location":"UtilsAPI/","text":"Utils API Reference \u00b6 The functions explained below are defined inside the file include/iowa_utils.h . Data types \u00b6 iowa_list_t \u00b6 List structure used by the List APIs. typedef struct _iowa_list_t { struct _iowa_list_t * nextP ; } iowa_list_t ; nextP : Pointer to the next element in the list. \\clearpage Callbacks \u00b6 iowa_list_node_free_callback_t \u00b6 This is the list node free callback, called to free a node. typedef void ( * iowa_list_node_free_callback_t ) ( void * nodeP ); nodeP : The node to free. \\clearpage iowa_list_node_find_callback_t \u00b6 This is the list node find callback, called to find a node. typedef bool ( * iowa_list_node_find_callback_t ) ( void * nodeP , void * criteria ); nodeP : The current node in the list. criteria : The criteria to match. \\clearpage API \u00b6 iowa_utils_base64_get_encoded_size \u00b6 Prototype size_t iowa_utils_base64_get_encoded_size ( size_t rawBufferLen ); Description iowa_utils_base64_get_encoded_size() calculates the length of a Base64 buffer based on a raw buffer represented by its length. Arguments rawBufferLen : The length of the raw buffer. Return Value The length of the Base64 buffer. Header File iowa_utils.h \\clearpage iowa_utils_base64_get_decoded_size \u00b6 Prototype size_t iowa_utils_base64_get_decoded_size ( uint8_t * base64Buffer , size_t base64BufferLen ); Description iowa_utils_base64_get_decoded_size() calculates the length of a raw buffer based on a Base64 buffer. Arguments base64Buffer : The Base64 buffer. base64BufferLen : The length of the Base64 buffer. Return Value The length of the raw buffer. If any error the length will be 0. Header File iowa_utils.h \\clearpage iowa_utils_base64_encode \u00b6 Prototype size_t iowa_utils_base64_encode ( uint8_t * rawBuffer , size_t rawBufferLen , uint8_t * base64Buffer , size_t base64BufferLen ); Description iowa_utils_base64_encode() encodes a raw buffer using Base64. Arguments rawBuffer : The raw buffer. rawBufferLen : The length of the raw buffer. base64Buffer : The preallocated Base64 buffer. base64BufferLen : The length of the preallocated Base64 buffer. Return Value The length of the encoded buffer. If any error the length will be 0. Header File iowa_utils.h \\clearpage iowa_utils_base64_decode \u00b6 Prototype size_t iowa_utils_base64_decode ( uint8_t * base64Buffer , size_t base64BufferLen , uint8_t * rawBuffer , size_t rawBufferLen ); Description iowa_utils_base64_decode() decodes a Base64 buffer into a raw buffer. Arguments base64Buffer : The Base64 buffer. base64BufferLen : The length of the Base64 buffer. rawBuffer : The preallocated raw buffer. rawBufferLen : The length of the preallocated raw buffer. Return Value The length of the decoded buffer. If any error the length will be 0. Header File iowa_utils.h \\clearpage iowa_utils_uri_to_sensor \u00b6 Prototype iowa_sensor_t iowa_utils_uri_to_sensor ( iowa_lwm2m_uri_t * uriP ); Description iowa_utils_uri_to_sensor() converts an iowa_lwm2m_uri_t into an iowa_sensor_t. Arguments uriP : Uri to convert. Return Value The corresponding iowa_sensor_t or IOWA_INVALID_SENSOR_ID in case of error. Header File iowa_utils.h \\clearpage iowa_utils_sensor_to_uri \u00b6 Prototype iowa_lwm2m_uri_t iowa_utils_sensor_to_uri ( iowa_sensor_t id ); Description iowa_utils_sensor_to_uri() converts an iowa_sensor_t into an iowa_lwm2m_uri_t. Arguments id : Id to convert. Return Value An iowa_lwm2m_uri_t. Header File iowa_utils.h \\clearpage iowa_utils_list_add \u00b6 Prototype iowa_list_t * iowa_utils_list_add ( iowa_list_t * headP , iowa_list_t * nodeP ); Description iowa_utils_list_add() adds a node to a list. Arguments headP : Head of the current list. nodeP : Node to add to the list. Return Value The list with the new element. Header File iowa_utils.h \\clearpage iowa_utils_list_remove \u00b6 Prototype iowa_list_t * iowa_utils_list_remove ( iowa_list_t * headP , iowa_list_t * nodeP ); Description iowa_utils_list_remove() removes a node from a list. Arguments headP : Head of the current list. nodeP : Node to remove from the list. Return Value The updated list. Header File iowa_utils.h \\clearpage iowa_utils_list_free \u00b6 Prototype void iowa_utils_list_free ( iowa_list_t * headP , iowa_list_node_free_callback_t freeCb ); Description iowa_utils_list_free() adds a node to a list. Arguments headP : List to free. freeCb : Callback used to free the list. Return Value None. Header File iowa_utils.h \\clearpage iowa_utils_list_find \u00b6 Prototype iowa_list_t * iowa_utils_list_find ( iowa_list_t * headP , iowa_list_node_find_callback_t findCb , void * criteriaP ); Description iowa_utils_list_find() finds a node in a list. Arguments headP : List to search on. findCb : Callback used to find the node in the list. criteriaP : Criteria used to find the node in the list. Return Value The node if found else NULL. Header File iowa_utils.h \\clearpage iowa_utils_list_find_and_remove \u00b6 Prototype iowa_list_t * iowa_utils_list_find_and_remove ( iowa_list_t * headP , iowa_list_node_find_callback_t findCb , void * criteriaP , iowa_list_t ** nodeP ); Description iowa_utils_list_find_and_remove() finds a node in a list and removes it. Arguments headP : List to search on. findCb : Callback used to find the node in the list. criteriaP : Criteria used to find the node in the list. nodeP : OUT. Node removed from the list. Can be nil. Return Value The updated list. Header File iowa_utils.h \\clearpage Example: Linked List usage \u00b6 When declaring the linked list data structure, the first member must be a pointer. This pointer will contain the address of the next element of the list. Example: struct myData { struct myData * nextP ; // Used by the linked list functions char * aString ; int anInt ; }; The head of the list is a pointer to your data structure. Example: struct myData * listHead ; You can now add or remove elements to the list by using the functions iowa_utils_list_add() and iowa_utils_list_remove() . But to avoid compiler warnings or multiple cast making the code unreadable, the following macros can be used: IOWA_UTILS_LIST_ADD(H, N) IOWA_UTILS_LIST_REMOVE(H, N) IOWA_UTILS_LIST_FREE(H, F) IOWA_UTILS_LIST_FIND(H, F, C) IOWA_UTILS_LIST_FIND_AND_REMOVE(H, F, C, N) Instead of calling: listHead = ( struct myData * ) iowa_utils_list_add (( iowa_list_t * ) listHead , ( iowa_list_t * ) newDataP ); You can use: listHead = ( struct myData * ) IOWA_UTILS_LIST_ADD ( listHead , newDataP );","title":"Utils APIs"},{"location":"UtilsAPI/#utils-api-reference","text":"The functions explained below are defined inside the file include/iowa_utils.h .","title":"Utils API Reference"},{"location":"UtilsAPI/#data-types","text":"","title":"Data types"},{"location":"UtilsAPI/#iowa_list_t","text":"List structure used by the List APIs. typedef struct _iowa_list_t { struct _iowa_list_t * nextP ; } iowa_list_t ; nextP : Pointer to the next element in the list. \\clearpage","title":"iowa_list_t"},{"location":"UtilsAPI/#callbacks","text":"","title":"Callbacks"},{"location":"UtilsAPI/#iowa_list_node_free_callback_t","text":"This is the list node free callback, called to free a node. typedef void ( * iowa_list_node_free_callback_t ) ( void * nodeP ); nodeP : The node to free. \\clearpage","title":"iowa_list_node_free_callback_t"},{"location":"UtilsAPI/#iowa_list_node_find_callback_t","text":"This is the list node find callback, called to find a node. typedef bool ( * iowa_list_node_find_callback_t ) ( void * nodeP , void * criteria ); nodeP : The current node in the list. criteria : The criteria to match. \\clearpage","title":"iowa_list_node_find_callback_t"},{"location":"UtilsAPI/#api","text":"","title":"API"},{"location":"UtilsAPI/#iowa_utils_base64_get_encoded_size","text":"Prototype size_t iowa_utils_base64_get_encoded_size ( size_t rawBufferLen ); Description iowa_utils_base64_get_encoded_size() calculates the length of a Base64 buffer based on a raw buffer represented by its length. Arguments rawBufferLen : The length of the raw buffer. Return Value The length of the Base64 buffer. Header File iowa_utils.h \\clearpage","title":"iowa_utils_base64_get_encoded_size"},{"location":"UtilsAPI/#iowa_utils_base64_get_decoded_size","text":"Prototype size_t iowa_utils_base64_get_decoded_size ( uint8_t * base64Buffer , size_t base64BufferLen ); Description iowa_utils_base64_get_decoded_size() calculates the length of a raw buffer based on a Base64 buffer. Arguments base64Buffer : The Base64 buffer. base64BufferLen : The length of the Base64 buffer. Return Value The length of the raw buffer. If any error the length will be 0. Header File iowa_utils.h \\clearpage","title":"iowa_utils_base64_get_decoded_size"},{"location":"UtilsAPI/#iowa_utils_base64_encode","text":"Prototype size_t iowa_utils_base64_encode ( uint8_t * rawBuffer , size_t rawBufferLen , uint8_t * base64Buffer , size_t base64BufferLen ); Description iowa_utils_base64_encode() encodes a raw buffer using Base64. Arguments rawBuffer : The raw buffer. rawBufferLen : The length of the raw buffer. base64Buffer : The preallocated Base64 buffer. base64BufferLen : The length of the preallocated Base64 buffer. Return Value The length of the encoded buffer. If any error the length will be 0. Header File iowa_utils.h \\clearpage","title":"iowa_utils_base64_encode"},{"location":"UtilsAPI/#iowa_utils_base64_decode","text":"Prototype size_t iowa_utils_base64_decode ( uint8_t * base64Buffer , size_t base64BufferLen , uint8_t * rawBuffer , size_t rawBufferLen ); Description iowa_utils_base64_decode() decodes a Base64 buffer into a raw buffer. Arguments base64Buffer : The Base64 buffer. base64BufferLen : The length of the Base64 buffer. rawBuffer : The preallocated raw buffer. rawBufferLen : The length of the preallocated raw buffer. Return Value The length of the decoded buffer. If any error the length will be 0. Header File iowa_utils.h \\clearpage","title":"iowa_utils_base64_decode"},{"location":"UtilsAPI/#iowa_utils_uri_to_sensor","text":"Prototype iowa_sensor_t iowa_utils_uri_to_sensor ( iowa_lwm2m_uri_t * uriP ); Description iowa_utils_uri_to_sensor() converts an iowa_lwm2m_uri_t into an iowa_sensor_t. Arguments uriP : Uri to convert. Return Value The corresponding iowa_sensor_t or IOWA_INVALID_SENSOR_ID in case of error. Header File iowa_utils.h \\clearpage","title":"iowa_utils_uri_to_sensor"},{"location":"UtilsAPI/#iowa_utils_sensor_to_uri","text":"Prototype iowa_lwm2m_uri_t iowa_utils_sensor_to_uri ( iowa_sensor_t id ); Description iowa_utils_sensor_to_uri() converts an iowa_sensor_t into an iowa_lwm2m_uri_t. Arguments id : Id to convert. Return Value An iowa_lwm2m_uri_t. Header File iowa_utils.h \\clearpage","title":"iowa_utils_sensor_to_uri"},{"location":"UtilsAPI/#iowa_utils_list_add","text":"Prototype iowa_list_t * iowa_utils_list_add ( iowa_list_t * headP , iowa_list_t * nodeP ); Description iowa_utils_list_add() adds a node to a list. Arguments headP : Head of the current list. nodeP : Node to add to the list. Return Value The list with the new element. Header File iowa_utils.h \\clearpage","title":"iowa_utils_list_add"},{"location":"UtilsAPI/#iowa_utils_list_remove","text":"Prototype iowa_list_t * iowa_utils_list_remove ( iowa_list_t * headP , iowa_list_t * nodeP ); Description iowa_utils_list_remove() removes a node from a list. Arguments headP : Head of the current list. nodeP : Node to remove from the list. Return Value The updated list. Header File iowa_utils.h \\clearpage","title":"iowa_utils_list_remove"},{"location":"UtilsAPI/#iowa_utils_list_free","text":"Prototype void iowa_utils_list_free ( iowa_list_t * headP , iowa_list_node_free_callback_t freeCb ); Description iowa_utils_list_free() adds a node to a list. Arguments headP : List to free. freeCb : Callback used to free the list. Return Value None. Header File iowa_utils.h \\clearpage","title":"iowa_utils_list_free"},{"location":"UtilsAPI/#iowa_utils_list_find","text":"Prototype iowa_list_t * iowa_utils_list_find ( iowa_list_t * headP , iowa_list_node_find_callback_t findCb , void * criteriaP ); Description iowa_utils_list_find() finds a node in a list. Arguments headP : List to search on. findCb : Callback used to find the node in the list. criteriaP : Criteria used to find the node in the list. Return Value The node if found else NULL. Header File iowa_utils.h \\clearpage","title":"iowa_utils_list_find"},{"location":"UtilsAPI/#iowa_utils_list_find_and_remove","text":"Prototype iowa_list_t * iowa_utils_list_find_and_remove ( iowa_list_t * headP , iowa_list_node_find_callback_t findCb , void * criteriaP , iowa_list_t ** nodeP ); Description iowa_utils_list_find_and_remove() finds a node in a list and removes it. Arguments headP : List to search on. findCb : Callback used to find the node in the list. criteriaP : Criteria used to find the node in the list. nodeP : OUT. Node removed from the list. Can be nil. Return Value The updated list. Header File iowa_utils.h \\clearpage","title":"iowa_utils_list_find_and_remove"},{"location":"UtilsAPI/#example-linked-list-usage","text":"When declaring the linked list data structure, the first member must be a pointer. This pointer will contain the address of the next element of the list. Example: struct myData { struct myData * nextP ; // Used by the linked list functions char * aString ; int anInt ; }; The head of the list is a pointer to your data structure. Example: struct myData * listHead ; You can now add or remove elements to the list by using the functions iowa_utils_list_add() and iowa_utils_list_remove() . But to avoid compiler warnings or multiple cast making the code unreadable, the following macros can be used: IOWA_UTILS_LIST_ADD(H, N) IOWA_UTILS_LIST_REMOVE(H, N) IOWA_UTILS_LIST_FREE(H, F) IOWA_UTILS_LIST_FIND(H, F, C) IOWA_UTILS_LIST_FIND_AND_REMOVE(H, F, C, N) Instead of calling: listHead = ( struct myData * ) iowa_utils_list_add (( iowa_list_t * ) listHead , ( iowa_list_t * ) newDataP ); You can use: listHead = ( struct myData * ) IOWA_UTILS_LIST_ADD ( listHead , newDataP );","title":"Example: Linked List usage"}]}